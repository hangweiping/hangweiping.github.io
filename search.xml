<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[前端要知道的知识点]]></title>
      <url>http://hangweiping.github.io/2016/07/05/%E5%89%8D%E7%AB%AF%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p><img src="../images/HTML常用标签.jpg" alt=""></p>
<a id="more"></a>
<h2 id="1、HTML-HTML5基础："><a href="#1、HTML-HTML5基础：" class="headerlink" title="1、HTML/HTML5基础："></a>1、HTML/HTML5基础：</h2><p><code>1.0、</code>语义化<code>H5</code>标签<br><code>1.1</code>、H5引进了一些新的标签，特别注意<code>article、header、footer、aside、nav</code>等，注意<code>HTML</code>的标题结构<br><code>1.2、</code>理解浏览器解析<code>HTML</code>的过程，理解<code>DOM</code>的树形结构，及相应<code>API</code><br><code>1.3、</code>理解<code>HTML</code>标签在各个浏览器上的默认样式（代理样式），理解CSS中的重置样式表的概念<br><code>1.4、</code>理解<code>Canvas、SVG、video</code>等功能性标签<br><code>1.5</code>、理解<code>form、iframe</code>标签，理解文件提交过程<br>推荐书籍：</p>
<p>推荐书籍：<br>A、《HTML5秘籍》</p>
<h2 id="2、高健壮性CSS"><a href="#2、高健壮性CSS" class="headerlink" title="2、高健壮性CSS"></a>2、高健壮性<code>CSS</code></h2><p><code>2.1、</code>学习基础知识，包括大部分常用属性、选择器的用法，要对大多数标签有个基础概念,在日常使用的基础上，尝试学习浏览器兼容性问题，要知道兼容性的主要问题及解决方法<br><code>2.2、</code>深入理解盒子模型，区分块级元素、行内元素，有几个比较重要的属性：<code>display、float、position</code>，一定要弄清楚区分盒子、行内盒子的概念另外可以考虑学一些预编译语言：<code>sass、less</code>，都很简单<br><code>2.3、</code>学习常用框架，可以使用<code>bootstrap</code>构建项目<br><code>2.4、</code>学习框架的代码组织方式包括：<code>12</code>格栅系统、组件化、组件的风格化等<br><code>2.5、</code>学习<code>CSS3</code>的新功能，特别是动画效果、选择器<br><code>2.6、</code>认真学习一些<code>CSS</code>对象化思想，学习编写简洁性、高复用性、高健壮性的<code>CSS</code><br><code>2.7、</code>有空的话，可以看看所谓的扁平化设计，还有简洁性<br><code>2.8、</code>理解<code>CSSOM、render、reflow、CSS</code>性能、<code>CSS</code>阻塞概念<br>学习方法：<br>1、多看别人的代码，一些设计的不错的网站就是很好的学习素材，比如拉勾网<br>2、一定要学会使用grunt、gulp压缩CSS<br>3、display + position + float 可以组合出很复杂的效果，多想想盒子模型<br>4、尝试在不用float，且position不为absolute的情况下实现等高、等宽等布局</p>
<p>推荐书籍：<br>1、《图灵程序设计丛书:HTML5与CSS3设计模式》<br>2、《Web开发技术丛书:深入理解Bootstrap》<br>3、《高流量网站CSS开发技术》<br>4、《CSS设计彻底研究》 这个一定要<br>5、《Web开发技术丛书:深入理解Bootstrap》<br>6、可以找一些专门讲SASS的书，但是我没找到<br>7、《CSS权威指南(第3版)》</p>
<h2 id="3、深入学习JS"><a href="#3、深入学习JS" class="headerlink" title="3、深入学习JS"></a>3、深入学习JS</h2><p><code>3.1、</code>重新学习JS语法，注意：表达式（特别是函数访问表达式）、语句、类型（包括类型判断)注意，这个时候主要倾向于“原生”JS哦，不要使用框架<br><code>3.2、</code>深入理解JS的“一级函数”、对象、类的概念,学会使用函数来构造类、闭包，学会用面向对象的方式组织代码<br><code>3.3、</code>深入理解JS的作用域、作用域链、this对象（在各种调用形式中，this的指向）理解函数的各种调用方法（call、apply、bind等）<br><code>3.4、</code>理解对象、数组的概念<br>理解对象的“[]”调用，理解对象是一种“特殊数组”<br>理解for语句的用法<br>深入理解JS中原始值、包装对象的概念（重要）<br><code>3.5、</code>学习一些常用框架的使用方法，包括：<code>JQUERY、underscore、EXTJS，</code>加分点有：<code>vuejs、react,angularjs、ejs、jade</code><br>通过比较多个框架的使用方法，想清楚“JS语言极其灵活”这一事实<br>总结常见用法，提高学习速度<br>学习模块化开发（使用require.js、sea.js等）<br><code>3.6、</code>适当看一些著名框架的源码，比如jQuery（不建议看angularjs，太复杂了）<br>重要的是学习框架中代码的组织形式，即设计模式<br><code>3.7、</code>了解JS解释、运行过程，理解JS的单线程概念<br>深入理解JS事件、异步、阻塞概念<br><code>3.8、</code>理解浏览器组成部件，理解V8的概念<br>学习V8的解释-运行过程<br>在V8基础上，学会如何提高JS性能<br>学会使用chrome的profile进行内存泄露分析<br>学习方法：<br>1、提高对自己的要求，要有代码洁癖<br>2、适当的时候看看优秀框架的源码，特别是框架的架构模式、设计模式<br>3、多学学设计模式<br>4、学习原生JS、DOM、BOM、Ajax<br>推荐书籍：<br>1、《O’Reilly精品图书系列:​JavaScript权威指南(​第6版)》 必看<br>2、《JavaScript设计模式》<br>3、《WebKit技术内幕》<br>4、《JavaScript框架高级编​程:应用Prototype YUI Ext JS Dojo MooTools》<br>5、《用AngularJS开发下一代Web应用》<br>6、跨终端<br>6.1、理解混合APP的概念<br>6.2、理解网页在各类终端上的表现<br>6.3、理解网页与原生app的区同，重在约束<br>6.4、理解单页网站，特别要规避页面的内存泄露问题<br>6.5、入门nodejs，对其有个基础概念，知道它能做什么，缺点是什么<br>推荐书籍：<br>1、《单页Web应用:JavaScript从前端到后端 》<br>2、《Web 2.0界面设计模式》<br>3、《响应式Web设计:HTML5和​CSS3实战》<br>5、工具<br>学会使用grunt进行JS、CSS、HTML 压缩，特别是模块化js开发时候的压缩<br>会用PS进行切图、保存icon<br>入手sublime、webstorm<br>学会使用chrome调试面板，特别是：console、network、profile、element</p>
<hr>
<p><strong>进阶</strong>：</p>
<h2 id="4、性能"><a href="#4、性能" class="headerlink" title="4、性能"></a>4、性能</h2><p>1.1、理解资源加载的过程<br>包括：TCP握手连接、HTTP请求报文、HTTP回复报文<br>1.2、理解资源加载的性能约束，包括：TCP连接限制、TCP慢启动<br>1.3、理解CSS文件、JS文件压缩，理解不同文件放在页面不同位置后对性能的影响<br>1.4、理解CDN加速<br>1.5、学会使用HTTP头控制资源缓存，理解cache-control、expire、max-age、ETag对缓存的影响<br>1.6、深入理解浏览器的render过程<br>推荐书籍：<br>1、《Web性能权威指南》<br>2、雅虎网站页面性能优化的34条黄金守则</p>
<h2 id="5、http及TCP协议族"><a href="#5、http及TCP协议族" class="headerlink" title="5、http及TCP协议族"></a>5、http及TCP协议族</h2><p><code>2.1</code>、学习http协议，理解http请求-响应模式<br><code>2.2、</code>理解http是应用层协议，它是构建在TCP/IP协议上的<br><code>2.3、</code>理解http报文（请求-响应报文）<br><code>2.4、</code>理解http代理、缓存、网关等概念，指定如何控制缓存<br><code>2.5、</code>理解http协议内容，包括：状态码、http头、长连接（http1.1）<br><code>2.6、</code>学习http服务器的工作模型，对静态文件、CGI、DHTML的处理流程有个大致概念</p>
<p>推荐书籍：<br>1、《HTTP权威指南》<br>2、《TCP/IP详解》<br>3、《图解TCP/IP(第5版)》</p>
<h2 id="6、安全性"><a href="#6、安全性" class="headerlink" title="6、安全性"></a>6、安全性</h2><p><code>XSS、SQL</code>注入</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS设计指南-读书笔记]]></title>
      <url>http://hangweiping.github.io/2016/07/03/CSS%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>只要能把本书读懂、吃透，自称“CSS老手”绝对没人敢说你吹牛皮。要是能将书中给出的建议和提示融会贯通地运用到自己的项目当中，那“CSS高手”这顶桂冠也将非你莫属！<br><a id="more"></a></p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-2-HTML-文档剖析"><a href="#1-2-HTML-文档剖析" class="headerlink" title="1.2 HTML 文档剖析"></a>1.2 HTML 文档剖析</h3><p>作者在这节主要讲了一个 HTML 页面所需的最基本的文档结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 这里是网页内容 --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>首先 <code>&lt;!DOCTYPE html&gt;</code> 是 HTML5 中新的文档类型声明语法，相比 HTML4 的冗长文档类型声明语法来说 HTML5 是大大的简化了。</p>
<h4 id="1-2-2-块级元素和行内元素"><a href="#1-2-2-块级元素和行内元素" class="headerlink" title="1.2.2 块级元素和行内元素"></a>1.2.2 块级元素和行内元素</h4><p>作者在这一节介绍了两个比较重要的概念————块级元素和行内元素，默认情况下块级元素会始终占居一行，而行内元素并不会。除了 table 元素的 display 属性比较特殊以外，基本上所有的 HTML 元素的 display 的属性值要么是 block，要么是 inline。作者的一个思想是，无论你想了解哪个 HTML 元素，第一个要问的问题就是：它是块级元素还是行内元素，然后在编写标记的时候预想到这个元素在初始状态下是如何定位的，这样才能进一步想好将来怎么用 CSS 重新定位它，因为块级元素和行内元素在定位上有很大的区别，后面的拓展会详细说明。</p>
<p>块级元素盒子（一个很重要的概念————盒模型，后面会详细说明）会扩展到与父元素同宽，这也是为什么块级元素会占居一行的原因了，因为所有块级元素的父元素都是 body，而它的默认宽度就是浏览器的视口（viewport）大小，所以默认情况下块级元素的宽度也和浏览器的视口一样宽，这样以来，一个块级元素旁边也就没有空间来容纳另一个块级元素了。</p>
<p>相比于块级元素会扩展到与父元素同宽，然而行内元素的行为却是恰恰相反，它会尽量的「收缩包裹」其内容（也是盒模型的概念），这也就是为什么几个行内元素会并排显示在一行直到它们排满一行才会另起一行，而每个块级元素会直接另起一行的原因了。</p>
<p>拓展：</p>
<p>作者在这一节中并没有对块级元素和行内元素的一些其他特性进行详细的解释，在这里笔者对它们的一些特性知识进行拓展。首先先列出一些常见的块级元素和行内元素：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 常见的块级元素 --&gt;</div><div class="line"><span class="selector-tag">div</span>, <span class="selector-tag">form</span>, <span class="selector-tag">table</span>, <span class="selector-tag">header</span>, <span class="selector-tag">aside</span>, <span class="selector-tag">section</span>, <span class="selector-tag">article</span>, <span class="selector-tag">figure</span>, <span class="selector-tag">figcaption</span>, h1~<span class="selector-tag">h6</span>, <span class="selector-tag">nav</span>, <span class="selector-tag">p</span>, pre, blockqoute, <span class="selector-tag">canvas</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">dl</span></div><div class="line"></div><div class="line">&lt;!-- 常见的行内元素 --&gt;</div><div class="line"><span class="selector-tag">span</span>, <span class="selector-tag">a</span>, <span class="selector-tag">img</span>, <span class="selector-tag">label</span>, <span class="selector-tag">input</span>, select, <span class="selector-tag">textarea</span>, br, <span class="selector-tag">i</span>, <span class="selector-tag">em</span>, <span class="selector-tag">strong</span>, small, <span class="selector-tag">button</span>, sub, <span class="selector-tag">sup</span>, code</div></pre></td></tr></table></figure>
<p>之前作者提到过无论你想了解哪个 HTML 元素，第一个要问的问题就是：它是块级元素还是行内元素，因为它们在盒模型上的表现有很大的不同，不过在了解它们的不同之前我们还得先知道另外一个概念————<a href="http://www.w3.org/TR/html5/rendering.html#replaced-elements" target="_blank" rel="external">替换元素</a>和<a href="http://www.w3.org/TR/html5/rendering.html#non-replaced-elements" target="_blank" rel="external">非替换元素</a>，其中替换元素就是指浏览器是根据元素的属性来判断具体要显示的内容的元素，比如 <code>img</code> 标签，浏览器是根据其 <code>src</code> 的属性值来读取这个元素所包含的内容的，常见的替换元素还有 <code>input</code>、<code>textarea</code>、 <code>select</code>、 <code>object</code>、 <code>iframe</code> 和 <code>video</code> 等等，这些元素都有一个共同的特点，就是浏览器并不直接显示其内容，而是通过其某个属性的值来显示具体的内容，比如浏览器会根据 <code>input</code> 中的 <code>type</code> 的属性值来判断到底应该显示单选按钮还是多选按钮亦或是文本输入框。而对于非替换元素，比如 <code>p</code>、<code>label</code> 元素等等，浏览器这是直接显示元素所包含的内容。看到这里你应该大概的知道了什么是替换元素和非替换元素了。</p>
<p>对着两个概念有了大概的了解后就可以对 <code>block</code> 和 <code>inline</code> 在盒模型上的表现差异进行了解了，首先是 <code>margin</code> ，<a href="http://www.w3.org/TR/CSS2/box.html#margin-properties" target="_blank" rel="external">W3C</a> 对其所支持了元素对象是这么定义的：</p>
<blockquote>
<p>Applies to: all elements except elements with table display types other than table-caption, table and inline-table</p>
</blockquote>
<p>英语不是很好，没太明白这句话的意思，我的理解就是所有元素都支持 <code>margin</code> 除了 <code>display</code> 属性值为 <code>table-caption</code> 和 <code>table-inline</code>以外的所有表格显示类型比如 <code>table-row-group</code>、 <code>table-cell</code>、 <code>table-row</code> 和 <code>table-header-group</code>等等,但是为了验证我的理解，我发先 <code>display</code> 属性值为 <code>table</code> 的元素也支持，可能是我对原文标准的理解有误。但还有一个要特别注意的是 <code>margin-top</code> 和 <code>margin-bottom</code>两个属性比较特殊，它们对非替换行内元素没有效果，下面是 W3C 上对于 <code>margin-top</code> 和 <code>margin-bottom</code> 支持对象的介绍：</p>
<blockquote>
<p>Applies to: all elements except elements with table display types other than table-caption, table and inline-table</p>
<p>These properties have no effect on non-replaced inline elements.</p>
</blockquote>
<p>前面一句和之前对 <code>margin</code> 的描述是一样的，这毫无疑问，下面这句话的意思是这些（ <code>margin-top</code> 和 <code>margin-bottom</code> ）属性对非替换行内元素没有效果比如 <code>a</code> 和 <code>span</code>，注意这里是<strong>非替换行内元素</strong>而不单单是非替换元素或者是行内元素。比如 <code>img</code> 就是一个行内元素， <code>margin-top</code> 和 <code>margin-bottom</code> 对它是有效果的，因为它是一个替换元素而不是非替换元素，所以对于「 <code>margin-top</code> 和 <code>margin-bottom</code> 对行内元素没有效果」这种说法是不对的。</p>
<p>而对于 <code>padding</code> 的支持对象，W3C 是这么描述的：</p>
<blockquote>
<p>all elements except table-row-group, table-header-group, table-footer-group, table-row, table-column-group and table-column</p>
</blockquote>
<p>上面这句话的意思是除了表格显示类型为 <code>table-row-group</code>、 <code>table-header-group</code>、 <code>table-footer-group</code>、 <code>table-row</code>, <code>table-column-group</code> 和 <code>table-column</code> 的元素不支持，其他所有的元素都支持。</p>
<p>但这里有些特殊情况需要注意的是，对行内元素比如 <code>span</code> 和 <code>img</code> 设置左右内边距的效果是可见可，但是对行内元素设置上下内边距在有些情况下是不可见的，这些情况又要分为是否为替换元素和是否设置了背景色，为了能更直观的了解这些概念，我在这里做了个表格：</p>
<p>padding-top 和 padding-bottom 对于行内元素是否可见：</p>
<table>
<thead>
<tr>
<th></th>
<th>替换元素（e.g: input）</th>
<th>非替换元素（e.g: span）</th>
</tr>
</thead>
<tbody>
<tr>
<td>设置背景色</td>
<td>可见，影响行高，会撑开父元素</td>
<td>可见，不影响行高，不会撑开父元素</td>
</tr>
<tr>
<td>没有设置背景色</td>
<td>可见，影响行高，会撑开父元素</td>
<td>不可见，不影响行高，不会撑开父元素</td>
</tr>
</tbody>
</table>
<p>所以对于「 <code>padding-top</code> 和 <code>padding-bottom</code> 对行内元素没有效果」这种说法也是不对的，因为它们只是对于没有设置背景色的行内非替换元素效果不可见而已，而对于行内替换元素来说，不管是否设置了背景色都是有效果了，并且会把父元素撑开。</p>
<p>说了这么多 <code>block</code> 和 <code>inline-block</code> 的区别，其实除了这两个常见的 <code>display</code> 属性以外还有一个属性也是非常常见的，那就是 <code>inline-block</code> ，没错，这就是前面两种情况的结合体，它既有 <code>block</code> 的特性又有 <code>inline</code> 的特性，比如把一个 <code>display</code> 属性值为 <code>block</code> 或者<code>inline</code> 的元素属性值设置成 <code>inline-block</code> 后，既可以用只对行内元素有效的 <code>text-align: center;</code> 声明对其进行居中以外，还可以用<code>padding-top</code> 和 <code>padding-bottom</code> 对元素设置上下内边距而无需对其设置背景色，并且能把父元素撑开。</p>
<p>对于块级元素和行内元素的拓展就暂时到这，如果有不明白或者不对的地方也欢迎指出。</p>
<h3 id="1-3-文档对象模型"><a href="#1-3-文档对象模型" class="headerlink" title="1.3 文档对象模型"></a>1.3 文档对象模型</h3><p>作者在这一小节只要介绍了 HTML 结构所对应的文档对象模型（DOM,Document Object Model）,DOM 是从浏览器的视角来观察页面中的元素以及每个元素的属性，由此可以得出这些元素的一个家族树。通过 DOM 可以很清晰的看出文档中每个元素之间的关系。比如下面的 HTML 代码的 DOM 的家族树就如下图：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>The Document Object Model<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>The page's HTML markup structure defines the DOM.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/dom.png" alt="DOM"></p>
<p>上面是一个非常简单的 DOM 结构图，由此你可以和直观的看出 HTML 文档流中每个元素之间的关系，比如到底是父子元素还是兄弟元素。</p>
<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p>作者在本章主要讲解了 HTML 标签是怎么为内容提供结构的，以及每个元素会在屏幕上生成什么样子的盒子，比如是行内盒子还是块级盒子，最后又简单的讲解了什么是 DOM ，它是浏览器中文档的模型，而 CSS 可以修改 DOM 中的元素样式属性，从而修改页面本身的布局和外观。</p>
<h2 id="第二章-CSS-工作原理"><a href="#第二章-CSS-工作原理" class="headerlink" title="第二章 CSS 工作原理"></a>第二章 CSS 工作原理</h2><p>在本章中作者主要讲解了 CSS 如何对 HTML 添加样式的，并且解释了层叠的工作机制比如当元素的同一个属性被多次设置样式后到底应该选择何种样式，这就要靠 CSS 的层叠机制来决定最终应用哪种样式了。</p>
<p>每个 HTML 元素都有一组样式属性，这些属性涉及元素在文档流中显示时的不同方面，比如在文档流中的位置、边框、背景、颜色等等。CSS 就是一种先选择 HTML 元素，然后设定选中元素 CSS 属性的机制。CSS 选择符和要应用的样式构成一条 CSS 规则。</p>
<h3 id="2-2-上下文选择器"><a href="#2-2-上下文选择器" class="headerlink" title="2.2 上下文选择器"></a>2.2 上下文选择器</h3><p>上下文选择器的格式如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">标签<span class="number">1</span> 标签<span class="number">2</span> ｛ 声明｝</div></pre></td></tr></table></figure>
<p>其中标签2就是我们要选择的目标，而且只有在标签1是标签2的祖先元素（不一定是父级元素）的情况下才会被选中。上下文选择器严格来讲应该叫「后代组合式选择器（Descendant Comninator Selector）」。</p>
<p>还有一点要注意的是，上下文选择器以空格作为分隔符，而分组选择器则以逗号作为分隔符，不要弄混。</p>
<h3 id="2-3-特殊的上下文选择器"><a href="#2-3-特殊的上下文选择器" class="headerlink" title="2.3 特殊的上下文选择器"></a>2.3 特殊的上下文选择器</h3><p>前面一节作者介绍的上下文选择器是以某个祖先元素作为上下文的，只要目标元素在 DOM 结构「上游」存在这么一个祖先元素即可，无论这个祖先元素和目标元素隔了多少层级都没有关系，但有的时候我们需要比「某个祖先元素」更具体的上下文，这时候我们就可以使用一些特殊的选择器了，比如自选择器 <code>&gt;</code>、 紧邻兄弟选择器 <code>+</code>、一般兄弟选择器 <code>~</code> 和通用选择器 <code>*</code>。</p>
<h4 id="2-3-1-子选择器-gt"><a href="#2-3-1-子选择器-gt" class="headerlink" title="2.3.1 子选择器 &gt;"></a>2.3.1 子选择器 &gt;</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">标签<span class="number">1</span> &gt; 标签<span class="number">2</span></div></pre></td></tr></table></figure>
<p>这里的标签2必须是标签1的子元素，也就是说标签1必须是标签2的父元素，而不能是标签2的任何其他祖先元素。</p>
<h4 id="2-3-2-紧邻兄弟选择器"><a href="#2-3-2-紧邻兄弟选择器" class="headerlink" title="2.3.2 紧邻兄弟选择器 +"></a>2.3.2 紧邻兄弟选择器 +</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">标签<span class="number">1</span> + 标签<span class="number">2</span></div></pre></td></tr></table></figure>
<p>在这里标签2必须紧跟在兄弟标签1的后面，否则无效。</p>
<h4 id="2-3-3-一般兄弟选择器"><a href="#2-3-3-一般兄弟选择器" class="headerlink" title="2.3.3 一般兄弟选择器 ~"></a>2.3.3 一般兄弟选择器 ~</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">标签<span class="number">1</span> ~ 标签<span class="number">2</span></div></pre></td></tr></table></figure>
<p>在这里标签2必须跟（不一定要紧跟，只需在标签1的后面即可）在其兄弟标签1后面。</p>
<h4 id="2-3-4-通用选择器"><a href="#2-3-4-通用选择器" class="headerlink" title="2.3.4 通用选择器 *"></a>2.3.4 通用选择器 *</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">*</span></div></pre></td></tr></table></figure>
<p>通用选择器 <code>*</code> 是一个是一个通配符，代表文档流中的任意元素，不过通用选择器 <code>*</code> 通常会搭配一些其他选择器来使用，比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">section</span> &gt; *</div></pre></td></tr></table></figure>
<p>代表 <code>section</code> 的所有子元素，不过一般情况下很少通过通配符来选择某个元素下的所有子元素，因为这涉及到浏览器性能问题，它会影响网页的渲染时间，我们写的时候是从左到右写的，但是浏览器渲染却是从右到左的，就上面这段代码来说，浏览器会先遍历所有的元素，然后在找出哪些元素的父元素是 <code>section</code>，另外举一个例子，有选择器：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-class">.container</span> <span class="selector-id">#main</span> &gt; <span class="selector-class">.article</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>浏览器在渲染时，先把所有类中包含 <code>article</code> 的元素取出来组成一个集合，然后对每一个集合中的元素进行遍历，如果元素的父元素的 <code>id</code>不为 <code>main</code> 则把元素从集合中删去。 再然后从这个元素的父元素开始向上找，没有找到一个标签名为 <code>div</code> 并且类名中有 <code>container</code> 的元素，就把元素从集合中删去，直到匹配所有的条件，所以在能不使用通配符的情况就尽量不要使用它。</p>
<h3 id="2-4-ID-和类选择器"><a href="#2-4-ID-和类选择器" class="headerlink" title="2.4 ID 和类选择器"></a>2.4 ID 和类选择器</h3><p>作者在这一节介绍了 <code>id</code> 和 <code>class</code> 选择器，为我们选择元素提供了另一种手段，利用它们可以不考虑元素在文档流中的层次结构，只要在元素中添加了 <code>id</code> 和 <code>class</code> 属性和值，我们就可以通过它们的值来找到目标元素。</p>
<blockquote>
<p>可以给 <code>id</code> 和 <code>class</code> 属性设定任何值，但不能以数字或者特殊符号开头。</p>
</blockquote>
<h4 id="2-4-3-什么时候用-id，什么时候用-class"><a href="#2-4-3-什么时候用-id，什么时候用-class" class="headerlink" title="2.4.3 什么时候用 id，什么时候用 class"></a>2.4.3 什么时候用 id，什么时候用 class</h4><p><code>id</code> 的用途是在页面中唯一地标识元素，所以每个页面中每一个 <code>id</code> 属性值都是独一无二的。而 <code>class</code> 的目的是为了标识一组具有相同特征的元素，也就是说一个页面中可以出现多个相同的类。</p>
<p>对于什么时候用 <code>id</code> 这个问题作者的观点是：</p>
<blockquote>
<p>每一个顶级区域都应该添加一个 <code>id</code>，从而得到非常明确的上下文关系，以便编写 CSS 时只选择嵌套在相应区域内的标签。</p>
</blockquote>
<p>对于什么时候使用 <code>class</code>，由于 <code>class</code> 的目的是为了标识一组具有相同特征的元素，所以如果当页面中有一组元素具有某种相同的特征，就应该毫不犹豫的时候 <code>class</code> 了。</p>
<p>但是这里也应该注意不要乱用类，避免造成类泛滥，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Alan<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Andrew<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Angela<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"boy"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Angus<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Anne<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"girl"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Annette<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面这个例子就是一个典型的类泛滥。</p>
<h4 id="2-4-4-id-和-class-的小结"><a href="#2-4-4-id-和-class-的小结" class="headerlink" title="2.4.4 id 和 class 的小结"></a>2.4.4 id 和 class 的小结</h4><p>对于什么时候用 id 和什么时候用 class，我想每个人都有不同的看法，这里写说一下笔者的观点，笔者认为能不实用 <code>id</code> 就尽量不使用 <code>id</code>，实际情况是笔者基本不在 CSS 中使用 <code>id</code>，因为在 CSS 的层叠机制中，<code>id</code> 的权重是 <code>class</code> 的10倍，其实很多情况下对某个元素设置某个不一样的样式来覆盖之前的样式并没有效果就是因为之前的样式权重太高，而为了达到效果就要编写权重更高的选择器，所以只有在某个元素需要被 JavaScript 找到的时候才会在某个元素中添加 <code>id</code> ，以便可以通过 <code>document.getElementById()</code> 方法来快速获取需要的元素。</p>
<h3 id="2-5-属性选择器"><a href="#2-5-属性选择器" class="headerlink" title="2.5 属性选择器"></a>2.5 属性选择器</h3><p>属性选择器包括属性名选择器和属性值选择器，它们是通过元素的属性和值来获取元素的：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">标签名[属性名]</div><div class="line">标签名[属性名=<span class="string">"属性值"</span>]</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span><span class="selector-attr">[title]</span> &#123;<span class="attribute">border</span>: <span class="number">2px</span> solid blue;&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[target="_blank"]</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(_blank.png);&#125;</div></pre></td></tr></table></figure>
<p>上面第一段代码意思是，如果某个 <code>img</code> 标签带有 <code>title</code> 这个属性，那么就为它添加一个宽度为 2px 的蓝色实线边框。第二段代码的意思是，如果某个 <code>a</code> 标签带有 <code>target</code> 这个属性，并且这个属性的值为 <code>_blank</code> 那么就为这个元素添加一个背景图。</p>
<p>拓展：</p>
<p>其实除了以上两种属性选择器，还有其他几种属性选择器作者并没有列出来，这里这几种其他的属性选择器作一个简单的介绍：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">标签名[name^=<span class="string">"value"</span>]  让你匹配属性为 `name` 并且属性值以 `value` 开始的标签，如:<span class="literal">a</span>[href^= <span class="string">"http://"</span>]则匹配所有具有 `href` 属性并且属性值以 `http://` 开始的标签。</div><div class="line"></div><div class="line">标签名[name$=<span class="string">"value"</span>]  让你匹配属性为 `name` 并且属性值以 `value` 结束的标签，如:<span class="literal">a</span>[href$=<span class="string">".com"</span>]则匹配所有具有 `href` 属性并且属性值以 `http://` 结束的标签。</div><div class="line"></div><div class="line">标签名[name*=<span class="string">"value"</span>]  让你匹配属性为 `name` 并且属性值包含 `value` 的标签，如:<span class="literal">a</span>[href*= <span class="string">"renren"</span>]则匹配所有具有 `href` 属性并且属性值包含 `http://` 的标签。</div><div class="line"></div><div class="line">标签名[name|=<span class="string">"value"</span>]  让你匹配属性为 `name` 或者以 `name-` 开始的标签，如:p[lang|= <span class="string">"en"</span>]则匹配具有 `lang` 属性的 `p` 标签，不管其属性值是 `en` 还是 `en-us` 。</div><div class="line"></div><div class="line">标签名[name~=<span class="string">"value"</span>]  让你匹配属性为 `name` 并且其属性值是具有多个空格分隔的值，其中一个值为 `value`，如有：</div><div class="line">&lt;<span class="literal">a</span> title=<span class="string">"I'm title for learn more"</span>&gt;Learn More&lt;/<span class="literal">a</span>&gt;</div><div class="line">就可以用 p[title~=<span class="string">"learn"</span>] 来选择这个元素。</div></pre></td></tr></table></figure>
<p>你应该注意到了这些属性选择器与前面两种属性选择器之间的差别了，通过这些属性选择器我们可以很容易的做出许多意想不到的效果，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=".pdf"]</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(pdf.png);&#125;</div></pre></td></tr></table></figure>
<p>比如上面这段代码就为链接是 pdf 文档连接的 <code>a</code> 标签添加一个表示这个链接是 pdf 文档的图片，而其他 <code>href</code> 属性的值不是以 <code>.pdf</code> 结尾的<code>a</code> 标签就不会应用这条样式声明，让用户很清楚的判断这是一个什么类型的链接。</p>
<h3 id="2-6-伪类"><a href="#2-6-伪类" class="headerlink" title="2.6 伪类"></a>2.6 伪类</h3><p>伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上，伪类分为两种：</p>
<ul>
<li>UI（User Interface，用户界面）伪类：会在 HTML 元素处于某个状态时（比如鼠标指针位于连接上），为该元素应用 CSS 样式。</li>
<li>结构化伪类：会在标记中纯在某种结构上的关系时（比如某个元素是一组元素的第一个或者最有一个元素），为相应的元素应用 CSS 样式。</li>
</ul>
<h4 id="2-6-1-UI伪类"><a href="#2-6-1-UI伪类" class="headerlink" title="2.6.1 UI伪类"></a>2.6.1 UI伪类</h4><ol>
<li><p>链接伪类</p>
<ul>
<li>link: 链接就在那儿等着用户点击。</li>
<li>visited:用户此前点击过这个链接。</li>
<li>hover:鼠标指针正悬停在连接上。</li>
<li>active:链接正在i被点击（鼠标在元素上按下，还没有释放）。</li>
</ul>
<p>注意以上几种链接伪类要按一定的顺序才有效果，为了方便记忆作者是这么建议的：”LoVe?HA!”，大写字母就是每个伪类的第一个字母，其实也可以这么记： “LoVe,HAte”，其实都差不多就是了。</p>
<blockquote>
<p>一个冒号（:）表示伪类，两个冒号（::）表示 CSS3 新增的伪元素。</p>
</blockquote>
</li>
<li><p>:focus 伪类</p>
<p>表单中的文本字段在用户单击它时会获得焦点，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> solid blud;&#125;</div></pre></td></tr></table></figure>
<p>这段代码的意思就是当用户单击表单中的文本字段的时候，为该 <code>input</code> 标签添加宽度为 1px 的蓝色实线边框，需要注意的是，伪类的冒号要紧跟着标签名，之间不能有空格，否则该声明无效。</p>
</li>
<li><p>:target 伪类</p>
<p>如果用户点击一个指向页面中其他元素的链接，则哪个元素就是目标（target），可以用 <code>:target</code> 伪类选中它，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#more-info"</span>&gt;</span>More Information<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>位于页面其他地方、<code>id</code> 为 <code>more-info</code> 的那个元素就是目标元素，该元素可能是这样的：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;h2 <span class="built_in">id</span>=<span class="string">"more=info"</span>&gt;This <span class="keyword">is</span> <span class="keyword">the</span> information you are looking <span class="keyword">for</span>.&lt;/h2&gt;</div></pre></td></tr></table></figure>
<p>那么 CSS 规则如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#more-info</span><span class="selector-pseudo">:target</span> &#123;<span class="attribute">background</span>: <span class="number">#eee</span>;&#125;</div></pre></td></tr></table></figure>
<p>此时会在用户点击链接转向 <code>id</code> 为 <code>more-info</code> 的元素时，该目标元素的背景就会变成浅灰色。</p>
</li>
</ol>
<h4 id="2-6-2-结构化伪类"><a href="#2-6-2-结构化伪类" class="headerlink" title="2.6.2 结构化伪类"></a>2.6.2 结构化伪类</h4><ol>
<li><p>first-child 、 last-child 和 nth-child(n)</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">e:<span class="keyword">first</span>-child</div><div class="line">e:<span class="keyword">last</span>-child</div></pre></td></tr></table></figure>
<p><code>first-child</code> 和 <code>last-child</code> 分别代表一组同胞元素中的第一个元素和最后一个元素，而 <code>nth-child(n)</code> 则代表一组同胞元素中的任何一个元素，其中 n 表示一个整数（也可以是 odd-奇数 或 even-偶数）或者也可以是一个算数表达式（2n + 1），例如：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;<span class="built_in">li</span>&gt;My Fast Pony&lt;/<span class="built_in">li</span>&gt;</div><div class="line">    &lt;<span class="built_in">li</span>&gt;Steady Trotter&lt;/<span class="built_in">li</span>&gt;</div><div class="line">    &lt;<span class="built_in">li</span>&gt;Slow Ol' Nag&lt;/<span class="built_in">li</span>&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">ul <span class="built_in">li</span>:<span class="built_in">first</span>-child &#123;<span class="built_in">color</span>: black;&#125;</div><div class="line">ul <span class="built_in">li</span>:nth-child(<span class="number">2</span>) &#123;<span class="built_in">color</span>: red;&#125;</div><div class="line">ul <span class="built_in">li</span>:<span class="built_in">last</span>-child &#123;<span class="built_in">color</span>: blue;&#125;</div></pre></td></tr></table></figure>
<p>上面的 HTML 应用了上面的 CSS 规则后，无序列表的第一个元素字体颜色就会变成黑色，第二个元素变成红色，最后一个元素就变成蓝色。</p>
</li>
</ol>
<h3 id="2-7-伪元素"><a href="#2-7-伪元素" class="headerlink" title="2.7 伪元素"></a>2.7 伪元素</h3><p>顾名思义，伪元素就是文档中若有实无的元素，下面是几个比较常用的伪元素。</p>
<ol>
<li><p>::first-letter 伪元素，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;<span class="attribute">font-size</span>: <span class="number">300%</span>;&#125;</div></pre></td></tr></table></figure>
<p>这样 <code>p</code> 标签的第一个字母大小就会变成原来的 3 倍了，而其他元素则不会。</p>
</li>
<li><p>::first-line 伪元素：可以选中文本段落的第一行。</p>
</li>
<li><p>::before 和 ::after 伪元素</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">e::<span class="keyword">before</span></div><div class="line">e::<span class="keyword">after</span></div></pre></td></tr></table></figure>
<p>可用在特定元素前面或后面添加特殊内容，比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">p</span> class=<span class="string">"age"</span>&gt;<span class="number">25</span>&lt;/p&gt;</div><div class="line"></div><div class="line"><span class="selector-class">.age</span>::before &#123; <span class="attribute">content</span>: <span class="string">"Age: "</span>;&#125;</div><div class="line"><span class="selector-class">.age</span>::after &#123; <span class="attribute">content</span>: <span class="string">" years"</span>;&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意的是，对于 <code>::before</code> 和 <code>::after</code> 伪元素，其 <code>content</code> 属性是必须的，还有就是搜索引擎不会取得伪元素的信息（因为它在文档流中并不存在），因此不要通过伪元素添加一些对搜索引擎来说是重要的内容。</p>
</li>
</ol>
<p>拓展：</p>
<p>其实伪元素前面冒号可以是两个也可以是一个，但是为了区别伪类，笔者建议大家还是使用两个冒号。还有一个要注意的是，比如通过<code>::before</code> 和 <code>::after</code> 伪元素为 <code>class</code> 为 <code>pseudo-element</code> 添加两个伪元素，则生成的两个伪元素分别处于 <code>pseudo-element</code> 元素的内部，也就是说是 <code>pseudo-element</code> 元素的子元素，并且分别位于 <code>pseudo-element</code> 元素的内容的最前面和最后面，代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"pseudo-element"</span>&gt;</div><div class="line">    &lt;p&gt;Pseudo Element&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line"><span class="selector-class">.pseudo-element</span>::after,</div><div class="line"><span class="selector-class">.pseudo-element</span>::before &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/pseudo-element.png" alt="Pseudo Element"></p>
<p>如上图所示，生成的两个伪元素分别处于 <code>pseudo-element</code> 元素的内部，并且分别位于 <code>pseudo-element</code> 元素的内容 <code>p</code> 标签的前面和后面，而不是如下图所示的位于 <code>pseudo-element</code> 元素外部的前面和后面：</p>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/pseudo-element-2.png" alt="Pseudo Element"></p>
<h3 id="2-9-层叠"><a href="#2-9-层叠" class="headerlink" title="2.9 层叠"></a>2.9 层叠</h3><p>层叠就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源确定最终使用哪个值。</p>
<p>层叠是 CSS 的核心机制，理解了它才能以最经济的方式写出最容易改动的 CSS,让文档外观在达到设计要求的同时，也给用户留下一些空间，让他们能根据需要更改文档的显示效果。</p>
<h4 id="2-9-1-样式来源"><a href="#2-9-1-样式来源" class="headerlink" title="2.9.1 样式来源"></a>2.9.1 样式来源</h4><p>作者在这一节中介绍了样式的几种来源：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> 浏览器默认样式表</span></div><div class="line"></div><div class="line">-<span class="ruby"> 用户样式表</span></div><div class="line"></div><div class="line">-<span class="ruby"> 作者链接样式表</span></div><div class="line"></div><div class="line">-<span class="ruby"> 作者嵌入样式</span></div><div class="line"></div><div class="line">-<span class="ruby"> 作者行内样式</span></div></pre></td></tr></table></figure>
<p>作者在书中是这么描述的：</p>
<blockquote>
<p>浏览器会按照上面的顺序依次检查每个来源的样式，并在有定义的情况下，更新对每个标签属性值的设定，整个检查更新过程结束后，再将每个标签以最终设定的样式显示出来。</p>
</blockquote>
<h4 id="2-9-4-计算特指度"><a href="#2-9-4-计算特指度" class="headerlink" title="2.9.4 计算特指度"></a>2.9.4 计算特指度</h4><p>作者在这一节主要介绍了特指度的计算方法，相比作者个计算方式，笔者个人还是比较喜欢自己之前的计算方式，虽然差不多，如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 首先规定四个等级：<span class="literal">A</span> - B - C - D</div><div class="line"><span class="number">1</span>. <span class="literal">A</span> 等级代表内联样式：例如 `style=<span class="string">" "</span>`，权值为：<span class="number">1000</span>；</div><div class="line"><span class="number">2</span>. B 等级代表 ID 选择器：例如 `#main`，权值为：<span class="number">100</span>；</div><div class="line"><span class="number">3</span>. C 等级代表类、伪类和属性选择器： `.class` 和 `[title]`，权值为：<span class="number">10</span>；</div><div class="line"><span class="number">4</span>. D 等级代表元素（标签）名或者伪元素选择器：例如 `p` 和 `::after`，权值为：<span class="number">1</span>。</div><div class="line"></div><div class="line">//计算完每个值后再将每个值加起来，哪个值大哪个值的权重就高。</div></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> <span class="selector-id">#main</span> <span class="selector-class">.class</span> <span class="selector-tag">a</span>[title]::after &#123;&#125;</div></pre></td></tr></table></figure>
<p>我们先分析它由哪些选择器构成，上面这条规则有一个 <code>id</code> 选择器（<code>#main</code>），一个类选择器（<code>.class</code>），一个属性选择器（<code>[title]</code>）、一个伪元素选择器(<code>::after</code>)和两个标签名选择器（<code>body</code> 和 <code>a</code>），所以它的权重就等于：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">100 </span>× <span class="number">1</span> + <span class="number">10</span> × <span class="number">2</span> + <span class="number">1</span> × <span class="number">3</span> = <span class="number">123</span></div></pre></td></tr></table></figure>
<p>还有一点要注意的是，权重值 001(12) 与 0020 相比，任然是 0020 的权重更高，对于权重一样的情况，则后声明的样式更高。</p>
<h3 id="2-10-小结"><a href="#2-10-小结" class="headerlink" title="2.10 小结"></a>2.10 小结</h3><p>作者在本章介绍了 CSS 的一些规则，比如各种选择器的使用，层叠机制，还有权重的计算。</p>
<h2 id="第三章-定位元素"><a href="#第三章-定位元素" class="headerlink" title="第三章 定位元素"></a>第三章 定位元素</h2><h3 id="3-1-理解盒模型"><a href="#3-1-理解盒模型" class="headerlink" title="3.1 理解盒模型"></a>3.1 理解盒模型</h3><p>其实 HTML 页面中每个元素其实都是一个「盒子」，默认情况下这些盒子的边框不可见，背景也是透明的，所以我们不能直接的看到页面中盒子的结构，但是我们可以借助一些 Web Developer 工具条可以方便地显示盒子的边框和背景，让我们能很直观的看到这些盒子的结构。</p>
<p>每个盒子都有三组属性：</p>
<ul>
<li>外边距(margin)： 可以设置盒子与相邻盒子之间的距离。</li>
<li>边框(border)： 可以设置边框的宽度、样式和颜色。</li>
<li>内边距(padding)：可以设置盒子内容区和边框之间的距离。</li>
</ul>
<p>一个盒子有四条边，所以这些属性也各有四个属性，分别是上(top)、右(right)、下(bottom)和左(left)，为了更直观的了解盒模型的结构，这里放上一张盒模型的结构图：</p>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.1.png" alt="盒模型"></p>
<p>尽管这三组属性共有 12 个属性值，但我们也可以对它们进行简写，这里以 <code>margin</code> 为例：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">margin-top</span>:<span class="number">1px</span>;</div><div class="line"><span class="attribute">margin-right</span>:<span class="number">1px</span>;</div><div class="line"><span class="attribute">margin</span>-botton:<span class="number">1px</span>;</div><div class="line"><span class="attribute">margin-left</span>:<span class="number">1px</span>;</div></pre></td></tr></table></figure>
<p>缩写后的代码如下:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span>;</div></pre></td></tr></table></figure>
<p>缩写的顺序是上 -&gt; 右 -&gt; 下 -&gt; 左，顺时针的方向。相对的边的值相同，则可以省掉，代码如下:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span>;<span class="comment">// 四个方向的边距相同，等同于margin:1px 1px 1px 1px;</span></div><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span> <span class="number">2px</span>;<span class="comment">// 上下边距都为1px，左右边距均为2px，等同于margin:1px 2px 1px 2px</span></div><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span> <span class="number">2px</span> <span class="number">3px</span>;<span class="comment">// 右边距和左边距相同，等同于margin:1px 2px 3px 2px;</span></div><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span> <span class="number">2px</span> <span class="number">1px</span> <span class="number">3px</span>;<span class="comment">// 注意，这里虽然上下边距都为1px，但是这里不能缩写。</span></div></pre></td></tr></table></figure>
<h4 id="3-1-1-盒子的边框-border"><a href="#3-1-1-盒子的边框-border" class="headerlink" title="3.1.1 盒子的边框(border)"></a>3.1.1 盒子的边框(border)</h4><p>边框(border)有四个相关属性：</p>
<ul>
<li>宽度(border-width)：可以使用 thin、 medium 和 thick 等文本值，也可以使用<strong>除百分比和负值以外</strong>的任何绝对值。</li>
<li>样式(border-style)：有 none、 hidden、 dotted、 dashed、 solid、 double、 groove、 ridge、 inset 和 outset 等文本值。</li>
<li>颜色(border-color)：可以使用任何颜色值，包括 rgb、 hsl、十六进制颜色值和颜色关键字。</li>
<li>圆角(border-radius)：属于 CSS3 新增属性，可使用百分比、相对值和绝对值。</li>
</ul>
<blockquote>
<p>CSS 推荐标准并没有明确规定 border-width 的几个文本值的确切宽度，所以实际宽度会因浏览器而异。</p>
<p>border-radius 不影响盒子的定位。</p>
</blockquote>
<h4 id="3-1-2-盒子的内边距-padding"><a href="#3-1-2-盒子的内边距-padding" class="headerlink" title="3.1.2 盒子的内边距(padding)"></a>3.1.2 盒子的内边距(padding)</h4><p>内边距是盒子内容区与盒子边框之间的距离。在没有设置内边距的情况下，内容紧挨着边框：</p>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.2.png" alt="内边距"></p>
<p>设置内边距后，内容区与边框有一定的距离(padding 的大小)：</p>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.3.png" alt="内边距"></p>
<h4 id="3-1-3-盒子外边距-margin"><a href="#3-1-3-盒子外边距-margin" class="headerlink" title="3.1.3 盒子外边距(margin)"></a>3.1.3 盒子外边距(margin)</h4><p>与内边距和边框相比，外边距就要显得复杂的多了，首先是外边距叠加，<strong>垂直方向上的外边距会叠加</strong>，例如有三个段落应用了如下规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</div><div class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#000</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</div><div class="line">    <span class="attribute">margin-top</span>: <span class="number">50px</span>;</div><div class="line">    <span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于第一段的下边距与第二段的上边距相邻，你可能会觉得它们两个盒子边框之间的外边距只和是 80px，但实际上是 50px，像这样上下外边距相遇时，它们会相互重叠，直到一个外边距碰到另一个盒子的边框。就上面例子而言，第二段较宽的上外边距会碰到第一段的边框，也就是说较宽的外边距决定两个盒子之间的距离。</p>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.4.png" alt="img"></p>
<h4 id="3-1-5-外边距的单位"><a href="#3-1-5-外边距的单位" class="headerlink" title="3.1.5 外边距的单位"></a>3.1.5 外边距的单位</h4><p>在设置段落文本外边距时应该注意，为了避免因增大字号导致段落间外边距不变引起的整体不协调的问题，在设置段落的上下外边距是应该使用 <code>em</code> 单位，这样当字体大小调整时，段落的上下外边距也会根据字体的大小来调整距离，这样页面的整体布局就会比较协调一致，而左右外边距则可以用 <code>px</code> 绝对单位，确保左右外边距不会因字体大小的调整而发生改变，比如可以这么设置：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span>;</div><div class="line">    <span class="attribute">margin</span>: .<span class="number">75em</span> <span class="number">30px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样段落垂直距离就会始终保持字体高度的四分之三的高度，水平外边距不会因字体的调整而发生改变了。</p>
<h3 id="3-2-盒子有多大"><a href="#3-2-盒子有多大" class="headerlink" title="3.2 盒子有多大"></a>3.2 盒子有多大</h3><p>作者在本章介绍了块级元素和行内元素的不同行为。</p>
<h4 id="3-2-1-没有宽度的盒子"><a href="#3-2-1-没有宽度的盒子" class="headerlink" title="3.2.1 没有宽度的盒子"></a>3.2.1 没有宽度的盒子</h4><p>作者在这一节中专门提到了一个 「没有宽度」的概念：没有显式地设置元素的 <code>width</code> 属性。如果不设置块级元素的 <code>width</code> 属性，那么这个属性的默认值就是 <code>auto</code> ，结果就是会让元素的宽度扩展到与父元素同宽，对于块级元素和行内元素更具体的介绍请看笔者的上一篇文章<a href="http://www.cleardesign.me/stylin-with-css-note-1" target="_blank" rel="external">CSS 设计指南 学习笔记 一</a>。</p>
<p>盒模型结论一：</p>
<blockquote>
<p>没有设置宽度的元素始终会扩展到填满其父元素的宽度为止，添加水平外边距、水平边框和水平内边距都会导致内容宽度的减少，减少量等于水平外边距、水平边框和水平内边距的和。</p>
</blockquote>
<h4 id="3-2-2-有宽度的盒子"><a href="#3-2-2-有宽度的盒子" class="headerlink" title="3.2.2 有宽度的盒子"></a>3.2.2 有宽度的盒子</h4><p>盒模型结论二：</p>
<blockquote>
<p>为设定了宽度的盒子添加外边距、边框和内边距，会导致盒子扩展的更宽，实际上，盒子的 <code>width</code> 属性设定的只是盒子内容区的宽度，而不是盒子要占据的( margin-left + border-left + padding-left + width + padding-right + border-right + margin-right )水平宽度。</p>
</blockquote>
<p>所以一定要记住的是，给设定了 <code>width</code> 的元素添加外边距、边框和内边距所展示的行为与默认的 <code>auto</code> 状态下的行为会有截然不同的表现。</p>
<p>拓展：</p>
<p>但是与布局相关的元素大部分都同时设置了 <code>margin</code>、 <code>border</code>、 <code>padding</code> 和 <code>width</code>，这就导致了在布局时的各种计算保证总宽度( margin-left + border-left + padding-left + width + padding-right + border-right + margin-right )保持不变，这样不仅麻烦，有的时候还比较容易出错，为了解决这一问题， CSS3 新增了一个 <code>box-sizing</code> 属性，通过它可以将设置了 <code>width</code> 的元素也设定成具有默认的 <code>auto</code> 状态下的行为。这样就省去了许多计算 <code>width</code> 的时间，同时也不会出错，而且它的浏览器支持情况也是一片大好（ 除了 IE 6 和 IE 7 不支持，其他个别老版本的浏览器需要添加浏览器私有前缀才支持 ）。</p>
<p>可以这样使用这个属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    <span class="attribute">-webkit-box-sizing</span>: border-box;</div><div class="line">       <span class="attribute">-moz-box-sizing</span>: border-box;</div><div class="line">            <span class="attribute">box-sizing</span>: border-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.5.png" alt="Browser Supported"></p>
<h3 id="3-3-浮动与清除"><a href="#3-3-浮动与清除" class="headerlink" title="3.3 浮动与清除"></a>3.3 浮动与清除</h3><p>浮动和清除是页面布局的一大利剑，分别是 <code>float</code> 和 <code>clear</code>，浮动可以让原来上下堆叠的块级元素变成左右并列，可以实现文字绕图片排列效果。浮动的元素会脱离常规的文档流，原来紧跟其后的元素会在空间允许的情况下向上提升到与浮动元素平起平坐。如果浮动元素后面有两个段落，而你只想让第一段与浮动元素并列（就算旁边还能放下第二段，也不想让它上来），就可以使用 <code>clear</code> 属性清除浮动。</p>
<h4 id="3-3-2-围住浮动元素的三种方法"><a href="#3-3-2-围住浮动元素的三种方法" class="headerlink" title="3.3.2 围住浮动元素的三种方法"></a>3.3.2 围住浮动元素的三种方法</h4><p>浮动元素脱离了文档流，所以我们看不到包含它的父元素了，这种情况有时候并不是我们想要的，所以作者在本章介绍了如何围住浮动元素的三种方法。</p>
<p>方法一：为父元素添加 <code>overflow: hidden;</code> 强制它包围浮动元素。</p>
<p>这种方法在某些情况下也不适用，比如通过浮动设置的水平排列的菜单，对其父元素设置 <code>overflow: hidden;</code> 后，尽管父元素围住了它，但是如果菜单有下拉选项的话，当鼠标移动到上面的时候下拉菜单并不会显示，因为设置了 <code>overflow: hidden;</code>，所以超出父元素范围的内容都被隐藏掉了。</p>
<p>方法二：同时浮动父元素</p>
<p>父元素设置浮动后，不管其子元素是否是浮动，父元素都会紧紧地包围住它的子元素，因此需要用 <code>width: 100%;</code> 再让父元素的宽度与浏览器容器同宽。同样，尽管父元素围住了它，但是这样会导致页面中出现大量的浮动元素，而浮动元素有往往不好控制，并不利于页面的布局。</p>
<p>方法三：添加非浮动的清除元素</p>
<p>第三种强制父元素包含其浮动的子元素的方式就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素，因此父元素一定会包含这个子元素以及前面的浮动元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// HTML</div><div class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>It's fun to float<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line"></div><div class="line">// CSS</div><div class="line">p &#123;</div><div class="line">    float: left;</div><div class="line">&#125;</div><div class="line">.clearfix &#123;</div><div class="line">    clear:both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管这个方法能解决上面提到的两种方法中的问题，但它还不是最好的方法，因为它会在文档中添加无意义的标签，这违反了标签语义化的规则，对搜索引擎并不友好。所以如果你要清楚浮动但既不想浮动父元素又不想对父元素设置 <code>overflow: hidden;</code> 也不想增加无意义的标签的话，可以使用伪元素来清除浮动：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</div><div class="line">    <span class="attribute">display</span>: table;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在父元素中添加 <code>clearfix</code> 类，因为搜索引擎并不会抓取伪元素，所以这种方法并没有增加无意义的标签，这里应该注意的是，CSS3 标准是用两个冒号来区别伪元素和伪类，而 CSS2.1 中不管是伪元素还是伪类都是用单个冒号表示，然而 IE8 并不支持双冒号的伪元素，所以问题就来了，如果你要遵循 CSS3 的标准使用双冒号的话就不兼容 IE8 了，如果使用但冒号的话又不符合 CSS3 标准规范，当然现在大多数还是使用但冒号的，选择哪种还是看个人的选择。</p>
<h3 id="3-4-定位"><a href="#3-4-定位" class="headerlink" title="3.4 定位"></a>3.4 定位</h3><p>CSS 布局的核心是 <code>position</code> 属性，对元素应用这个属性可以相对于它在常规文档流中的位置重新定位，<code>position</code> 属性有 4 个值：<code>static</code>、 <code>relative</code>、 <code>absolute</code> 和 <code>fixed</code>。</p>
<h4 id="3-4-1-静态定位-static"><a href="#3-4-1-静态定位-static" class="headerlink" title="3.4.1 静态定位(static)"></a>3.4.1 静态定位(static)</h4><p>静态定位下的块级元素会在默认文档流中上下堆叠，想要突破 <code>static</code> 定位提供的这种按顺序布局元素的方式，就必须对元素的 <code>position</code> 属性的值改为其他三个值。</p>
<h4 id="3-4-1-相对定位-relative"><a href="#3-4-1-相对定位-relative" class="headerlink" title="3.4.1 相对定位(relative)"></a>3.4.1 相对定位(relative)</h4><p>所谓的相对定位就是相对于元素原来的位置（static 状态下的位置）进行定位，也就是说在不设置 <code>top</code>、 <code>right</code>、 <code>bottom</code> 或 <code>left</code> 的话，和它在默认(static)情况下的表现是相同的，但是如果对它设置了 <code>top</code>、 <code>right</code>、 <code>bottom</code> 或 <code>left</code> 的话，就会相对与它默认的位置进行定位。相对定位的元素可以遮住静态(static)定位的元素。可以给 <code>top</code> 和 <code>left</code> 属性设定负值，把元素向上和向左移动。</p>
<h4 id="3-4-2-绝对定位-absolute"><a href="#3-4-2-绝对定位-absolute" class="headerlink" title="3.4.2 绝对定位(absolute)"></a>3.4.2 绝对定位(absolute)</h4><p>绝对定位跟静态定位和相对定位是绝对不一样的，静态定位和相对定位并不会脱离文档流，会占居原来的位置，而绝对定位会把元素彻底从文档流中拿出来，然后再相对于其他元素（这里的其他元素指的是定位上下文，默认是 <code>body</code> 元素）定位。</p>
<p>绝对定位的一个重要的概念就是<strong>定位上下文</strong>，把元素的 <code>position</code> 属性设定为 <code>relative</code>、 <code>absolute</code> 或 <code>fixed</code> 后，继而可以使用 <code>top</code>、<code>right</code>、 <code>bottom</code> 和 <code>left</code> 属性，相对于「另一个元素」移动该元素的位置。这里的「另一个元素」就是该元素的定位上下文。</p>
<p>绝对定位的默认定位上下文是 <code>body</code>，这是因为 <code>body</code> 是标记中所有元素的唯一的祖先元素，而实际上，绝对定位元素的任何祖先元素都可以成为该绝对定位元素的定位上下文，只要把相应的祖先元素的 <code>position</code> 属性的值设定为 <code>relative</code> 即可。</p>
<h4 id="3-4-3-固定定位"><a href="#3-4-3-固定定位" class="headerlink" title="3.4.3 固定定位"></a>3.4.3 固定定位</h4><p>从完全脱离文档流的角度说，固定定位与绝对定位类似。但不同之处在于，固定定位的定位上下文是视口（浏览器窗口），因此它不会随页面的滚动而移动。最常见的情况是用它来创建不随页面滚动而移动的导航元素。</p>
<h3 id="3-5-显示属性"><a href="#3-5-显示属性" class="headerlink" title="3.5 显示属性"></a>3.5 显示属性</h3><p><code>display</code> 属性的值很多，但常用的除了前面提到的控制块级元素、行内元素和行内块级元素的 <code>block</code>、 <code>inline</code> 和 <code>inline-block</code> 以外，还有一个比较常用的就是 <code>none</code>，把元素的 <code>display</code> 属性的值设定为 <code>none</code> 后，该元素及所包含在其中的元素，都不会在页面中显示。他们原先战局的所有空间都会被「回收」，就好像相关元素根本不存在一样。</p>
<p>与此类似的属性还有 <code>visibility</code>，这个属性常用的两个值是 <code>visible</code>(默认值) 和 <code>hidden</code>，把元素的 <code>visibility</code> 属性的值设定成<code>hidden</code> ，元素会被隐藏，但它还会占据页面中原来的空间位置。</p>
<p>笔者觉得有点类似定位中 <code>absolute</code> 和 <code>relative</code> 的感觉，就是 <code>absolute</code> 定位的元素的原来的位置会被「回收」（脱离文档流），就好像元素根本不存在一样（指的是原来占据的位置不存在一样），<code>relative</code> 定位的元素还会占据页面中原来的空间位置。</p>
<h3 id="3-6-背景"><a href="#3-6-背景" class="headerlink" title="3.6 背景"></a>3.6 背景</h3><p>背景支持为元素添加背景颜色也背景图片。</p>
<h4 id="3-6-1-CSS-背景属性"><a href="#3-6-1-CSS-背景属性" class="headerlink" title="3.6.1 CSS 背景属性"></a>3.6.1 CSS 背景属性</h4><p>CSS 规定以下与背景相关属性：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">background-color</span>: ; <span class="comment">// 背景颜色</span></div><div class="line"><span class="attribute">background-image</span>: url(); <span class="comment">// 背景图片</span></div><div class="line"><span class="attribute">background-repeat</span>: ; <span class="comment">// 背景重复</span></div><div class="line"><span class="attribute">background-position</span>: ; <span class="comment">// 背景位置</span></div><div class="line"><span class="attribute">background-size</span>: ; <span class="comment">// 背景尺寸 CSS3 新增属性</span></div><div class="line"><span class="attribute">background-attachment</span>: ; <span class="comment">// 背景粘附</span></div><div class="line"><span class="attribute">background-clip</span>: ; <span class="comment">// 背景</span></div><div class="line"><span class="attribute">background-origin</span>: ; <span class="comment">// 背景</span></div></pre></td></tr></table></figure>
<h4 id="3-6-5-背景位置"><a href="#3-6-5-背景位置" class="headerlink" title="3.6.5 背景位置"></a>3.6.5 背景位置</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">background</span>-<span class="built_in">position</span>：关键字 px em 百分比；</div></pre></td></tr></table></figure>
<p>用于控制背景位置的 <code>background-position</code> 属性，是所有背景属性中最复杂的。<code>background-position</code> 有 5 个关键字值： <code>top</code>、<code>right</code>、 <code>bottom</code>、 <code>left</code> 或 <code>center</code>，这些关键字值任意两个组合起来都可以作为该属性的值。比如 <code>top</code> <code>right</code> 表示把图片放在元素的右上角位置，<code>center</code> <code>center</code> 表示把图片放在元素的中心位置。除了这些关键字值以外还可以用百分比、<code>px</code> 和 <code>em</code> 等单位。</p>
<p>拓展</p>
<p>要是只设置一个值，则将其用来设定水平位置，而垂直位置会被设为 <code>center</code>。</p>
<p>在使用<strong>关键字</strong>和<strong>百分比</strong>的情况下，情况有点特殊，设定的值会同时应用于元素和图片，也就是说，如果设定了 <code>80%</code> <code>20%</code>，则图片水平 <code>80%</code> 的位置与元素 <code>33%</code> 的位置对齐，垂直方向也一样，如下图：</p>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.6.png" alt="background-position"></p>
<p>其他单位数值就不一样了，如果用像素单位来设定位置：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">background</span>-<span class="built_in">position</span>: <span class="number">80</span>px <span class="number">20</span>px;</div></pre></td></tr></table></figure>
<p>那么图片的左上角会被放在距元素左边 <code>80px</code> 上边 <code>20px</code> 的地方。</p>
<h4 id="3-6-6-背景尺寸"><a href="#3-6-6-背景尺寸" class="headerlink" title="3.6.6 背景尺寸"></a>3.6.6 背景尺寸</h4><p><code>background-size</code> 是 CSS3 新增的属性，但却的到了浏览器很好的支持，这个属性用来控制背景图片的尺寸，可以给它设定的值及含义如下：</p>
<ul>
<li><code>50%</code>：缩放图片，使其填充背景区的一半。</li>
<li><code>100px</code> <code>50px</code>：把图片调整到 <code>100px</code> 宽，<code>50px</code> 高。</li>
<li><code>cover</code>：拉大图片，使其完全填满背景区，并保持宽高比例。</li>
<li><code>contain</code>：缩放图片，使其恰好适应整个背景区域，并保持宽高比例。</li>
</ul>
<h4 id="3-6-7-背景粘附"><a href="#3-6-7-背景粘附" class="headerlink" title="3.6.7 背景粘附"></a>3.6.7 背景粘附</h4><p><code>background-attachment</code> 属性控制滚动元素内的背景图片是否随元素滚动而移动，这个属性默认是 <code>scroll</code>，即背景图片随元素移动，如果把它的值改为 <code>fixed</code>，那么背景图片不会随元素滚动而移动。</p>
<h3 id="3-6-8-简写背景属性"><a href="#3-6-8-简写背景属性" class="headerlink" title="3.6.8 简写背景属性"></a>3.6.8 简写背景属性</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">background</span>:</div><div class="line">    [<span class="built_in">background</span>-<span class="built_in">color</span>]</div><div class="line">    [<span class="built_in">background</span>-<span class="built_in">image</span>]</div><div class="line">    [<span class="built_in">background</span>-repeat]</div><div class="line">    [<span class="built_in">background</span>-attachment]</div><div class="line">    [<span class="built_in">background</span>-<span class="built_in">position</span>] / [ <span class="built_in">background</span>-size]</div><div class="line">    [<span class="built_in">background</span>-<span class="built_in">origin</span>]</div><div class="line">    [<span class="built_in">background</span>-clip];</div></pre></td></tr></table></figure>
<p>声明中少些了哪个属性（比如没写 <code>no-repeat</code>），就会使用相应属性的默认值（<code>repeat</code>）。</p>
<h4 id="3-6-9-其他-CSS3-背景属性"><a href="#3-6-9-其他-CSS3-背景属性" class="headerlink" title="3.6.9 其他 CSS3 背景属性"></a>3.6.9 其他 CSS3 背景属性</h4><p>CSS3 新增的一些背景属性：</p>
<ul>
<li><code>background-clip</code>：控制背景绘制区域的范围，比如可以让背景颜色和背景图片只出现在内容区，而不出现在内边距区域，默认情况下背景绘制区域是扩展到边框外边界的。</li>
<li><code>background-origin</code>：控制背景定位区域的原点，可以设定为元素盒子左上角以外的位置。</li>
<li><code>background-break</code>：控制分离元素（比如跨越多行的行内元素盒子）的显示效果。</li>
</ul>
<p><code>background-size</code>、 <code>background-clip</code> 和 <code>background-origin</code> 的浏览器支持情况还是挺不错的：</p>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.7.png" alt="Browser Supported"></p>
<h4 id="3-6-10-多背景图片"><a href="#3-6-10-多背景图片" class="headerlink" title="3.6.10 多背景图片"></a>3.6.10 多背景图片</h4><p>CSS3 还可以给元素背景条件多个背景图片：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">background-image</span>: 	<span class="built_in">url</span>(img/1.png),</div><div class="line">                        <span class="built_in">url</span>(img/2.png),</div><div class="line">                        <span class="built_in">url</span>(img/3.png);</div><div class="line">    <span class="attribute">background-position</span>:<span class="number">20%</span> <span class="number">20%</span>,</div><div class="line">                        <span class="number">30px</span> <span class="number">50px</span>,</div><div class="line">                        center center;</div><div class="line">    <span class="attribute">background-repeat</span>:	repeat,</div><div class="line">                        no-repeat,</div><div class="line">                        repeat;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 CSS 中，我们把每张图片的声明都单独放在了一行，以逗号分隔，以便看清他们的位置、重复的设定值等等。要注意的是，代码中先列出的图片显示在上方，或者说更接近前景，还有就是对每张背景图设置重复或者位置的时候，也要用逗号一一对应隔开。</p>
<h4 id="3-6-11-背景渐变"><a href="#3-6-11-背景渐变" class="headerlink" title="3.6.11 背景渐变"></a>3.6.11 背景渐变</h4><p>渐变就是在一定长度内两种或多种颜色之间自然过度。渐变分两种，一种是线性渐变，一种是径向渐变。线性渐变是从元素的一端延伸到另一端，径向渐变则是从元素的一点向四周发散，下面来看一个简单的线性渐变例子：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HTML</span></div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-1"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-2"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-3"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line"><span class="comment">// CSS</span></div><div class="line"><span class="selector-class">.gradient</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 默认为从上到下 */</span></div><div class="line"><span class="selector-class">.effect-1</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>: 		linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.effect-2</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(left, <span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-linear-gradient(left, <span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-linear-gradient(left, <span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>: 		linear-gradient(to right, <span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.effect-3</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(<span class="number">45deg</span>, <span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-linear-gradient(<span class="number">45deg</span>, <span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-linear-gradient(<span class="number">45deg</span>, <span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">    <span class="attribute">background</span>: 		linear-gradient(<span class="number">45deg</span>, <span class="number">#45b29a</span>, <span class="number">#fff</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.8.png" alt="Gradient"></p>
<p>上面展示了三种简单的渐变效果，默认情况下渐变方向是从上到下的如图一，例 2 起点关键字 <code>left</code> 意思是渐变方向从左到右，例 3 中的<code>45deg</code> （顺时钟旋转 45 度）相当于把起点从默认的中上设定到了又上。</p>
<h5 id="3-6-11-1-渐变点"><a href="#3-6-11-1-渐变点" class="headerlink" title="3.6.11.1 渐变点"></a>3.6.11.1 渐变点</h5><p>渐变点就是渐变方向上的点，可以在这些点上设定颜色和不透明度。可以添加任意多个渐变点：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HTML</span></div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-1"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-2"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-3"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-4"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line"><span class="comment">// CSS</span></div><div class="line"><span class="selector-class">.gradient</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 50% 处有一个渐变点 */</span></div><div class="line"><span class="selector-class">.effect-1</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">50%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">50%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">50%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 		linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">50%</span>, <span class="number">#45b29a</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 20% 和 80%处有一个渐变点 */</span></div><div class="line"><span class="selector-class">.effect-2</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(<span class="number">#45b29a</span> <span class="number">20%</span>, <span class="number">#fff</span> <span class="number">50%</span>, <span class="number">#45b29a</span> <span class="number">80%</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-linear-gradient(<span class="number">#45b29a</span> <span class="number">20%</span>, <span class="number">#fff</span> <span class="number">50%</span>, <span class="number">#45b29a</span> <span class="number">80%</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-linear-gradient(<span class="number">#45b29a</span> <span class="number">20%</span>, <span class="number">#fff</span> <span class="number">50%</span>, <span class="number">#45b29a</span> <span class="number">80%</span>);</div><div class="line">    <span class="attribute">background</span>: 		linear-gradient(<span class="number">#45b29a</span> <span class="number">20%</span>, <span class="number">#fff</span> <span class="number">50%</span>, <span class="number">#45b29a</span> <span class="number">80%</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 25%、50% 和 75% 处有一个渐变点 */</span></div><div class="line"><span class="selector-class">.effect-3</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">25%</span>, <span class="number">#45b29a</span> <span class="number">50%</span>, <span class="number">#fff</span> <span class="number">75%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">25%</span>, <span class="number">#45b29a</span> <span class="number">50%</span>, <span class="number">#fff</span> <span class="number">75%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">25%</span>, <span class="number">#45b29a</span> <span class="number">50%</span>, <span class="number">#fff</span> <span class="number">75%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 		linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">25%</span>, <span class="number">#45b29a</span> <span class="number">50%</span>, <span class="number">#fff</span> <span class="number">75%</span>, <span class="number">#45b29a</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 为同一个渐变点设定两种颜色可以的到突变的效果 */</span></div><div class="line"><span class="selector-class">.effect-4</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">25%</span>, <span class="number">#45b29a</span> <span class="number">25%</span>%, <span class="number">#45b29a</span> <span class="number">75%</span>, <span class="number">#fff</span> <span class="number">75%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">25%</span>, <span class="number">#45b29a</span> <span class="number">25%</span>%, <span class="number">#45b29a</span> <span class="number">75%</span>, <span class="number">#fff</span> <span class="number">75%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">25%</span>, <span class="number">#45b29a</span> <span class="number">25%</span>%, <span class="number">#45b29a</span> <span class="number">75%</span>, <span class="number">#fff</span> <span class="number">75%</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 		linear-gradient(<span class="number">#45b29a</span>, <span class="number">#fff</span> <span class="number">25%</span>, <span class="number">#45b29a</span> <span class="number">25%</span>%, <span class="number">#45b29a</span> <span class="number">75%</span>, <span class="number">#fff</span> <span class="number">75%</span>, <span class="number">#45b29a</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.9.png" alt="Gradient"></p>
<p>例 1，如果不是使用百分比或其他值声明渐变点的位置，三种颜色会均匀分布于整个渐变。</p>
<p>例 2，演示了起点和终点不是 0% 和 100% 时的情形。此时，在第一个渐变点(20%)之前，是第一个渐变点声明的实色，而在该点之后，则是从该颜色到下一个渐变点颜色的过度。同样，在最后一个渐变点(80%)之后，该渐变点的颜色会以实色扩展到元素结束。</p>
<p>例 3，简单展示了相同颜色在几个渐变点之间变来变去的效果。</p>
<p>例 4，展示了在同一个渐变点声明两种不同颜色，能实现一种突变的效果。</p>
<h5 id="3-6-11-2-径向渐变"><a href="#3-6-11-2-径向渐变" class="headerlink" title="3.6.11.2 径向渐变"></a>3.6.11.2 径向渐变</h5><p>在创建径向渐变的时候，可以使用参数指定形状、位置、尺寸、颜色和不透明度：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// HTML</span></div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-1"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-2"</span>&gt;&lt;/div&gt;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"gradient effect-3"</span>&gt;&lt;/div&gt;</div><div class="line"></div><div class="line"><span class="comment">// CSS</span></div><div class="line"><span class="selector-class">.gradient</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.effect-1</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-radial-gradient(<span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-radial-gradient(<span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-radial-gradient(<span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 		radial-gradient(<span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.effect-2</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-radial-gradient(circle, <span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-radial-gradient(circle, <span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-radial-gradient(circle, <span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 		radial-gradient(circle, <span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.effect-3</span> &#123;</div><div class="line">    <span class="attribute">background</span>: -webkit-radial-gradient(<span class="number">50px</span> <span class="number">30px</span>, circle, <span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>:    -moz-radial-gradient(<span class="number">50px</span> <span class="number">30px</span>, circle, <span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 	 -o-radial-gradient(<span class="number">50px</span> <span class="number">30px</span>, circle, <span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">    <span class="attribute">background</span>: 		radial-gradient(<span class="number">50px</span> <span class="number">30px</span>, circle, <span class="number">#fff</span>, <span class="number">#45b29a</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.10.png" alt="Gradient"></p>
<p>例 1，展示了默认的渐变形状，即渐变效果会填充元素，这里是矩形，如果元素是正方形，那渐变就是圆形：</p>
<p><img src="http://justclear.github.io/images/posts/stylin-with-css-note/2.11.png" alt="Gradient"></p>
<p>例 2，设定了关键字 <code>circle</code>，于是渐变形状变得均匀，并在元素最近的边达到终点，形成了圆形渐变。而长边剩下的区域则填充了终点的颜色。</p>
<p>例 3，位置参数 <code>50px 30px</code> 把渐变的圆心放到了靠近左上角的位置。</p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>网页中字体的三个来源</p>
<ul>
<li>用户机器安装的字体</li>
<li>第三方网站上的字体</li>
<li>储存在 web 服务器上字体</li>
</ul>
<p>CSS 中有6个与字体有关的属性：font-family、font-size、font-style、font-weight、font-variant、font</p>
<h3 id="字体族"><a href="#字体族" class="headerlink" title="字体族"></a>字体族</h3><p>font-family 可以设置 字体族，也就是指定文本用什么字体，可以设置多个，排列在前面的优先级高</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>:<span class="string">"trebuchet ms"</span>, tahoma, sans-serif;&#125;</div></pre></td></tr></table></figure>
<p>带有空格的字体需要加上引号，前面的字体优先选择，如果找不到，选择下一个，一般最后一个是要设置一个通用字体。</p>
<ul>
<li>serif ，也就是衬线字体，在每个字符笔画的末端会有一些装饰线；</li>
<li>sans-serif ，也就是无衬线字体，字符笔画的末端没有装饰线；</li>
<li>monospace ，也就是等宽字体，顾名思义，就是每个字符的宽度相等（也称代码体）；</li>
<li>cursive ，也就是草书体或手写体</li>
<li>fantasy ，不能归入其他类别的字体（一般都是奇形怪状的字体）</li>
</ul>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p>每个 HTML 元素都设置默认字体大小，当在修改字体大小时候都是修改了默认值，同时也是可以继承的</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">font-size</span>:<span class="number">18px</span>;&#125;</div></pre></td></tr></table></figure>
<p>设置字体大小可以有绝对字体大小和相对字体大小</p>
<p>绝对字体大小不会随页面缩放不会继承父元素属性，一般使用 px 单位，也可以使用关键字 x-small 、medium 、x-large</p>
<p>相对字体大小会随着页面缩放会继续父元素的字体大小，再其基础上缩放。使用百分比、em、rem 作为单位。</p>
<p>rem 是相对根元素的的大小</p>
<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">font-style</span>:italic;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>normal 正常</li>
<li>italic 斜体</li>
</ul>
<h3 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h3><p>font-weight 属性的两个值： bold 和 normal</p>
<h3 id="字体变化"><a href="#字体变化" class="headerlink" title="字体变化"></a>字体变化</h3><p>font-variant 属性除了 normal ，就只有一个值，即 small-caps 。这个值会导致所有 小写英文字母变成小型大写字母：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h3</span> &#123;<span class="attribute">font-variant</span>:small-caps;&#125;</div></pre></td></tr></table></figure>
<h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><p>以下是几个最有用的 CSS文本属性：</p>
<ul>
<li>text-indent</li>
<li>letter-spacing</li>
<li>word-spacing</li>
<li>text-decoration</li>
<li>text-align</li>
<li>line-height</li>
<li>text-transform</li>
<li>vertical-align</li>
</ul>
<h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-indent</span>:<span class="number">3em</span>;&#125;</div></pre></td></tr></table></figure>
<p>text-indent 属性设定行内盒子相对于包含元素的起点。默认情况下，这个起点就是包含元素的左上角。</p>
<p>正值向右，负值向左</p>
<p>text-indent 是可以被子元素继承的。但是继承的是最终的值。</p>
<p>假设有一个 400 像素宽的 div，包含的文本缩进 5%，则缩进的距离是 20 像素（400 的 5%）。 在这个 div 中有一个 200 像素宽的段落。作为子元素，它继承父元素的 text-indent 值，所以 它包含的文本也缩进。但继承的缩进值是多少呢？不是 5%，而是 20 像素</p>
<h3 id="字符间距"><a href="#字符间距" class="headerlink" title="字符间距"></a>字符间距</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">letter-spacing</span>:.<span class="number">2em</span>;&#125;</div></pre></td></tr></table></figure>
<p>letter-spacing 为正值时增大字符间距，为负值时缩小间距。无论设定字体大小时使用的是什么单位，设定字符间距一定要用相对单位，以便字间距能随字体大小同比例变化。</p>
<h3 id="单词间距"><a href="#单词间距" class="headerlink" title="单词间距"></a>单词间距</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">word-spacing</span>:.<span class="number">2em</span>;&#125;</div></pre></td></tr></table></figure>
<h3 id="文本装饰"><a href="#文本装饰" class="headerlink" title="文本装饰"></a>文本装饰</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.retailprice</span> &#123;<span class="attribute">text-decoration</span>:line-through;&#125;</div></pre></td></tr></table></figure>
<p>值有：underline 、 overline 、 line-through 、 blink 、 none，其中 blink 不使用</p>
<h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-align</span>:right;&#125;</div></pre></td></tr></table></figure>
<p>text-align 属性只有 4 个值， left 、 right 、 center 和 justify ，控制着文本在水平方向对齐的方式。其中， center 值也可以用来在较大的元素中居中较小的固定宽度的元素或图片。</p>
<h3 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">line-height</span>:<span class="number">1.5</span>;&#125;</div></pre></td></tr></table></figure>
<p>值：任何数字值（不用指定单位）</p>
<h3 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a>文本转换</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-transform</span>:capitalize;&#125;</div></pre></td></tr></table></figure>
<p>值： none 、 uppercase 、 lowercase 、 capitalize 。</p>
<h3 id="垂直对齐"><a href="#垂直对齐" class="headerlink" title="垂直对齐"></a>垂直对齐</h3><p>值：任意长度值以及 sub 、 super 、 top 、 middle 、 bottom 等。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">vertical-align</span>:<span class="number">60%</span>;&#125; 。</div></pre></td></tr></table></figure>
<p>vertical-align 以基线为参照上下移动文本，但这个属性只影响行内元素。如果你想在垂直方向上对齐块级元素，必须把其 display 属性设定为 inline 。</p>
<p>HTML 标签 sup 和 sub 有默认的上标和下标样式，但重新设定一下vertical-align 和 font-size 属性能得到更美观的效果。</p>
<h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@font-face &#123;</div><div class="line">/*这就是将来在字体栈中引用的字体族的名字*/</div><div class="line">font-family:"UbuntuTitlingBold";</div><div class="line">src: url("UbuntuTitling-Bold-webfont.eot");</div><div class="line">    src: url("UbuntuTitling-Bold-webfont.eot?#iefix")</div><div class="line">        format("embedded-opentype"),</div><div class="line">        url("UbuntuTitling-Bold-webfont.woff")</div><div class="line">        format("woff"),</div><div class="line">        url("UbuntuTitling-Bold-webfont.ttf")</div><div class="line">        format("truetype"),</div><div class="line">        url("UbuntuTitling-Bold-webfont.</div><div class="line">        svg#UbuntuTitlingBold") format("svg");</div><div class="line">font-weight: normal;</div><div class="line">font-style: normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把以上代码添加到网页中之后，就可以使用 font-family 以常规方式引用该字体了。引用字体时要使用 @font-face 规则中 font-family 属性的值作为字体族的名字。</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>多栏布局的三种基本实现方案：固定宽度、流动、弹性。</p>
<ul>
<li>固定宽度不会随着页面的缩放而变化，一般选择固定宽度为 960 px，能被多种整数整除，实现多栏布局。</li>
<li>流动布局会随着浏览器的窗口大小变化而变化，这种布局能更好的适应大屏幕，但是文明本行的长度和页面的元素之间的位置关系可能会发生变化。</li>
<li>响应式设计利用媒体查询，为提供不同的 CSS 成为可能，使得不同的屏幕可以使用固定布局，正在替代流动布局。</li>
<li>弹性布局在浏览器大小发生变化时候，所有的元素和布局都会缩放，这种技术实现难度大。</li>
</ul>
<p>布局高度一般要保持 auto ，这样在垂直方向上添加元素时候会自动向下拓展，如果设置的高度，那么元素可能会被剪掉，或者跑出元素外面去。</p>
<p>布局宽度需要精确的控制，在浏览器宽度合理变化时候提供合理的调整。必须要给定栏宽，其中的元素不需要给定宽度，使用默认行为填充满整个父元素的宽度。</p>
<h3 id="三栏-固定布局"><a href="#三栏-固定布局" class="headerlink" title="三栏-固定布局"></a>三栏-固定布局</h3><p>三栏布局中，需要计算出三栏的宽度等于父元素的宽度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 无序列表 --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 这里是一些文本元素 --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 文本 --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>三栏的元素分别是 nav、article、aside，假设 #wrapper 的宽度是 960px，那么这三个元素的宽度也要是 960px。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#wrapper</span> &#123;<span class="attribute">width</span>:<span class="number">960px</span>; <span class="attribute">margin</span>:<span class="number">0</span> auto; <span class="attribute">border</span>:<span class="number">1px</span> solid;&#125;</div><div class="line"><span class="selector-tag">nav</span> &#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">150px</span>;</div><div class="line">    <span class="attribute">float</span>:left;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#dcd9c0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">nav</span> <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">list-style-type</span>:none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">article</span> &#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">600px</span>;</div><div class="line">    <span class="attribute">float</span>:left;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#ffed53</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">aside</span> &#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">210px</span>;</div><div class="line">    <span class="attribute">float</span>:left;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#3f7ccf</span>;</div><div class="line">    <span class="attribute">width</span>:<span class="number">210px</span>;</div><div class="line">    <span class="attribute">float</span>:left;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#3f7ccf</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给这三个固定宽度元素添加内外边距时，由于被指定宽度的元素再添加内外边距时候元素会被扩大，会出现元素错位的情况，有三种方式可以解决。</p>
<ul>
<li>计算元素宽度时候就把内外边距也考虑上，这样太麻烦，不推荐。</li>
<li>把这三个元素用 div 包起来，由于这个 div 是没有被设置宽度的，所以添加内外边距时大小不变</li>
<li>给三个元素使用 box-sizing:border-box 的属性，就不会导致给设定宽度的元素添加内外边距时，导致元素扩大，这个方法好。</li>
</ul>
<h3 id="三栏-中栏流动布局"><a href="#三栏-中栏流动布局" class="headerlink" title="三栏-中栏流动布局"></a>三栏-中栏流动布局</h3><p>目前而言 CSS 中的 table 属性是最简单、最容易实现的，但是在低于 IE7 的浏览器不被支持，也没有任何的替代方法。</p>
<p>CSS可以把一个 HTML元素的 display 属性设定为 table 、 table-row 和 table-cell 。</p>
<p>而通过 CSS把布局中的栏设定为 table-cell 有三个好处。</p>
<ul>
<li>单元格（table-cell）不需要浮动就可以并排显示，而且直接为它们应用内边距也不会破坏布局。</li>
</ul>
<ul>
<li>默认情况下，一行中的所有单元格高度相同，因而也不需要人造的等高栏效果了。</li>
</ul>
<ul>
<li>任何没有明确设定宽度的栏都是流动的。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line">        <span class="selector-id">#main</span>&#123;</div><div class="line">            <span class="attribute">width</span>: <span class="number">960px</span>;</div><div class="line">            <span class="attribute">margin</span>: auto auto;</div><div class="line">        &#125;</div><div class="line">      <span class="selector-tag">nav</span> &#123;</div><div class="line">        <span class="attribute">display</span>: table-cell;</div><div class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">        <span class="attribute">background-color</span>: red;</div><div class="line">        <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">20px</span>;</div><div class="line">      &#125; </div><div class="line">      <span class="selector-tag">article</span> &#123;</div><div class="line">        <span class="attribute">display</span>: table-cell;</div><div class="line">        <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">        <span class="attribute">background-color</span>: blue;</div><div class="line">        <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">20px</span>;</div><div class="line">      &#125; </div><div class="line">      <span class="selector-tag">aside</span> &#123;</div><div class="line">        <span class="attribute">display</span>: table-cell;</div><div class="line">        <span class="attribute">width</span>: <span class="number">260px</span>;</div><div class="line">        <span class="attribute">background-color</span>: yellow;</div><div class="line">        <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">20px</span>;</div><div class="line">      &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">nav</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- 一些东西 --&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">article</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- 一些东西 --&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">article</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aside</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- 一些东西 --&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>余下的其他章节注重实践，使用前面的基本知识，实现了一个综合的项目</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS实现对象的深度克隆]]></title>
      <url>http://hangweiping.github.io/2016/07/02/JS%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>要弄明白对象的克隆，首先要明白js中对象的组成。<strong>对象即是属性的集合</strong>，在js中一切实例皆是对象，具体分为<a href="http://javascript.ruanyifeng.com/grammar/basic.html#toc9" target="_blank" rel="external">原始类型和合成类型</a>。原始类型对象指的基本类型（包括undefined,Null,boolean,String,Number），按值传递；合成类型对象(array、object以及function)指的是引用类型（包括数组，对象），按址传递，引用类型在值传递的时候是内存中的地址。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>浅度克隆：原始类型为值传递，对象类型仍为引用传递。</li>
</ul>
<ul>
<li>深度克隆：所有元素或属性均完全复制，与原对象完全脱离，也就是说所有对于新对象的修改都不会反映到原对象中。</li>
</ul>
<p>又或许你刚听说“深度克隆”这个词，简单来说，就是说有个变量a，a的值是个对象（包括基本数据类型），现在你要创建一个变量b，使得它拥有跟a一样的方法和属性等等。<strong>但是a和b之间不能相互影响，即a的值的改变不影响b值的变化。</strong></p>
<p>实践证明某些JavaScript的原始数据类型，如果要克隆直接赋值即可。</p>
<p><strong><em>但是对象呢？</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a;a.push(<span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [0, 1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
<p>显然与预期不符，为什么会这样？因为原始数据类型储存的是对象的实际数据，而对象类型存储的是对象的引用地址。上面的例子呢也就是说a和b对象引用了同一个地址，无论改变a还是改变b，其实根本操作是一样的，都是对那块空间地址中的值的改变。</p>
<p>于是我们知道了，对于基本的对象来说，不能只能用=赋值，思索后写下如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj) </div><div class="line">    o[k] = <span class="keyword">typeof</span> obj[k] === <span class="built_in">Object</span> ? deepClone(obj[k]) : obj[k];</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]];</div><div class="line"><span class="keyword">var</span> b = deepClone(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div></pre></td></tr></table></figure>
<p>似乎可以解决一般的对象（包括Array）的深度克隆了，或许这儿会有疑问，new String(..)这类的也是对象啊，可是这样写你克隆不了啊…但是楼主觉得深度克隆的考点不在这里，可能在于：</p>
<ol>
<li>原始数据类型的直接赋值</li>
<li>function的exception</li>
<li>对象的深度克隆中Array类型的判断</li>
<li>克隆函数的递归调用</li>
</ol>
<p><strong>另外一种深度克隆代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!o || <span class="string">'object'</span> !== <span class="keyword">typeof</span> o) &#123;</div><div class="line">            <span class="keyword">return</span> o;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> temp;</div><div class="line">        <span class="keyword">if</span>(o.constructor === <span class="built_in">Array</span>)&#123;</div><div class="line">            <span class="comment">//temp=o.concat();</span></div><div class="line">            temp = [];</div><div class="line">            <span class="keyword">var</span> i = o.length;</div><div class="line">            <span class="keyword">while</span> (i--) &#123;</div><div class="line">                temp[i] = cloneObject(o[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o.constructor === <span class="built_in">Object</span>)&#123;</div><div class="line">            temp = &#123;&#125;;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o) &#123;</div><div class="line">                <span class="keyword">if</span>(o.hasOwnProperty(k))&#123;</div><div class="line">                    temp[k] = cloneObject(o[k]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> temp;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>主要使用了递归。<br>不过代码看上去挺变扭的，数组本来就是对象，可以精简代码。优化了一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> o = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</div><div class="line">            <span class="keyword">if</span>(obj.hasOwnProperty(i))&#123;</div><div class="line">                o[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">"object"</span> ? cloneObject(obj[i]) : obj[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最简单的深度克隆，很简单，很实用： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify( obj ); </div><div class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse( s );</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gulp指南]]></title>
      <url>http://hangweiping.github.io/2016/06/01/gulp%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>gulp 是基于 node 实现 Web 前端自动化开发的工具，利用它能够极大的提高开发效率。</p>
<p>在 Web 前端开发工作中有很多“重复工作”，比如压缩CSS/JS文件。而这些工作都是有规律的。找到这些规律，并编写 gulp 配置代码,让 gulp 自动执行这些“重复工作”。</p>
<a id="more"></a>
<h2 id="将规律转换为-gulp-代码"><a href="#将规律转换为-gulp-代码" class="headerlink" title="将规律转换为 gulp 代码"></a>将规律转换为 gulp 代码</h2><p>现有目录结构如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">└── js/</div><div class="line">    └── <span class="selector-tag">a</span>.js</div></pre></td></tr></table></figure>
<h3 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h3><ol>
<li>找到 js/目录下的所有 .js 文件</li>
<li>压缩这些 js 文件</li>
<li>将压缩后的代码另存在 dist/js/ 目录下</li>
</ol>
<h3 id="编写-gulp-代码"><a href="#编写-gulp-代码" class="headerlink" title="编写 gulp 代码"></a>编写 gulp 代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 压缩 JavaScript 文件</span></div><div class="line">gulp.task(<span class="string">'script'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 1. 找到</span></div><div class="line">    gulp.src(<span class="string">'js/*.js'</span>)</div><div class="line">    <span class="comment">// 2. 压缩</span></div><div class="line">        .pipe(uglify())</div><div class="line">    <span class="comment">// 3. 另存</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/js'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="代码执行结果"><a href="#代码执行结果" class="headerlink" title="代码执行结果"></a>代码执行结果</h3><p>代码执行后文件结构</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">└── js/</div><div class="line">│   └── <span class="selector-tag">a</span><span class="selector-class">.js</span></div><div class="line">└── dist/</div><div class="line">    └── js/</div><div class="line">        └── <span class="selector-tag">a</span>.js</div></pre></td></tr></table></figure>
<p>a.js 压缩前<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    alert(<span class="string">'--------\r\n'</span> + msg + <span class="string">'\r\n--------'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">demo(<span class="string">'Hi'</span>)</div></pre></td></tr></table></figure></p>
<p>a.js 压缩后<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">n</span>)</span>&#123;alert(<span class="string">"--------\r\n"</span>+n+<span class="string">"\r\n--------"</span>)&#125;demo(<span class="string">"Hi"</span>);</div></pre></td></tr></table></figure></p>
<p>此时 <code>dist/js</code> 目录下的 <code>.js</code> 文件都是压缩后的版本。</p>
<p>你还可以监控 <code>js/</code> 目录下的 js 文件，当某个文件被修改时，自动压缩修改文件。启动 gulp 后就可以让它帮助你自动构建 Web 项目。</p>
<hr>
<p>gulp 还可以做很多事，例如：</p>
<ol>
<li>压缩CSS</li>
<li>压缩图片</li>
<li>编译Sass/LESS</li>
<li>编译CoffeeScript</li>
<li>markdown 转换为 html</li>
</ol>
<h1 id="安装-Node-和-gulp"><a href="#安装-Node-和-gulp" class="headerlink" title="安装 Node 和 gulp"></a>安装 Node 和 gulp</h1><p>gulp 是基于 node 实现的，那么我们就需要先安装 node。</p>
<blockquote>
<p>Node 是一个基于Chrome JavaScript V8引擎建立的一个平台，可以利用它实现 Web服务，做类似PHP的事。</p>
</blockquote>
<p>打开 <a href="https://nodejs.org/" target="_blank" rel="external">https://nodejs.org/</a> 点击绿色的 <strong>INSTALL</strong> 按钮下载安装 node。</p>
<p><a href="#hash_cli" name="hash_cli"></a></p>
<h2 id="使用终端-命令行"><a href="#使用终端-命令行" class="headerlink" title="使用终端/命令行"></a>使用终端/命令行</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>在 Windows 中可按 <kbd>徽标键</kbd>（alt键左边）+ <kbd>R</kbd> 打开输入 <code>cmd</code> + <kbd>Enter</kbd> 打开命令行。</p>
<h3 id="终端-Mac"><a href="#终端-Mac" class="headerlink" title="终端(Mac)"></a>终端(Mac)</h3><p>打开 Launchpad（像火箭一样的图标），在屏幕上方搜索框中输入 <code>终端</code> + <kbd>Enter</kbd> 打开终端。</p>
<h3 id="查看-node-版本号"><a href="#查看-node-版本号" class="headerlink" title="查看 node 版本号"></a>查看 node 版本号</h3><p>在终端/命令行中输入 <code>node -v</code> 检测node是否安装成功，安装成功会显示出 node 的版本号。</p>
<h3 id="跳转目录"><a href="#跳转目录" class="headerlink" title="跳转目录"></a>跳转目录</h3><p>终端/命令行 中可使用 <code>cd 目录名</code> 跳转至指定目录，Mac 中还可以使用 <code>ls</code> 查看当前目录下的文件列表。</p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>Windows 下可使用如下命令跳转至指定目录：</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳转至 C 盘根目录</span></div><div class="line"><span class="built_in">cd</span> c:\</div><div class="line"><span class="comment">// 跳转至当前目录的 demo 文件夹</span></div><div class="line"><span class="built_in">cd</span> demo</div><div class="line"><span class="comment">// 跳转至上一级</span></div><div class="line"><span class="built_in">cd</span> ..</div></pre></td></tr></table></figure>
<h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p>Mac 中建议只在 Documents 目录下进行文件操作。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳转至文档目录</span></div><div class="line"><span class="keyword">cd</span> /Users/你的用户名/Documents/</div><div class="line"><span class="comment">// 或第一次打开终端时直接输入</span></div><div class="line"><span class="keyword">cd</span> Documents</div><div class="line"><span class="comment">// 查看目录下文件列表</span></div><div class="line"><span class="keyword">ls</span></div><div class="line"><span class="comment">// 创建文件夹</span></div><div class="line"><span class="keyword">mkdir</span> demo</div><div class="line"><span class="comment">// 跳转至当前目录下的 demo 文件夹</span></div><div class="line"><span class="keyword">cd</span> demo</div><div class="line"><span class="comment">// 跳转至上级目录</span></div><div class="line"><span class="keyword">cd</span> ..</div></pre></td></tr></table></figure>
<h3 id="退出运行状态"><a href="#退出运行状态" class="headerlink" title="退出运行状态"></a>退出运行状态</h3><p>如果你在命令行中启动了一些一直运行的命令，你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 <code>Ctrl + C</code> 停止 gulp。（Mac 中使用 <code>control + C</code>）</p>
<p>后面的章节中如果代码中存在 <code>gulp.watch</code> 并在命令行运行了 <code>gulp</code> 则需要使用 <code>Ctrl + C</code> 退出任务。</p>
<h2 id="npm-模块管理器"><a href="#npm-模块管理器" class="headerlink" title="npm 模块管理器"></a>npm 模块管理器</h2><p>如果你了解 npm 则跳过此章节</p>
<p>若你不了解npm 请阅读 <a href="http://javascript.ruanyifeng.com/nodejs/npm.html" target="_blank" rel="external">npm模块管理器</a></p>
<h2 id="安装-gulp"><a href="#安装-gulp" class="headerlink" title="安装 gulp"></a>安装 gulp</h2><p>npm 是 node 的包管理工具，可以利用它安装 gulp 所需的包。（在安装 node 时已经自动安装了 npm）</p>
<p>在命令行输入</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> -g gulp</div></pre></td></tr></table></figure>
<p>若一直没安装成功，请<a href="https://github.com/nimojs/blog/issues/20" target="_blank" rel="external">使用 cnpm 安装</a>(npm的国内加速镜像)</p>
<p>意思是：使用 npm 安装全局性的(<code>-g</code>) gulp 包。</p>
<blockquote>
<p>如果你安装失败，请输入<code>sudo npm install -g gulp</code>使用管理员权限安装。（可能会要求输入密码）</p>
</blockquote>
<p>安装时请注意命令行的提示信息，安装完成后可在命令行输入 <code>gulp -v</code> 以确认安装成功。</p>
<p>至此，我们完成了准备工作。接着让 gulp 开始帮我们干活吧！</p>
<h1 id="使用-gulp-压缩-JS"><a href="#使用-gulp-压缩-JS" class="headerlink" title="使用 gulp 压缩 JS"></a>使用 gulp 压缩 JS</h1><p>压缩 js 代码可降低 js 文件大小，提高页面打开速度。在不利用 gulp 时我们需要通过各种工具手动完成压缩工作。</p>
<p>所有的 gulp 代码编写都可以看做是将规律转化为代码的过程。</p>
<h2 id="规律-1"><a href="#规律-1" class="headerlink" title="规律"></a>规律</h2><p>找到 <code>js/</code> 目录下的所有 js 文件，压缩它们，将压缩后的文件存放在 <code>dist/js/</code> 目录下。</p>
<h2 id="gulp-代码"><a href="#gulp-代码" class="headerlink" title="gulp 代码"></a>gulp 代码</h2><p>你可以 <a href="https://github.com/nimojs/gulp-book/archive/master.zip" target="_blank" rel="external">下载所有示例代码</a> 或 <a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter2" target="_blank" rel="external">在线查看代码</a></p>
<p><strong>建议</strong>：你可以只阅读下面的代码与注释或同时阅读代码解释</p>
<p>gulp 的所有配置代码都写在 <code>gulpfile.js</code> 文件。</p>
<p><strong>一、新建一个 <code>gulpfile.js</code> 文件</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">chapter2</span></div><div class="line">└── <span class="selector-tag">gulpfile</span><span class="selector-class">.js</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>二、在 <code>gulpfile.js</code> 中编写代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 gulp</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p><code>require()</code> 是 node （CommonJS）中获取模块的语法。</p>
<p>在 gulp 中你只需要理解 <code>require()</code> 可以获取模块。</p>
</blockquote>
<hr>
<p><strong>三、获取 <code>gulp-uglify</code> 组件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 uglify 模块（用于压缩 JS）</span></div><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>)</div></pre></td></tr></table></figure>
<hr>
<p><strong>四、创建压缩任务</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 压缩 js 文件</span></div><div class="line"><span class="comment">// 在命令行使用 gulp script 启动此任务</span></div><div class="line">gulp.task(<span class="string">'script'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 1. 找到文件</span></div><div class="line">    gulp.src(<span class="string">'js/*.js'</span>)</div><div class="line">    <span class="comment">// 2. 压缩文件</span></div><div class="line">        .pipe(uglify())</div><div class="line">    <span class="comment">// 3. 另存压缩后的文件</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/js'</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li><code>gulp.task(name, fn)</code> - 定义任务，第一个参数是任务名，第二个参数是任务内容。</li>
<li><code>gulp.src(path)</code> - 选择文件，传入参数是文件路径。</li>
<li><code>gulp.dest(path)</code> - 输出文件</li>
<li><code>gulp.pipe()</code> - 管道，你可以暂时将 pipe 理解为将操作加入执行队列</li>
</ul>
<p>参考：<a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="external">gulp API文档</a></p>
<hr>
<p><strong>五、跳转至 <code>gulpfile.js</code> 所在目录</strong></p>
<p>打开命令行使用 <code>cd</code> 命令跳转至 <code>gulpfile.js</code> 文件所在目录。</p>
<p>例如我的 <code>gulpfile.js</code> 文件保存在 <code>C:\gulp-book\demo\chapter2\gulpfile.js</code>。</p>
<p>那么就需要在命令行输入<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd C:<span class="symbol">\g</span>ulp-book<span class="symbol">\d</span>emo<span class="symbol">\c</span>hapter2</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Mac 用户可使用 <code>cd Documents/gulp-book/demo/chapter2/</code> 跳转</p>
</blockquote>
<hr>
<p><strong>六、使用命令行运行 script 任务</strong></p>
<p>在控制台输入 <code>gulp 任务名</code> 可运行任务，此处我们输入 <code>gulp script</code> 回车。</p>
<p>注意：输入 <code>gulp script</code> 后命令行将会提示错误信息<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在命令行输入</span></div><div class="line">gulp script</div><div class="line"></div><div class="line">Error: Cannot find module <span class="string">'gulp-uglify'</span></div><div class="line">    at Function<span class="selector-class">.Module</span>._resolveFilename (module<span class="selector-class">.js</span>:<span class="number">338</span>:<span class="number">15</span>)</div><div class="line">    at Function<span class="selector-class">.Module</span>._load (module<span class="selector-class">.js</span>:<span class="number">280</span>:<span class="number">25</span>)</div></pre></td></tr></table></figure></p>
<p><code>Cannot find module &#39;gulp-uglify&#39;</code> 没有找到 <code>gulp-uglify</code> 模块。</p>
<hr>
<p><strong>七、安装 <code>gulp-uglify</code> 模块</strong></p>
<p>因为我们并没有安装 <code>gulp-uglify</code> 模块到本地，所以找不到此模块。</p>
<p>使用 npm 安装 <code>gulp-uglify</code> 到本地</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> gulp-uglify</div></pre></td></tr></table></figure>
<p>安装成功后你会看到如下信息：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp-uglify<span class="variable">@1</span>.<span class="number">1.0</span> node_modules/gulp-uglify</div><div class="line">├── deepmerge<span class="variable">@0</span>.<span class="number">2.7</span></div><div class="line">├── uglify-js<span class="variable">@2</span>.<span class="number">4.16</span> (uglify-to-browserify<span class="variable">@1</span>.<span class="number">0.2</span>, async<span class="variable">@0</span>.<span class="number">2.10</span>, source-map<span class="variable">@0</span>.<span class="number">1.34</span>, optimist<span class="variable">@0</span>.<span class="number">3.7</span>)</div><div class="line">├── vinyl-sourcemaps-apply<span class="variable">@0</span>.<span class="number">1.4</span> (source-map<span class="variable">@0</span>.<span class="number">1.43</span>)</div><div class="line">├── through2<span class="variable">@0</span>.<span class="number">6.3</span> (xtend<span class="variable">@4</span>.<span class="number">0.0</span>, readable-stream<span class="variable">@1</span>.<span class="number">0.33</span>)</div><div class="line">└── gulp-util<span class="variable">@3</span>.<span class="number">0.4</span> (array-differ<span class="variable">@1</span>.<span class="number">0.0</span>, beeper<span class="variable">@1</span>.<span class="number">0.0</span>, array-uniq<span class="variable">@1</span>.<span class="number">0.2</span>, object-assign<span class="variable">@2</span>.<span class="number">0.0</span>, lodash._reinterpolate<span class="variable">@3</span>.<span class="number">0.0</span>, lodash._reescape<span class="variable">@3</span>.<span class="number">0.0</span>, lodash._reevaluate<span class="variable">@3</span>.<span class="number">0.0</span>, replace-ext<span class="variable">@0</span>.<span class="number">0.1</span>, minimist<span class="variable">@1</span>.<span class="number">1.1</span>, chalk<span class="variable">@1</span>.<span class="number">0.0</span>, lodash.template<span class="variable">@3</span>.<span class="number">3.2</span>, vinyl<span class="variable">@0</span>.<span class="number">4.6</span>, multipipe<span class="variable">@0</span>.<span class="number">1.2</span>, dateformat<span class="variable">@1</span>.<span class="number">0.11</span>)</div><div class="line">chapter2 $</div></pre></td></tr></table></figure></p>
<p>在你的文件夹中会新增一个 <code>node_modules</code> 文件夹，这里面存放着 npm 安装的模块。</p>
<p>目录结构：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">├── gulpfile<span class="selector-class">.js</span></div><div class="line">└── node_modules</div><div class="line">	└── gulp-uglify</div></pre></td></tr></table></figure></p>
<p>接着输入 <code>gulp script</code> 执行任务</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gulp script</div><div class="line">[<span class="number">13</span>:<span class="number">34</span>:<span class="number">57</span>] <span class="symbol">Using</span> gulpfile ~/<span class="symbol">Documents</span>/code/gulp-book/demo/chapter2/gulpfile.js</div><div class="line">[<span class="number">13</span>:<span class="number">34</span>:<span class="number">57</span>] <span class="symbol">Starting</span> <span class="string">'script'</span>...</div><div class="line">[<span class="number">13</span>:<span class="number">34</span>:<span class="number">57</span>] <span class="symbol">Finished</span> <span class="string">'script'</span> after <span class="number">6.13</span> ms</div></pre></td></tr></table></figure>
<hr>
<p><strong>八、编写 js 文件</strong></p>
<p>我们发现 gulp 没有进行任何压缩操作。因为没有js这个目录，也没有 js 目录下的 <code>.js</code> 后缀文件。</p>
<p>创建 <code>a.js</code> 文件，并编写如下内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    alert(<span class="string">'--------\r\n'</span> + msg + <span class="string">'\r\n--------'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">demo(<span class="string">'Hi'</span>)</div></pre></td></tr></table></figure>
<p>目录结构：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">├── gulpfile<span class="selector-class">.js</span></div><div class="line">├──  js</div><div class="line">│	└── <span class="selector-tag">a</span><span class="selector-class">.js</span></div><div class="line">└── node_modules</div><div class="line">	└── gulp-uglify</div></pre></td></tr></table></figure></p>
<p>接着在命令行输入 <code>gulp script</code> 执行任务</p>
<p>gulp 会在命令行当前目录下创建 <code>dist/js/</code> 文件夹，并创建压缩后的 <code>a.js</code> 文件。</p>
<p>目录结构：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">├── gulpfile<span class="selector-class">.js</span></div><div class="line">├──  js</div><div class="line">│	└── <span class="selector-tag">a</span><span class="selector-class">.js</span></div><div class="line">├──  dist</div><div class="line">│	└── js</div><div class="line">│		└── <span class="selector-tag">a</span><span class="selector-class">.js</span></div><div class="line">└── node_modules</div><div class="line">	└── gulp-uglify</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/nimojs/gulp-book/blob/master/demo/chapter2/dist/js/a.js" target="_blank" rel="external">dist/js/a.js</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">n</span>)</span>&#123;alert(<span class="string">"--------\r\n"</span>+n+<span class="string">"\r\n--------"</span>)&#125;demo(<span class="string">"Hi"</span>);</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>九、检测代码修改自动执行任务</strong></p>
<p><code>js/a.js</code>一旦有修改 就必须重新在命令行输入 <code>gulp script</code> ，这很麻烦。</p>
<p>可以使用 <code>gulp.watch(src, fn)</code> 检测指定目录下文件的修改后执行任务。</p>
<p>在 <code>gulpfile.js</code> 中编写如下代码：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听文件修改，当文件被修改则执行 script 任务</span></div><div class="line">gulp<span class="selector-class">.watch</span>(<span class="string">'js/*.js'</span>, [<span class="string">'script'</span>]);</div></pre></td></tr></table></figure></p>
<p>但是没有命令可以运行 <code>gulp.watch()</code>，需要将 <code>gulp.watch()</code> 包含在一个任务中。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在命令行使用 gulp auto 启动此任务</span></div><div class="line"><span class="selector-tag">gulp</span><span class="selector-class">.task</span>(<span class="string">'auto'</span>, function () &#123;</div><div class="line">    <span class="comment">// 监听文件修改，当文件被修改则执行 script 任务</span></div><div class="line">    gulp<span class="selector-class">.watch</span>(<span class="string">'js/*.js'</span>, [<span class="string">'script'</span>])</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>接着在命令行输入 <code>gulp auto</code>，自动监听 <code>js/*.js</code> 文件的修改后压缩js。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gulp</span> auto</div><div class="line">[<span class="number">21</span><span class="symbol">:</span>09<span class="symbol">:</span><span class="number">45</span>] Using gulpfile ~<span class="regexp">/Documents/code</span><span class="regexp">/gulp-book/demo</span><span class="regexp">/chapter2/gulpfile</span>.js</div><div class="line">[<span class="number">21</span><span class="symbol">:</span>09<span class="symbol">:</span><span class="number">45</span>] Starting <span class="string">'auto'</span>...</div><div class="line">[<span class="number">21</span><span class="symbol">:</span>09<span class="symbol">:</span><span class="number">45</span>] Finished <span class="string">'auto'</span> after <span class="number">9.19</span> ms</div></pre></td></tr></table></figure>
<p>此时修改 <code>js/a.js</code> 中的代码并保存。命令行将会出现提示，表示检测到文件修改并压缩文件。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="name">21:11:01</span>] Starting <span class="symbol">'script</span><span class="symbol">'...</span></div><div class="line">[<span class="name">21:11:01</span>] Finished <span class="symbol">'script</span>' after <span class="number">2.85</span> ms</div></pre></td></tr></table></figure>
<p>至此，我们完成了 gulp 压缩 js 文件的自动化代码编写。</p>
<p><strong>注意：</strong>使用 <code>gulp.watch</code> 后你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 <code>Ctrl + C</code> 停止 gulp。</p>
<blockquote>
<p>Mac 下使用 <code>control + C</code> 停止 gulp</p>
</blockquote>
<p><strong>十、使用 gulp.task(‘default’, fn) 定义默认任务</strong></p>
<p>增加如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'script'</span>, <span class="string">'auto'</span>]);</div></pre></td></tr></table></figure>
<p>此时你可以在命令行直接输入 <code>gulp</code> +回车，运行 <code>script</code> 和 <code>auto</code> 任务。</p>
<p>最终代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 gulp</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 获取 uglify 模块（用于压缩 JS）</span></div><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 压缩 js 文件</span></div><div class="line"><span class="comment">// 在命令行使用 gulp script 启动此任务</span></div><div class="line">gulp.task(<span class="string">'script'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 1. 找到文件</span></div><div class="line">    gulp.src(<span class="string">'js/*.js'</span>)</div><div class="line">    <span class="comment">// 2. 压缩文件</span></div><div class="line">        .pipe(uglify())</div><div class="line">    <span class="comment">// 3. 另存压缩后的文件</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/js'</span>))</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 在命令行使用 gulp auto 启动此任务</span></div><div class="line">gulp.task(<span class="string">'auto'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 监听文件修改，当文件被修改则执行 script 任务</span></div><div class="line">    gulp.watch(<span class="string">'js/*.js'</span>, [<span class="string">'script'</span>])</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 使用 gulp.task('default') 定义默认任务</span></div><div class="line"><span class="comment">// 在命令行使用 gulp 启动 script 任务和 auto 任务</span></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'script'</span>, <span class="string">'auto'</span>])</div></pre></td></tr></table></figure>
<p>去除注释后，你会发现只需要 11 行代码就可以让 gulp 自动监听 js 文件的修改后压缩代码。但是还有还有一些性能问题和缺少容错性，将在后面的章节详细说明。</p>
<p>你可以访问 <a href="https://github.com/terinjokes/gulp-uglify" target="_blank" rel="external">gulp-uglify</a> 以查看更多用法。</p>
<h1 id="使用-gulp-压缩-CSS"><a href="#使用-gulp-压缩-CSS" class="headerlink" title="使用 gulp 压缩 CSS"></a>使用 gulp 压缩 CSS</h1><hr>
<p>压缩 css 代码可降低 css 文件大小，提高页面打开速度。</p>
<p>我们接着将规律转换为 gulp 代码</p>
<h2 id="规律-2"><a href="#规律-2" class="headerlink" title="规律"></a>规律</h2><p>找到 <code>css/</code> 目录下的所有 css 文件，压缩它们，将压缩后的文件存放在 <code>dist/css/</code> 目录下。</p>
<h2 id="gulp-代码-1"><a href="#gulp-代码-1" class="headerlink" title="gulp 代码"></a>gulp 代码</h2><p>你可以 <a href="https://github.com/nimojs/gulp-book/archive/master.zip" target="_blank" rel="external">下载所有示例代码</a> 或 <a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter3" target="_blank" rel="external">在线查看代码</a></p>
<p>当熟悉 <a href="chapter2.md">使用 gulp 压缩 JS</a> 的方法后，配置压缩 CSS 的 gulp 代码就变得很轻松。</p>
<p><strong>一、安装 gulp-minify-css</strong> 模块</p>
<p>提示：你需要使用命令行的 <code>cd</code> 切换到对应目录后进行安装操作。</p>
<p><a href="chapter1.md">学习使用命令行</a></p>
<p>在命令行输入</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> gulp-minify-css</div></pre></td></tr></table></figure>
<p>安装成功后你会看到如下信息：(安装时间可能会比较长)</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp-minify-css<span class="variable">@1</span>.<span class="number">0.0</span> node_modules/gulp-minify-css</div><div class="line">├── object-assign<span class="variable">@2</span>.<span class="number">0.0</span></div><div class="line">├── vinyl-sourcemaps-apply<span class="variable">@0</span>.<span class="number">1.4</span> (source-map<span class="variable">@0</span>.<span class="number">1.43</span>)</div><div class="line">├── clean-css<span class="variable">@3</span>.<span class="number">1.8</span> (commander<span class="variable">@2</span>.<span class="number">6.0</span>, source-map<span class="variable">@0</span>.<span class="number">1.43</span>)</div><div class="line">├── through2<span class="variable">@0</span>.<span class="number">6.3</span> (xtend<span class="variable">@4</span>.<span class="number">0.0</span>, readable-stream<span class="variable">@1</span>.<span class="number">0.33</span>)</div><div class="line">├── vinyl-bufferstream<span class="variable">@1</span>.<span class="number">0.1</span> (bufferstreams<span class="variable">@1</span>.<span class="number">0.1</span>)</div><div class="line">└── gulp-util<span class="variable">@3</span>.<span class="number">0.4</span> (array-differ<span class="variable">@1</span>.<span class="number">0.0</span>, beeper<span class="variable">@1</span>.<span class="number">0.0</span>, array-uniq<span class="variable">@1</span>.<span class="number">0.2</span>, lodash._reescape<span class="variable">@3</span>.<span class="number">0.0</span>, lodash._reinterpolate<span class="variable">@3</span>.<span class="number">0.0</span>, lodash._reevaluate<span class="variable">@3</span>.<span class="number">0.0</span>, replace-ext<span class="variable">@0</span>.<span class="number">0.1</span>, minimist<span class="variable">@1</span>.<span class="number">1.1</span>, multipipe<span class="variable">@0</span>.<span class="number">1.2</span>, vinyl<span class="variable">@0</span>.<span class="number">4.6</span>, chalk<span class="variable">@1</span>.<span class="number">0.0</span>, lodash.template<span class="variable">@3</span>.<span class="number">3.2</span>, dateformat<span class="variable">@1</span>.<span class="number">0.11</span>)</div></pre></td></tr></table></figure>
<p><strong>二、参照 <a href="chapter2.md">使用 gulp 压缩 JS</a> 创建 <code>gulpfile.js</code> 文件编写代码</strong></p>
<p>在对应目录创建 <code>gulpfile.js</code> 文件并写入如下内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 gulp</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 获取 minify-css 模块（用于压缩 CSS）</span></div><div class="line"><span class="keyword">var</span> minifyCSS = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 压缩 css 文件</span></div><div class="line"><span class="comment">// 在命令行使用 gulp css 启动此任务</span></div><div class="line">gulp.task(<span class="string">'css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 1. 找到文件</span></div><div class="line">    gulp.src(<span class="string">'css/*.css'</span>)</div><div class="line">    <span class="comment">// 2. 压缩文件</span></div><div class="line">        .pipe(minifyCSS())</div><div class="line">    <span class="comment">// 3. 另存为压缩文件</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/css'</span>))</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 在命令行使用 gulp auto 启动此任务</span></div><div class="line">gulp.task(<span class="string">'auto'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 监听文件修改，当文件被修改则执行 css 任务</span></div><div class="line">    gulp.watch(<span class="string">'css/*.css'</span>, [<span class="string">'css'</span>])</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 使用 gulp.task('default') 定义默认任务</span></div><div class="line"><span class="comment">// 在命令行使用 gulp 启动 css 任务和 auto 任务</span></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'css'</span>, <span class="string">'auto'</span>])</div></pre></td></tr></table></figure>
<p>你可以访问 <a href="https://github.com/jonathanepollack/gulp-minify-css" target="_blank" rel="external">gulp-minify-css</a> 以查看更多用法。</p>
<hr>
<p><strong>三、创建 css 文件</strong></p>
<p>在 <code>gulpfile.js</code> 对应目录创建 <code>css</code> 文件夹，并在 <code>css/</code> 目录下创建 <code>a.css</code> 文件。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* a.css */</span></div><div class="line"><span class="selector-tag">body</span> <span class="selector-tag">a</span>&#123;</div><div class="line">    <span class="attribute">color</span>:pink;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>四、运行 gulp 查看效果</strong></p>
<p>在命令行输入 <code>gulp</code> +回车</p>
<p>你将看到命令行出现如下提示</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gulp</div><div class="line">[<span class="number">17</span>:<span class="number">01</span>:<span class="number">19</span>] <span class="symbol">Using</span> gulpfile ~/<span class="symbol">Documents</span>/code/gulp-book/demo/chapter3/gulpfile.js</div><div class="line">[<span class="number">17</span>:<span class="number">01</span>:<span class="number">19</span>] <span class="symbol">Starting</span> <span class="string">'css'</span>...</div><div class="line">[<span class="number">17</span>:<span class="number">01</span>:<span class="number">19</span>] <span class="symbol">Finished</span> <span class="string">'css'</span> after <span class="number">6.21</span> ms</div><div class="line">[<span class="number">17</span>:<span class="number">01</span>:<span class="number">19</span>] <span class="symbol">Starting</span> <span class="string">'auto'</span>...</div><div class="line">[<span class="number">17</span>:<span class="number">01</span>:<span class="number">19</span>] <span class="symbol">Finished</span> <span class="string">'auto'</span> after <span class="number">5.42</span> ms</div><div class="line">[<span class="number">17</span>:<span class="number">01</span>:<span class="number">19</span>] <span class="symbol">Starting</span> <span class="string">'default'</span>...</div><div class="line">[<span class="number">17</span>:<span class="number">01</span>:<span class="number">19</span>] <span class="symbol">Finished</span> <span class="string">'default'</span> after <span class="number">5.71</span> μs</div></pre></td></tr></table></figure>
<p>gulp 会创建 <code>dist/css</code> 目录，并创建 <code>a.css</code> 文件，此文件存放压缩后的 css 代码。<br><a href="https://github.com/nimojs/gulp-book/blob/master/demo/chapter3/dist/css/a.css" target="_blank" rel="external">dist/css/a.css</a></p>
<p><a href="https://github.com/nimojs/gulp-book/issues/12" target="_blank" rel="external">访问论坛获取帮助</a></p>
<p><a href="chapter4.md">接着阅读：使用 gulp 压缩图片</a></p>
<h1 id="使用-gulp-压缩图片"><a href="#使用-gulp-压缩图片" class="headerlink" title="使用 gulp 压缩图片"></a>使用 gulp 压缩图片</h1><p>请务必理解如下章节后阅读此章节：</p>
<ol>
<li><a href="chapter1.md">安装 Node 和 gulp</a></li>
<li><a href="chapter2.md">使用 gulp 压缩 JS</a></li>
</ol>
<h2 id="访问论坛获取帮助"><a href="#访问论坛获取帮助" class="headerlink" title="访问论坛获取帮助"></a><a href="https://github.com/nimojs/gulp-book/issues/13" target="_blank" rel="external">访问论坛获取帮助</a></h2><p>压缩 图片文件可降低文件大小，提高图片加载速度。</p>
<p>找到规律转换为 gulp 代码</p>
<h2 id="规律-3"><a href="#规律-3" class="headerlink" title="规律"></a>规律</h2><p>找到 <code>images/</code> 目录下的所有文件，压缩它们，将压缩后的文件存放在 <code>dist/images/</code> 目录下。</p>
<h2 id="gulp-代码-2"><a href="#gulp-代码-2" class="headerlink" title="gulp 代码"></a>gulp 代码</h2><p>你可以 <a href="https://github.com/nimojs/gulp-book/archive/master.zip" target="_blank" rel="external">下载所有示例代码</a> 或 <a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter4" target="_blank" rel="external">在线查看代码</a></p>
<p><strong>一、安装 gulp-imagemin</strong> 模块</p>
<p>提示：你需要使用命令行的 <code>cd</code> 切换至对应目录再进行安装操作和 gulp 启动操作。</p>
<p><a href="chapter1.md">学习使用命令行</a></p>
<p>在命令行输入</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> gulp-imagemin</div></pre></td></tr></table></figure>
<p>安装成功后你会看到如下信息：(安装时间可能会比较长)</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gulp-imagemin<span class="variable">@2</span>.<span class="number">2.1</span> node_modules/gulp-imagemin</div><div class="line">├── object-assign<span class="variable">@2</span>.<span class="number">0.0</span></div><div class="line">├── pretty-bytes<span class="variable">@1</span>.<span class="number">0.3</span> (get-stdin<span class="variable">@4</span>.<span class="number">0.1</span>)</div><div class="line">├── chalk<span class="variable">@1</span>.<span class="number">0.0</span> (escape-string-regexp<span class="variable">@1</span>.<span class="number">0.3</span>, ansi-styles<span class="variable">@2</span>.<span class="number">0.1</span>, supports-color<span class="variable">@1</span>.<span class="number">3.1</span>, has-ansi<span class="variable">@1</span>.<span class="number">0.3</span>, strip-ansi<span class="variable">@2</span>.<span class="number">0.1</span>)</div><div class="line">├── through2-concurrent<span class="variable">@0</span>.<span class="number">3.1</span> (through2<span class="variable">@0</span>.<span class="number">6.3</span>)</div><div class="line">├── gulp-util<span class="variable">@3</span>.<span class="number">0.4</span> (array-differ<span class="variable">@1</span>.<span class="number">0.0</span>, beeper<span class="variable">@1</span>.<span class="number">0.0</span>, array-uniq<span class="variable">@1</span>.<span class="number">0.2</span>, lodash._reevaluate<span class="variable">@3</span>.<span class="number">0.0</span>, lodash._reescape<span class="variable">@3</span>.<span class="number">0.0</span>, lodash._reinterpolate<span class="variable">@3</span>.<span class="number">0.0</span>, replace-ext<span class="variable">@0</span>.<span class="number">0.1</span>, minimist<span class="variable">@1</span>.<span class="number">1.1</span>, vinyl<span class="variable">@0</span>.<span class="number">4.6</span>, through2<span class="variable">@0</span>.<span class="number">6.3</span>, multipipe<span class="variable">@0</span>.<span class="number">1.2</span>, lodash.template<span class="variable">@3</span>.<span class="number">3.2</span>, dateformat<span class="variable">@1</span>.<span class="number">0.11</span>)</div><div class="line">└── imagemin<span class="variable">@3</span>.<span class="number">1.0</span> (get-stdin<span class="variable">@3</span>.<span class="number">0.2</span>, optional<span class="variable">@0</span>.<span class="number">1.3</span>, vinyl<span class="variable">@0</span>.<span class="number">4.6</span>, through2<span class="variable">@0</span>.<span class="number">6.3</span>, stream-combiner<span class="variable">@0</span>.<span class="number">2.1</span>, concat-stream<span class="variable">@1</span>.<span class="number">4.7</span>, meow<span class="variable">@2</span>.<span class="number">1.0</span>, vinyl-fs<span class="variable">@0</span>.<span class="number">3.13</span>, imagemin-svgo<span class="variable">@4</span>.<span class="number">1.2</span>, imagemin-optipng<span class="variable">@4</span>.<span class="number">2.0</span>, imagemin-jpegtran<span class="variable">@4</span>.<span class="number">1.0</span>, imagemin-pngquant<span class="variable">@4</span>.<span class="number">0.0</span>, imagemin-gifsicle<span class="variable">@4</span>.<span class="number">1.0</span>)</div></pre></td></tr></table></figure>
<p><strong>二、创建 <code>gulpfile.js</code> 文件编写代码</strong></p>
<p>在对应目录创建 <code>gulpfile.js</code> 文件并写入如下内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 gulp</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 获取 gulp-imagemin 模块</span></div><div class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 压缩图片任务</span></div><div class="line"><span class="comment">// 在命令行输入 gulp images 启动此任务</span></div><div class="line">gulp.task(<span class="string">'images'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 1. 找到图片</span></div><div class="line">    gulp.src(<span class="string">'images/*.*'</span>)</div><div class="line">    <span class="comment">// 2. 压缩图片</span></div><div class="line">        .pipe(imagemin(&#123;</div><div class="line">            progressive: <span class="literal">true</span></div><div class="line">        &#125;))</div><div class="line">    <span class="comment">// 3. 另存图片</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/images'</span>))</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 在命令行使用 gulp auto 启动此任务</span></div><div class="line">gulp.task(<span class="string">'auto'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 监听文件修改，当文件被修改则执行 images 任务</span></div><div class="line">    gulp.watch(<span class="string">'images/*.*)'</span>, [<span class="string">'images'</span>])</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 使用 gulp.task('default') 定义默认任务</span></div><div class="line"><span class="comment">// 在命令行使用 gulp 启动 images 任务和 auto 任务</span></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'images'</span>, <span class="string">'auto'</span>])</div></pre></td></tr></table></figure>
<p>你可以访问 <a href="https://github.com/sindresorhus/gulp-imagemin" target="_blank" rel="external">gulp-imagemin</a> 以查看更多用法。</p>
<hr>
<p><strong>三、在 <code>images/</code> 目录下存放图片</strong></p>
<p>在 <code>gulpfile.js</code> 对应目录创建 <code>images</code> 文件夹，并在 <code>images/</code> 目录下存放图片。</p>
<p>你可以访问 <a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter4/images/" target="_blank" rel="external">https://github.com/nimojs/gulp-book/tree/master/demo/chapter4/images/</a> 下载示例图片</p>
<hr>
<p><strong>四、运行 gulp 查看效果</strong></p>
<p>在命令行输入 <code>gulp</code> +回车</p>
<p>你将看到命令行出现如下提示</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gulp</div><div class="line">[<span class="number">18</span>:<span class="number">10</span>:<span class="number">42</span>] <span class="symbol">Using</span> gulpfile ~/<span class="symbol">Documents</span>/code/gulp-book/demo/chapter4/gulpfile.js</div><div class="line">[<span class="number">18</span>:<span class="number">10</span>:<span class="number">42</span>] <span class="symbol">Starting</span> <span class="string">'images'</span>...</div><div class="line">[<span class="number">18</span>:<span class="number">10</span>:<span class="number">42</span>] <span class="symbol">Finished</span> <span class="string">'images'</span> after <span class="number">5.72</span> ms</div><div class="line">[<span class="number">18</span>:<span class="number">10</span>:<span class="number">42</span>] <span class="symbol">Starting</span> <span class="string">'auto'</span>...</div><div class="line">[<span class="number">18</span>:<span class="number">10</span>:<span class="number">42</span>] <span class="symbol">Finished</span> <span class="string">'auto'</span> after <span class="number">6.39</span> ms</div><div class="line">[<span class="number">18</span>:<span class="number">10</span>:<span class="number">42</span>] <span class="symbol">Starting</span> <span class="string">'default'</span>...</div><div class="line">[<span class="number">18</span>:<span class="number">10</span>:<span class="number">42</span>] <span class="symbol">Finished</span> <span class="string">'default'</span> after <span class="number">5.91</span> μs</div><div class="line">[<span class="number">18</span>:<span class="number">10</span>:<span class="number">42</span>] gulp-imagemin: <span class="symbol">Minified</span> <span class="number">3</span> images (saved <span class="number">25.83</span> kB - <span class="number">5.2</span><span class="comment">%)</span></div></pre></td></tr></table></figure>
<h1 id="使用-gulp-编译-LESS"><a href="#使用-gulp-编译-LESS" class="headerlink" title="使用 gulp 编译 LESS"></a>使用 gulp 编译 LESS</h1><hr>
<blockquote>
<p>Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> gulp-<span class="keyword">less</span></div></pre></td></tr></table></figure>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 gulp</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</div><div class="line"><span class="comment">// 获取 gulp-less 模块</span></div><div class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 编译less</span></div><div class="line"><span class="comment">// 在命令行输入 gulp less 启动此任务</span></div><div class="line">gulp.task(<span class="string">'less'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 1. 找到 less 文件</span></div><div class="line">    gulp.src(<span class="string">'less/**.less'</span>)</div><div class="line">    <span class="comment">// 2. 编译为css</span></div><div class="line">        .pipe(less())</div><div class="line">    <span class="comment">// 3. 另存文件</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/css'</span>))</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 在命令行使用 gulp auto 启动此任务</span></div><div class="line">gulp.task(<span class="string">'auto'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 监听文件修改，当文件被修改则执行 less 任务</span></div><div class="line">    gulp.watch(<span class="string">'less/**.less'</span>, [<span class="string">'less'</span>])</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 使用 gulp.task('default') 定义默认任务</span></div><div class="line"><span class="comment">// 在命令行使用 gulp 启动 less 任务和 auto 任务</span></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'less'</span>, <span class="string">'auto'</span>])</div></pre></td></tr></table></figure>
<p>你可以访问 <a href="https://github.com/plus3network/gulp-less" target="_blank" rel="external">gulp-less</a> 以查看更多用法。</p>
<h2 id="LESS-代码和编译后的CSS代码"><a href="#LESS-代码和编译后的CSS代码" class="headerlink" title="LESS 代码和编译后的CSS代码"></a>LESS 代码和编译后的CSS代码</h2><p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter5/less/a.less" target="_blank" rel="external">less/a.less</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.less&#123;</div><div class="line">	a&#123;</div><div class="line">        color:pink;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter5/less/import.less" target="_blank" rel="external">less/import.less</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@import "a.less";</div><div class="line">.import&#123;</div><div class="line">	a&#123;</div><div class="line">		color:red;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter5/dist/css/a.css" target="_blank" rel="external">less/a.css</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.less</span> <span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">color</span>: pink;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter5/dist/css/import.css" target="_blank" rel="external">less/import.css</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.less</span> <span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">color</span>: pink;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.import</span> <span class="selector-tag">a</span>&#123;</div><div class="line">  <span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="使用-gulp-编译-Sass"><a href="#使用-gulp-编译-Sass" class="headerlink" title="使用 gulp 编译 Sass"></a>使用 gulp 编译 Sass</h1><blockquote>
<p>无论是 <code>node-sass</code> 还是 <code>ruby-sass</code> 使用 npm 安装都非常的慢，甚至会装不上。及其不利于团队协作。建议使用 less 作为 css 预处理器。<br>如果因为 less 不支持自定义函数选择用 sass 可以使用 <a href="https://github.com/seven-phases-max/less-plugin-functions" target="_blank" rel="external">less-plugin-functions</a> 让 less 支持自定义函数。</p>
</blockquote>
<h2 id="gulp-sass"><a href="#gulp-sass" class="headerlink" title="gulp-sass"></a>gulp-sass</h2><p>本章使用的是 ruby-sass 如果你不方便安装 ruby 或编译速度慢，建议使用 <a href="https://github.com/dlmanning/gulp-sass" target="_blank" rel="external">gulp-sass</a></p>
<hr>
<blockquote>
<p>Sass 是一种 CSS 的开发工具，提供了许多便利的写法，大大节省了开发者的时间，使得 CSS 的开发，变得简单和可维护。</p>
</blockquote>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> gulp-ruby-sass</div></pre></td></tr></table></figure>
<h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>你可以 <a href="https://github.com/nimojs/gulp-book/archive/master.zip" target="_blank" rel="external">下载所有示例代码</a> 或 <a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter6" target="_blank" rel="external">在线查看代码</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 gulp</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</div><div class="line"><span class="comment">// 获取 gulp-ruby-sass 模块</span></div><div class="line"><span class="keyword">var</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-ruby-sass'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 编译sass</span></div><div class="line"><span class="comment">// 在命令行输入 gulp sass 启动此任务</span></div><div class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sass(<span class="string">'sass/'</span>)</div><div class="line">    .on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">'Error!'</span>, err.message);</div><div class="line">   &#125;)</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/css'</span>))</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 在命令行使用 gulp auto 启动此任务</span></div><div class="line">gulp.task(<span class="string">'auto'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 监听文件修改，当文件被修改则执行 images 任务</span></div><div class="line">    gulp.watch(<span class="string">'sass/**/*.scss'</span>, [<span class="string">'sass'</span>])</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 使用 gulp.task('default') 定义默认任务</span></div><div class="line"><span class="comment">// 在命令行使用 gulp 启动 sass 任务和 auto 任务</span></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'sass'</span>, <span class="string">'auto'</span>])</div></pre></td></tr></table></figure>
<h2 id="Sass-代码和编译后的-CSS-代码"><a href="#Sass-代码和编译后的-CSS-代码" class="headerlink" title="Sass 代码和编译后的 CSS 代码"></a>Sass 代码和编译后的 CSS 代码</h2><p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter6/sass/a.scss" target="_blank" rel="external">sass/a.scss</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.sass&#123;</div><div class="line">	a&#123;</div><div class="line">        color:pink;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter6/sass/import.scss" target="_blank" rel="external">sass/import.scss</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@import "a.scss";</div><div class="line">.import&#123;</div><div class="line">	a&#123;</div><div class="line">		color:red;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter6/dist/css/a.css" target="_blank" rel="external">sass/a.css</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.sass</span> <span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">color</span>: pink;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter6/dist/css/import.css" target="_blank" rel="external">sass/import.css</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.sass</span> <span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">color</span>: pink;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.import</span> <span class="selector-tag">a</span>&#123;</div><div class="line">  <span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="使用-gulp-构建一个项目"><a href="#使用-gulp-构建一个项目" class="headerlink" title="使用 gulp 构建一个项目"></a>使用 gulp 构建一个项目</h1><hr>
<p>本章将介绍</p>
<ul>
<li><a href="https://github.com/nimojs/gulp-watch-path" target="_blank" rel="external">gulp-watch-path</a></li>
<li><a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/combining-streams-to-handle-errors.md" target="_blank" rel="external">stream-combiner2</a></li>
<li><a href="https://github.com/floridoo/gulp-sourcemaps" target="_blank" rel="external">gulp-sourcemaps</a></li>
<li><a href="https://github.com/sindresorhus/gulp-autoprefixer/blob/master/package.json" target="_blank" rel="external">gulp-autoprefixer</a></li>
</ul>
<p>并将之前所有章节的内容组合起来编写一个前端项目所需的 gulp 代码。</p>
<p>你可以在 <a href="https://github.com/nimojs/gulp-demo" target="_blank" rel="external">nimojs/gulp-demo</a> 查看完整代码。</p>
<p>若你不了解npm 请务必阅读 <a href="http://javascript.ruanyifeng.com/nodejs/npm.html" target="_blank" rel="external">npm模块管理器</a></p>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>如果你熟悉 npm 则可以利用 <code>package.json</code> 保存所有 <code>npm install --save-dev gulp-xxx</code> 模块依赖和模块版本。</p>
<p>在命令行输入</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">npm</span> init</div></pre></td></tr></table></figure>
<p>会依次要求补全项目信息，不清楚的可以直接回车跳过<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">name:</span> (gulp-demo)</div><div class="line"><span class="string">version:</span> (<span class="number">1.0</span><span class="number">.0</span>)</div><div class="line"><span class="string">description:</span></div><div class="line">entry <span class="string">point:</span> (index.js)</div><div class="line">test <span class="string">command:</span></div><div class="line">...</div><div class="line">...</div><div class="line">Is <span class="keyword">this</span> ok? (yes)</div></pre></td></tr></table></figure></p>
<p>最终会在当前目录中创建 <code>package.json</code> 文件并生成类似如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"gulp-demo"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"0.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"repository"</span>: &#123;</div><div class="line">    <span class="string">"type"</span>: <span class="string">"git"</span>,</div><div class="line">    <span class="string">"url"</span>: <span class="string">"https://github.com/nimojs/gulp-demo.git"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"keywords"</span>: [</div><div class="line">    <span class="string">"gulp"</span>,</div><div class="line">  ],</div><div class="line">  <span class="string">"author"</span>: <span class="string">"nimojs &lt;nimo.jser@gmail.com&gt;"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span>,</div><div class="line">  <span class="string">"bugs"</span>: &#123;</div><div class="line">    <span class="string">"url"</span>: <span class="string">"https://github.com/nimojs/gulp-demo/issues"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"homepage"</span>: <span class="string">"https://github.com/nimojs/gulp-demo"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>安装 gulp 到项目（防止全局 gulp 升级后与此项目 <code>gulpfile.js</code> 代码不兼容）<br><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install gulp --<span class="built_in">save</span>-<span class="built_in">dev</span></div></pre></td></tr></table></figure></p>
<p>此时打开 <code>package.json</code> 会发现多了如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"devDependencies"</span>: &#123;</div><div class="line">	<span class="string">"gulp"</span>: <span class="string">"^3.8.11"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明此项目的开发依赖 gulp</p>
<p>接着安装其他依赖：</p>
<blockquote>
<p>安装模块较多，请耐心等待，若一直安装失败可使用<a href="http://npm.taobao.org/" target="_blank" rel="external">npm.taobao.org</a></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> gulp-uglify gulp-watch-<span class="keyword">path</span> stream-combiner2 gulp-sourcemaps gulp-minify-css gulp-autoprefixer gulp-<span class="keyword">less</span> gulp-ruby-sass gulp-imagemin gulp-util <span class="comment">--save-dev</span></div></pre></td></tr></table></figure>
<p>此时，<a href="https://github.com/nimojs/gulp-demo/blob/master/package.json" target="_blank" rel="external">package.json</a> 将会更新<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"colors"</span>: <span class="string">"^1.0.3"</span>,</div><div class="line">    <span class="string">"gulp"</span>: <span class="string">"^3.8.11"</span>,</div><div class="line">    <span class="string">"gulp-autoprefixer"</span>: <span class="string">"^2.1.0"</span>,</div><div class="line">    <span class="string">"gulp-imagemin"</span>: <span class="string">"^2.2.1"</span>,</div><div class="line">    <span class="string">"gulp-less"</span>: <span class="string">"^3.0.2"</span>,</div><div class="line">    <span class="string">"gulp-minify-css"</span>: <span class="string">"^1.0.0"</span>,</div><div class="line">    <span class="string">"gulp-ruby-sass"</span>: <span class="string">"^1.0.1"</span>,</div><div class="line">    <span class="string">"gulp-sourcemaps"</span>: <span class="string">"^1.5.1"</span>,</div><div class="line">    <span class="string">"gulp-uglify"</span>: <span class="string">"^1.1.0"</span>,</div><div class="line">    <span class="string">"gulp-watch-path"</span>: <span class="string">"^0.0.7"</span>,</div><div class="line">    <span class="string">"stream-combiner2"</span>: <span class="string">"^1.0.2"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当你将这份 gulpfile.js 配置分享给你的朋友时，就不需要将 <code>node_modules/</code> 发送给他，他只需在命令行输入<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span></div></pre></td></tr></table></figure></p>
<p>就可以检测 <code>package.json</code> 中的 <code>devDependencies</code> 并安装所有依赖。</p>
<h2 id="设计目录结构"><a href="#设计目录结构" class="headerlink" title="设计目录结构"></a>设计目录结构</h2><p>我们将文件分为2类，一类是源码，一类是编译压缩后的版本。文件夹分别为 <code>src</code> 和 <code>dist</code>。(注意区分 <code>dist</code> 和 ·<code>dest</code> 的区别)</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">└── src/</div><div class="line">│</div><div class="line">└── <span class="built_in">dist</span>/</div></pre></td></tr></table></figure>
<p><code>dist/</code> 目录下的文件都是根据 <code>src/</code> 下所有源码文件构建而成。</p>
<p>在 <code>src/</code> 下创建前端资源对应的的文件夹</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">└── src/</div><div class="line">	├── less/    *<span class="selector-class">.less</span> 文件</div><div class="line">	├── sass/    *<span class="selector-class">.scss</span> *<span class="selector-class">.sass</span> 文件</div><div class="line">	├── css/     *<span class="selector-class">.css</span>  文件</div><div class="line">	├── js/      *<span class="selector-class">.js</span> 文件</div><div class="line">	├── fonts/   字体文件</div><div class="line">    └── images/   图片</div><div class="line">└── dist/</div></pre></td></tr></table></figure>
<p>你可以点击 <a href="https://github.com/nimojs/gulp-demo/archive/master.zip" target="_blank" rel="external">nimojs/gulp-demo</a> 下载本章代码。</p>
<h2 id="让命令行输出的文字带颜色"><a href="#让命令行输出的文字带颜色" class="headerlink" title="让命令行输出的文字带颜色"></a>让命令行输出的文字带颜色</h2><p>gulp 自带的输出都带时间和颜色，这样很容易识别。我们利用 <a href="https://github.com/gulpjs/gulp-util" target="_blank" rel="external">gulp-util</a> 实现同样的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</div><div class="line"><span class="keyword">var</span> gutil = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gutil.log(<span class="string">'message'</span>)</div><div class="line">    gutil.log(gutil.colors.red(<span class="string">'error'</span>))</div><div class="line">    gutil.log(gutil.colors.green(<span class="string">'message:'</span>) + <span class="string">"some"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>使用 <code>gulp</code> 启动默认任务以测试<br><img src="https://cloud.githubusercontent.com/assets/3949015/7137629/a1def1b8-e2ed-11e4-83e0-5a6adb22de6f.png" alt="gulp-util"></p>
<h2 id="配置-JS-任务"><a href="#配置-JS-任务" class="headerlink" title="配置 JS 任务"></a>配置 JS 任务</h2><h3 id="gulp-uglify"><a href="#gulp-uglify" class="headerlink" title="gulp-uglify"></a>gulp-uglify</h3><p>检测<code>src/js/</code>目录下的 js 文件修改后，压缩 <code>js/</code> 中所有 js 文件并输出到 <code>dist/js/</code> 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'uglifyjs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.src(<span class="string">'src/js/**/*.js'</span>)</div><div class="line">        .pipe(uglify())</div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/js'</span>))</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/js/**/*.js'</span>, [<span class="string">'uglifyjs'</span>])</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>src/js/**/*.js</code> 是 glob 语法。<a href="http://baike.baidu.com/view/4019153.htm" target="_blank" rel="external">百度百科：glob模式</a> 、<a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">node-glob</a></p>
<p>在命令行输入 <code>gulp</code> 后会出现如下消息，表示已经启动。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">20</span><span class="symbol">:</span><span class="number">39</span><span class="symbol">:</span><span class="number">50</span>] Using gulpfile ~<span class="regexp">/Documents/code</span><span class="regexp">/gulp-book/demo</span><span class="regexp">/chapter7/gulpfile</span>.js</div><div class="line">[<span class="number">20</span><span class="symbol">:</span><span class="number">39</span><span class="symbol">:</span><span class="number">50</span>] Starting <span class="string">'default'</span>...</div><div class="line">[<span class="number">20</span><span class="symbol">:</span><span class="number">39</span><span class="symbol">:</span><span class="number">50</span>] Finished <span class="string">'default'</span> after <span class="number">13</span> ms</div></pre></td></tr></table></figure></p>
<p>此时编辑 <a href="https://github.com/nimojs/gulp-demo/blob/master/src/js/log.js" target="_blank" rel="external">src/js/log.js</a> 文件并保存，命令行会出现如下消息，表示检测到 <code>src/js/**/*.js</code> 文件修改后重新编译所有 js。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">20</span><span class="symbol">:</span><span class="number">39</span><span class="symbol">:</span><span class="number">52</span>] Starting <span class="string">'js'</span>...</div><div class="line">[<span class="number">20</span><span class="symbol">:</span><span class="number">39</span><span class="symbol">:</span><span class="number">52</span>] Finished <span class="string">'js'</span> after <span class="number">14</span> ms</div></pre></td></tr></table></figure>
<h3 id="gulp-watch-path"><a href="#gulp-watch-path" class="headerlink" title="gulp-watch-path"></a>gulp-watch-path</h3><p>此配置有个性能问题，当 <code>gulp.watch</code> 检测到  <code>src/js/</code> 目录下的js文件有修改时会将所有文件全部编译。实际上我们只需要重新编译被修改的文件。</p>
<p>简单介绍 <code>gulp.watch</code> 第二个参数为 <code>function</code> 时的用法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">gulp.watch(<span class="string">'src/js/**/*.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event);</div><div class="line">    <span class="comment">/*</span></div><div class="line">	当修改 src/js/log.js 文件时</div><div class="line">    event &#123;</div><div class="line">		// 发生改变的类型，不管是添加，改变或是删除</div><div class="line">        type: 'changed',</div><div class="line">		// 触发事件的文件路径</div><div class="line">        path: '/Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.js'</div><div class="line">    &#125;</div><div class="line">    */</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>我们可以利用 <code>event</code> 给到的信息，检测到某个 js 文件被修改时，只编写当前修改的 js 文件。</p>
<p>可以利用 <code>gulp-watch-path</code> 配合 <code>event</code> 获取编译路径和输出路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> watchPath = <span class="built_in">require</span>(<span class="string">'gulp-watch-path'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'watchjs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/js/**/*.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> paths = watchPath(event, <span class="string">'src/'</span>, <span class="string">'dist/'</span>)</div><div class="line">        <span class="comment">/*</span></div><div class="line">        paths</div><div class="line">            &#123; srcPath: 'src/js/log.js',</div><div class="line">              srcDir: 'src/js/',</div><div class="line">              distPath: 'dist/js/log.js',</div><div class="line">              distDir: 'dist/js/',</div><div class="line">              srcFilename: 'log.js',</div><div class="line">              distFilename: 'log.js' &#125;</div><div class="line">        */</div><div class="line">		gutil.log(gutil.colors.green(event.type) + <span class="string">' '</span> + paths.srcPath)</div><div class="line">        gutil.log(<span class="string">'Dist '</span> + paths.distPath)</div><div class="line"></div><div class="line">        gulp.src(paths.srcPath)</div><div class="line">            .pipe(uglify())</div><div class="line">            .pipe(gulp.dest(paths.distDir))</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'watchjs'</span>])</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter7/use-gulp-watch-path.js" target="_blank" rel="external">use-gulp-watch-path 完整代码</a></p>
<p><strong><code>watchPath(event, search, replace, distExt)</code></strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>event</td>
<td><code>gulp.watch</code> 回调函数的 <code>event</code></td>
</tr>
<tr>
<td>search</td>
<td>需要被替换的起始字符串</td>
</tr>
<tr>
<td>replace</td>
<td>第三个参数是新的的字符串</td>
</tr>
<tr>
<td>distExt</td>
<td>扩展名(非必填)</td>
</tr>
</tbody>
</table>
<p>此时编辑 <a href="https://github.com/nimojs/gulp-demo/blob/master/src/js/log.js" target="_blank" rel="external">src/js/log.js</a> 文件并保存，命令行会出现消息，表示检测到 <code>src/js/log.js</code> 文件修改后只重新编译 <code>log.js</code>。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">21</span><span class="symbol">:</span><span class="number">47</span><span class="symbol">:</span><span class="number">25</span>] changed src/js/log.js</div><div class="line">[<span class="number">21</span><span class="symbol">:</span><span class="number">47</span><span class="symbol">:</span><span class="number">25</span>] Dist dist/js/log.js</div></pre></td></tr></table></figure>
<p>你可以访问 <a href="https://github.com/nimojs/gulp-watch-path" target="_blank" rel="external">gulp-watch-path</a> 了解更多。</p>
<h3 id="stream-combiner2"><a href="#stream-combiner2" class="headerlink" title="stream-combiner2"></a>stream-combiner2</h3><p>编辑 <code>log.js</code> 文件时，如果文件中有 js 语法错误时，gulp 会终止运行并报错。</p>
<p>当 log.js 缺少 <code>)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log(<span class="string">'gulp-book'</span></div></pre></td></tr></table></figure></p>
<p>并保存文件时出现如下错误，但是错误信息不全面。而且还会让 gulp 停止运行。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">events.<span class="symbol">js:</span><span class="number">85</span></div><div class="line">      throw er; <span class="regexp">//</span> Unhandled <span class="string">'error'</span> event</div><div class="line">            ^</div><div class="line">Error</div><div class="line">    at new JS_Parse_Error (<span class="regexp">/Users/nimojs</span><span class="regexp">/Documents/code</span><span class="regexp">/gulp-book/demo</span><span class="regexp">/chapter7/node</span>_modules/gulp-uglify/node_modules/uglify-js/<span class="class"><span class="keyword">lib</span>/<span class="title">parse</span>.<span class="title">js</span>:189:18)</span></div><div class="line">...</div><div class="line">...</div><div class="line">js_error (<span class="regexp">/Users/nimojs</span><span class="regexp">/Documents/code</span><span class="regexp">/gulp-book/demo</span><span class="regexp">/chapter7/node</span>_modules/gulp-</div><div class="line">-book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/<span class="class"><span class="keyword">lib</span>/<span class="title">parse</span>.<span class="title">js</span>:1165:20)</span></div><div class="line">    at maybe_unary (<span class="regexp">/Users/nimojs</span><span class="regexp">/Documents/code</span><span class="regexp">/gulp-book/demo</span><span class="regexp">/chapter7/node</span>_modules/gulp-uglify/node_modules/uglify-js/<span class="class"><span class="keyword">lib</span>/<span class="title">parse</span>.<span class="title">js</span>:1328:19)</span></div></pre></td></tr></table></figure>
<p>应对这种情况，我们可以使用 <a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/combining-streams-to-handle-errors.md" target="_blank" rel="external">Combining streams to handle errors</a> 文档中推荐的 <a href="https://github.com/substack/stream-combiner2" target="_blank" rel="external">stream-combiner2</a>  捕获错误信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> handleError = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> colors = gutil.colors;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'\n'</span>)</div><div class="line">    gutil.log(colors.red(<span class="string">'Error!'</span>))</div><div class="line">    gutil.log(<span class="string">'fileName: '</span> + colors.red(err.fileName))</div><div class="line">    gutil.log(<span class="string">'lineNumber: '</span> + colors.red(err.lineNumber))</div><div class="line">    gutil.log(<span class="string">'message: '</span> + err.message)</div><div class="line">    gutil.log(<span class="string">'plugin: '</span> + colors.yellow(err.plugin))</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> combiner = <span class="built_in">require</span>(<span class="string">'stream-combiner2'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'watchjs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/js/**/*.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> paths = watchPath(event, <span class="string">'src/'</span>, <span class="string">'dist/'</span>)</div><div class="line">        <span class="comment">/*</span></div><div class="line">        paths</div><div class="line">            &#123; srcPath: 'src/js/log.js',</div><div class="line">              srcDir: 'src/js/',</div><div class="line">              distPath: 'dist/js/log.js',</div><div class="line">              distDir: 'dist/js/',</div><div class="line">              srcFilename: 'log.js',</div><div class="line">              distFilename: 'log.js' &#125;</div><div class="line">        */</div><div class="line">        gutil.log(gutil.colors.green(event.type) + <span class="string">' '</span> + paths.srcPath)</div><div class="line">        gutil.log(<span class="string">'Dist '</span> + paths.distPath)</div><div class="line"></div><div class="line">        <span class="keyword">var</span> combined = combiner.obj([</div><div class="line">            gulp.src(paths.srcPath),</div><div class="line">            uglify(),</div><div class="line">            gulp.dest(paths.distDir)</div><div class="line">        ])</div><div class="line"></div><div class="line">        combined.on(<span class="string">'error'</span>, handleError)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter7/watchjs-1.js" target="_blank" rel="external">watchjs-1 完整代码</a></p>
<p>此时当编译错误的语法时，命令行会出现错误提示。而且不会让 gulp 停止运行。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">changed:</span>src<span class="regexp">/js/</span>log.js</div><div class="line"><span class="string">dist:</span>dist<span class="regexp">/js/</span>log.js</div><div class="line">--------------</div><div class="line">Error!</div><div class="line"><span class="string">fileName:</span> <span class="regexp">/Users/</span>nimojs<span class="regexp">/Documents/</span>code<span class="regexp">/gulp-book/</span>demo<span class="regexp">/chapter7/</span>src<span class="regexp">/js/</span>log.js</div><div class="line"><span class="string">lineNumber:</span> <span class="number">7</span></div><div class="line"><span class="string">message:</span> <span class="regexp">/Users/</span>nimojs<span class="regexp">/Documents/</span>code<span class="regexp">/gulp-book/</span>demo<span class="regexp">/chapter7/</span>src<span class="regexp">/js/</span>log.<span class="string">js:</span> Unexpected token eof «undefined», expected punc «,»</div><div class="line"><span class="string">plugin:</span> gulp-uglify</div></pre></td></tr></table></figure>
<h3 id="gulp-sourcemaps"><a href="#gulp-sourcemaps" class="headerlink" title="gulp-sourcemaps"></a>gulp-sourcemaps</h3><p>JS 压缩前和压缩后比较<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 压缩前</span></div><div class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'--------'</span>);</div><div class="line">    <span class="built_in">console</span>.log(msg)</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'--------'</span>);</div><div class="line">&#125;</div><div class="line">log(&#123;a:<span class="number">1</span>&#125;)</div><div class="line">log(<span class="string">'gulp-book'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 压缩后</span></div><div class="line"><span class="keyword">var</span> log=<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"--------"</span>),<span class="built_in">console</span>.log(o),<span class="built_in">console</span>.log(<span class="string">"--------"</span>)&#125;;log(&#123;a:<span class="number">1</span>&#125;),log(<span class="string">"gulp-book"</span>);</div></pre></td></tr></table></figure></p>
<p>压缩后的代码不存在换行符和空白符，导致出错后很难调试，好在我们可以使用 <a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="external">sourcemap</a> 帮助调试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sourcemaps = <span class="built_in">require</span>(<span class="string">'gulp-sourcemaps'</span>)</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">var</span> combined = combiner.obj([</div><div class="line">    gulp.src(paths.srcPath),</div><div class="line">    sourcemaps.init(),</div><div class="line">    uglify(),</div><div class="line">    sourcemaps.write(<span class="string">'./'</span>),</div><div class="line">    gulp.dest(paths.distDir)</div><div class="line">])</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter7/watchjs-1.js" target="_blank" rel="external">watchjs-2 完整代码</a></p>
<p>此时 <code>dist/js/</code> 中也会生成对应的 <code>.map</code> 文件，以便使用 Chrome 控制台调试代码 <a href="https://github.com/nimojs/gulp-demo/blob/master/src/js/" target="_blank" rel="external">在线文件示例：src/js/</a></p>
<hr>
<p>至此，我们完成了检测文件修改后压缩 JS 的 gulp 任务配置。</p>
<p>有时我们也需要一次编译所有 js 文件。可以配置 <code>uglifyjs</code> 任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'uglifyjs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> combined = combiner.obj([</div><div class="line">        gulp.src(<span class="string">'src/js/**/*.js'</span>),</div><div class="line">        sourcemaps.init(),</div><div class="line">        uglify(),</div><div class="line">        sourcemaps.write(<span class="string">'./'</span>),</div><div class="line">        gulp.dest(<span class="string">'dist/js/'</span>)</div><div class="line">    ])</div><div class="line">    combined.on(<span class="string">'error'</span>, handleError)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在命令行输入 <code>gulp uglifyjs</code> 以压缩 <code>src/js/</code> 下的所有 js 文件。</p>
<h2 id="配置-CSS-任务"><a href="#配置-CSS-任务" class="headerlink" title="配置 CSS 任务"></a>配置 CSS 任务</h2><p>有时我们不想使用 LESS 或 SASS而是直接编写 CSS，但我们需要压缩 CSS 以提高页面加载速度。</p>
<h3 id="gulp-minify-css"><a href="#gulp-minify-css" class="headerlink" title="gulp-minify-css"></a>gulp-minify-css</h3><p>按照本章中压缩 JS 的方式，先编写 <code>watchcss</code> 任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'watchcss'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/css/**/*.css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> paths = watchPath(event, <span class="string">'src/'</span>, <span class="string">'dist/'</span>)</div><div class="line"></div><div class="line">		gutil.log(gutil.colors.green(event.type) + <span class="string">' '</span> + paths.srcPath)</div><div class="line">        gutil.log(<span class="string">'Dist '</span> + paths.distPath)</div><div class="line"></div><div class="line">        gulp.src(paths.srcPath)</div><div class="line">            .pipe(sourcemaps.init())</div><div class="line">            .pipe(minifycss())</div><div class="line">            .pipe(sourcemaps.write(<span class="string">'./'</span>))</div><div class="line">            .pipe(gulp.dest(paths.distDir))</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'watchjs'</span>,<span class="string">'watchcss'</span>])</div></pre></td></tr></table></figure>
<h3 id="gulp-autoprefixer"><a href="#gulp-autoprefixer" class="headerlink" title="gulp-autoprefixer"></a>gulp-autoprefixer</h3><p>autoprefixer 解析 CSS 文件并且添加浏览器前缀到CSS规则里。<br>通过示例帮助理解</p>
<p>autoprefixer 处理前：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.demo</span> &#123;</div><div class="line">    <span class="attribute">display</span>:flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>autoprefixer 处理后：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.demo</span> &#123;</div><div class="line">    <span class="attribute">display</span>:-webkit-flex;</div><div class="line">    <span class="attribute">display</span>:-ms-flexbox;</div><div class="line">    <span class="attribute">display</span>:flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你只需要关心编写标准语法的 css，autoprefixer 会自动补全。</p>
<p>在 watchcss 任务中加入 autoprefixer:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'watchcss'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/css/**/*.css'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> paths = watchPath(event, <span class="string">'src/'</span>, <span class="string">'dist/'</span>)</div><div class="line"></div><div class="line">		gutil.log(gutil.colors.green(event.type) + <span class="string">' '</span> + paths.srcPath)</div><div class="line">        gutil.log(<span class="string">'Dist '</span> + paths.distPath)</div><div class="line"></div><div class="line">        gulp.src(paths.srcPath)</div><div class="line">            .pipe(sourcemaps.init())</div><div class="line">            .pipe(autoprefixer(&#123;</div><div class="line">              browsers: <span class="string">'last 2 versions'</span></div><div class="line">            &#125;))</div><div class="line">            .pipe(minifycss())</div><div class="line">            .pipe(sourcemaps.write(<span class="string">'./'</span>))</div><div class="line">            .pipe(gulp.dest(paths.distDir))</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>更多 autoprefixer 参数请查看 <a href="https://github.com/sindresorhus/gulp-autoprefixer" target="_blank" rel="external">gulp-autoprefixer</a></p>
<p>有时我们也需要一次编译所有 css 文件。可以配置 <code>minifyss</code> 任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'minifycss'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.src(<span class="string">'src/css/**/*.css'</span>)</div><div class="line">        .pipe(sourcemaps.init())</div><div class="line">        .pipe(autoprefixer(&#123;</div><div class="line">          browsers: <span class="string">'last 2 versions'</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(minifycss())</div><div class="line">        .pipe(sourcemaps.write(<span class="string">'./'</span>))</div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/css/'</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在命令行输入 <code>gulp minifyss</code> 以压缩 <code>src/css/</code> 下的所有 .css 文件并复制到 <code>dist/css</code> 目录下</p>
<h2 id="配置-Less-任务"><a href="#配置-Less-任务" class="headerlink" title="配置 Less 任务"></a>配置 Less 任务</h2><p>参考配置 JavaScript 任务的方式配置 less 任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'watchless'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/less/**/*.less'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> paths = watchPath(event, <span class="string">'src/less/'</span>, <span class="string">'dist/css/'</span>)</div><div class="line"></div><div class="line">		gutil.log(gutil.colors.green(event.type) + <span class="string">' '</span> + paths.srcPath)</div><div class="line">        gutil.log(<span class="string">'Dist '</span> + paths.distPath)</div><div class="line">        <span class="keyword">var</span> combined = combiner.obj([</div><div class="line">            gulp.src(paths.srcPath),</div><div class="line">            sourcemaps.init(),</div><div class="line">            autoprefixer(&#123;</div><div class="line">              browsers: <span class="string">'last 2 versions'</span></div><div class="line">            &#125;),</div><div class="line">            less(),</div><div class="line">            minifycss(),</div><div class="line">            sourcemaps.write(<span class="string">'./'</span>),</div><div class="line">            gulp.dest(paths.distDir)</div><div class="line">        ])</div><div class="line">        combined.on(<span class="string">'error'</span>, handleError)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'lesscss'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> combined = combiner.obj([</div><div class="line">            gulp.src(<span class="string">'src/less/**/*.less'</span>),</div><div class="line">            sourcemaps.init(),</div><div class="line">            autoprefixer(&#123;</div><div class="line">              browsers: <span class="string">'last 2 versions'</span></div><div class="line">            &#125;),</div><div class="line">            less(),</div><div class="line">            minifycss(),</div><div class="line">            sourcemaps.write(<span class="string">'./'</span>),</div><div class="line">            gulp.dest(<span class="string">'dist/css/'</span>)</div><div class="line">        ])</div><div class="line">    combined.on(<span class="string">'error'</span>, handleError)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'watchjs'</span>, <span class="string">'watchcss'</span>, <span class="string">'watchless'</span>])</div></pre></td></tr></table></figure>
<h2 id="配置-Sass-任务"><a href="#配置-Sass-任务" class="headerlink" title="配置 Sass 任务"></a>配置 Sass 任务</h2><p>参考配置 JavaScript 任务的方式配置 Sass 任务</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'watchsass'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/sass/**/*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> paths = watchPath(event, <span class="string">'src/sass/'</span>, <span class="string">'dist/css/'</span>)</div><div class="line"></div><div class="line">		gutil.log(gutil.colors.green(event.type) + <span class="string">' '</span> + paths.srcPath)</div><div class="line">        gutil.log(<span class="string">'Dist '</span> + paths.distPath)</div><div class="line">        sass(paths.srcPath)</div><div class="line">            .on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.error(<span class="string">'Error!'</span>, err.message);</div><div class="line">            &#125;)</div><div class="line">            .pipe(sourcemaps.init())</div><div class="line">            .pipe(minifycss())</div><div class="line">            .pipe(autoprefixer(&#123;</div><div class="line">              browsers: <span class="string">'last 2 versions'</span></div><div class="line">            &#125;))</div><div class="line">            .pipe(sourcemaps.write(<span class="string">'./'</span>))</div><div class="line">            .pipe(gulp.dest(paths.distDir))</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'sasscss'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        sass(<span class="string">'src/sass/'</span>)</div><div class="line">        .on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.error(<span class="string">'Error!'</span>, err.message);</div><div class="line">        &#125;)</div><div class="line">        .pipe(sourcemaps.init())</div><div class="line">        .pipe(minifycss())</div><div class="line">        .pipe(autoprefixer(&#123;</div><div class="line">          browsers: <span class="string">'last 2 versions'</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(sourcemaps.write(<span class="string">'./'</span>))</div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/css'</span>))</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'watchjs'</span>, <span class="string">'watchcss'</span>, <span class="string">'watchless'</span>, <span class="string">'watchsass'</span>, <span class="string">'watchsass'</span>])</div></pre></td></tr></table></figure>
<h2 id="配置-image-任务"><a href="#配置-image-任务" class="headerlink" title="配置 image 任务"></a>配置 image 任务</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'watchimage'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/images/**/*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> paths = watchPath(event,<span class="string">'src/'</span>,<span class="string">'dist/'</span>)</div><div class="line"></div><div class="line">		gutil.log(gutil.colors.green(event.type) + <span class="string">' '</span> + paths.srcPath)</div><div class="line">        gutil.log(<span class="string">'Dist '</span> + paths.distPath)</div><div class="line"></div><div class="line">        gulp.src(paths.srcPath)</div><div class="line">            .pipe(imagemin(&#123;</div><div class="line">                progressive: <span class="literal">true</span></div><div class="line">            &#125;))</div><div class="line">            .pipe(gulp.dest(paths.distDir))</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'image'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.src(<span class="string">'src/images/**/*'</span>)</div><div class="line">        .pipe(imagemin(&#123;</div><div class="line">            progressive: <span class="literal">true</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/images'</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="配置文件复制任务"><a href="#配置文件复制任务" class="headerlink" title="配置文件复制任务"></a>配置文件复制任务</h2><p>复制 <code>src/fonts/</code> 文件到 <code>dist/</code> 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'watchcopy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.watch(<span class="string">'src/fonts/**/*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> paths = watchPath(event)</div><div class="line"></div><div class="line">		gutil.log(gutil.colors.green(event.type) + <span class="string">' '</span> + paths.srcPath)</div><div class="line">        gutil.log(<span class="string">'Dist '</span> + paths.distPath)</div><div class="line"></div><div class="line">        gulp.src(paths.srcPath)</div><div class="line">            .pipe(gulp.dest(paths.distDir))</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'copy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.src(<span class="string">'src/fonts/**/*'</span>)</div><div class="line">        .pipe(gulp.dest(<span class="string">'dist/fonts/'</span>))</div><div class="line">&#125;)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'watchjs'</span>, <span class="string">'watchcss'</span>, <span class="string">'watchless'</span>, <span class="string">'watchsass'</span>, <span class="string">'watchimage'</span>, <span class="string">'watchcopy'</span>])</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><a href="https://github.com/nimojs/gulp-demo/tree/master/gulpfile.js" target="_blank" rel="external">完整代码</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker安装Gitlab]]></title>
      <url>http://hangweiping.github.io/2016/05/16/docker%E5%AE%89%E8%A3%85gitlab/</url>
      <content type="html"><![CDATA[<blockquote>
<p>此文为实践gitlab而成，通篇介绍了Docker下安装 Gitlab CE的过程及注意问题，顺便复习了一些docker和git的命令，由于原文比较简单，故没有翻译。</p>
</blockquote>
<a id="more"></a>
<h1 id="GitLab-Docker-images"><a href="#GitLab-Docker-images" class="headerlink" title="GitLab Docker images"></a>GitLab Docker images</h1><p>这是镜像<a href="https://registry.hub.docker.com/u/gitlab/gitlab-ce/" target="_blank" rel="external">GitLab CE docker image</a>,You can also deploy to Docker Cloud using the <a href="http://docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose" target="_blank" rel="external">docker-compose config</a>。</p>
<h2 id="Run-the-image"><a href="#Run-the-image" class="headerlink" title="Run the image:"></a>Run the image:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sudo docker run --detach \</div><div class="line">    --hostname gitlab.example.com \</div><div class="line">    --publish 443:443 --publish 80:80 --publish 22:22 \</div><div class="line">    --name gitlab \</div><div class="line">    --restart always \</div><div class="line">    --volume /srv/gitlab/config:/etc/gitlab \</div><div class="line">    --volume /srv/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</div><div class="line">    --volume /srv/gitlab/data:/var/opt/gitlab \</div><div class="line">    gitlab/gitlab-ce:latest</div></pre></td></tr></table></figure>
<p>This will download and start a GitLab CE container and publish ports needed to access SSH, HTTP and HTTPS. All GitLab data will be stored as subdirectories of /srv/gitlab/. The container will automatically restart after a system reboot.</p>
<p>You can now login to the web interface as explained in After starting a container.</p>
<h2 id="After-starting-a-container"><a href="#After-starting-a-container" class="headerlink" title="After starting a container"></a>After starting a container</h2><p>After starting a container you can visit <a href="http://localhost/" target="_blank" rel="external">http://localhost/</a> or <a href="http://192.168.59.103" target="_blank" rel="external">http://192.168.59.103</a> if you use boot2docker. It might take a while before the docker container starts to respond to queries.</p>
<p>Login to GitLab with the following credentials:  </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">username</span>: <span class="built_in">`root`</span>  </div><div class="line"><span class="attribute">password</span>: <span class="built_in">`5iveL!fe`</span></div></pre></td></tr></table></figure>
<p>Next time, you can just use docker start and stop to run the container.  </p>
<h2 id="Where-is-the-data-stored"><a href="#Where-is-the-data-stored" class="headerlink" title="Where is the data stored?"></a>Where is the data stored?</h2><p>The GitLab container uses host mounted volumes to store persistent data:</p>
<p>Local location    Container location    Usage  </p>
<table>
<thead>
<tr>
<th>/srv/gitlab/data</th>
<th>/var/opt/gitlab</th>
<th>For storing application data</th>
</tr>
</thead>
<tbody>
<tr>
<td>/srv/gitlab/logs</td>
<td>/var/log/gitlab</td>
<td>For storing logs</td>
</tr>
<tr>
<td>/srv/gitlab/config</td>
<td>/etc/gitlab</td>
<td>For storing the GitLab configuration files</td>
</tr>
</tbody>
</table>
<p>You can fine tune these directories to meet your requirements.  </p>
<h2 id="Configure-GitLab"><a href="#Configure-GitLab" class="headerlink" title="Configure GitLab"></a>Configure GitLab</h2><p>This container uses the official Omnibus GitLab package, so all configuration is done in the unique configuration file <code>/etc/gitlab/gitlab.rb</code>.</p>
<p>To access GitLab’s configuration file, you can start a shell session in the context of a running container. This will allow you to browse all directories and use your favorite text editor:</p>
<p><code>sudo docker exec -it gitlab /bin/bash</code></p>
<p>You can also just edit <code>/etc/gitlab/gitlab.rb</code>:</p>
<p><code>sudo docker exec -it gitlab vi /etc/gitlab/gitlab.rb</code></p>
<p>Once you open <code>/etc/gitlab/gitlab.rb</code> make sure to set the external_url to point to a valid URL.</p>
<p>To receive e-mails from GitLab you have to configure the SMTP settings because the GitLab docker image doesn’t have an SMTP server installed.</p>
<p>You may also be interested in Enabling HTTPS.</p>
<p>After you make all the changes you want, you will need to restart the container in order to reconfigure GitLab:</p>
<p><code>sudo docker restart gitlab</code></p>
<p>Note: GitLab will reconfigure itself whenever the container starts.</p>
<p>For more options about configuring GitLab please check the Omnibus GitLab documentation.</p>
<h2 id="Run-GitLab-CE-on-public-IP-address"><a href="#Run-GitLab-CE-on-public-IP-address" class="headerlink" title="Run GitLab CE on public IP address"></a>Run GitLab CE on public IP address</h2><p>You can make Docker to use your IP address and forward all traffic to the GitLab CE container by modifying the –publish flag.  </p>
<p>To expose GitLab CE on IP 1.1.1.1:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sudo docker run --detach \</div><div class="line">    --hostname gitlab.example.com \</div><div class="line">    --publish 1.1.1.1:443:443 \</div><div class="line">    --publish 1.1.1.1:80:80 \</div><div class="line">    --publish 1.1.1.1:22:22 \</div><div class="line">    --name gitlab \</div><div class="line">    --restart always \</div><div class="line">    --volume /srv/gitlab/config:/etc/gitlab \</div><div class="line">    --volume /srv/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</div><div class="line">    --volume /srv/gitlab/data:/var/opt/gitlab \</div><div class="line">    gitlab/gitlab-ce:latest</div></pre></td></tr></table></figure>
<p>You can then access your GitLab instance at 1.1.1.1.  </p>
<h2 id="Expose-GitLab-on-different-ports"><a href="#Expose-GitLab-on-different-ports" class="headerlink" title="Expose GitLab on different ports"></a>Expose GitLab on different ports</h2><p>If you want to use a different port than 80 (HTTP) or 443 (HTTPS), you need to add a separate –publish directive to the docker run command.</p>
<p>For example, to expose the web interface on port 8929 and the SSH service on port 2289, use the following docker run command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sudo docker run --detach \</div><div class="line">    --hostname gitlab.example.com \</div><div class="line">    --publish 8929:80 --publish 2289:22 \</div><div class="line">    --name gitlab \</div><div class="line">    --restart always \</div><div class="line">    --volume /srv/gitlab/config:/etc/gitlab \</div><div class="line">    --volume /srv/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</div><div class="line">    --volume /srv/gitlab/data:/var/opt/gitlab \</div><div class="line">    gitlab/gitlab-ce:latest</div></pre></td></tr></table></figure>
<p>You then need to appropriately configure gitlab.rb:</p>
<p>Set external_url:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># <span class="keyword">For</span> HTTP</div><div class="line">external_url <span class="string">"http://gitlab.example.com:8929"</span></div><div class="line"></div><div class="line"># <span class="keyword">For</span> HTTPS</div><div class="line">external_url <span class="string">"https://gitlab.example.com:8929"</span></div><div class="line"><span class="keyword">Set</span> gitlab_shell_ssh_port:</div><div class="line"></div><div class="line">gitlab_rails[<span class="string">'gitlab_shell_ssh_port'</span>] = 2289</div><div class="line">Diagnose <span class="comment">potential problems</span></div><div class="line"></div><div class="line">Read <span class="comment">container logs:</span></div><div class="line"></div><div class="line">sudo <span class="comment">docker logs gitlab</span></div><div class="line">Enter <span class="comment">running container:</span></div><div class="line"></div><div class="line">sudo <span class="comment">docker exec -it gitlab</span> /bin/<span class="comment">bash</span></div></pre></td></tr></table></figure>
<p>From within the container you can administer the GitLab container as you would normally administer an Omnibus installation</p>
<h2 id="Install-GitLab-using-docker-compose"><a href="#Install-GitLab-using-docker-compose" class="headerlink" title="Install GitLab using docker-compose"></a>Install GitLab using docker-compose</h2><p>With Docker compose you can easily configure, install, and upgrade your Docker-based GitLab installation.</p>
<p>Install Docker Compose<br>Create a docker-compose.yml file (or download an example):  </p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">web:</div><div class="line">  image: 'gitlab/gitlab-ce:latest'</div><div class="line">  restart: always</div><div class="line">  hostname: 'gitlab.example.com'</div><div class="line">  environment:</div><div class="line">    GITLAB_OMNIBUS_CONFIG: |</div><div class="line">      external_url 'https://gitlab.example.com'</div><div class="line">      # Add any other gitlab.rb configuration here, each on its own line</div><div class="line">  ports:</div><div class="line">    -<span class="ruby"> <span class="string">'80:80'</span></span></div><div class="line">    -<span class="ruby"> <span class="string">'443:443'</span></span></div><div class="line">    -<span class="ruby"> <span class="string">'22:22'</span></span></div><div class="line">  volumes:</div><div class="line">    -<span class="ruby"> <span class="string">'/srv/gitlab/config:/etc/gitlab'</span></span></div><div class="line">    -<span class="ruby"> <span class="string">'/srv/gitlab/logs:/var/log/gitlab'</span></span></div><div class="line">    -<span class="ruby"> <span class="string">'/srv/gitlab/data:/var/opt/gitlab'</span></span></div></pre></td></tr></table></figure>
<p>Make sure you are in the same directory as docker-compose.yml and run docker-compose up -d to start GitLab</p>
<p>Read “Pre-configure Docker container” to see how the GITLAB_OMNIBUS_CONFIG variable works.</p>
<p>Below is another docker-compose.yml example with GitLab running on a custom HTTP and SSH port. Notice how the GITLAB_OMNIBUS_CONFIG variables match the ports section:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">we<span class="variable">b:</span></div><div class="line">  image: <span class="string">'gitlab/gitlab-ce:latest'</span></div><div class="line">  restar<span class="variable">t:</span> always</div><div class="line">  <span class="built_in">hostname</span>: <span class="string">'gitlab.example.com'</span></div><div class="line">  environmen<span class="variable">t:</span></div><div class="line">    GITLAB_OMNIBUS_CONFIG: |</div><div class="line">      external_url <span class="string">'http://gitlab.example.com:9090'</span></div><div class="line">      gitlab_rails[<span class="string">'gitlab_shell_ssh_port'</span>] = <span class="number">2224</span></div><div class="line">  port<span class="variable">s:</span></div><div class="line">    - <span class="string">'9090:9090'</span></div><div class="line">    - <span class="string">'2224:22'</span></div><div class="line">  volume<span class="variable">s:</span></div><div class="line">    - <span class="string">'/srv/gitlab/config:/etc/gitlab'</span></div><div class="line">    - <span class="string">'/srv/gitlab/logs:/var/log/gitlab'</span></div><div class="line">    - <span class="string">'/srv/gitlab/data:/var/opt/gitlab'</span></div></pre></td></tr></table></figure>
<h2 id="Update-GitLab-using-Docker-compose"><a href="#Update-GitLab-using-Docker-compose" class="headerlink" title="Update GitLab using Docker compose"></a>Update GitLab using Docker compose</h2><p>Provided you installed GitLab using docker-compose, all you have to do is run <code>docker-compose pull</code> and <code>docker-compose up -d</code> to download a new release and upgrade your GitLab instance.</p>
<h1 id="docker命令回顾"><a href="#docker命令回顾" class="headerlink" title="docker命令回顾"></a>docker命令回顾</h1><h2 id="查看docker信息（version、info）"><a href="#查看docker信息（version、info）" class="headerlink" title="查看docker信息（version、info）"></a>查看docker信息（version、info）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看docker版本  </span></div><div class="line">$ docker version  </div><div class="line"><span class="comment"># 显示docker系统的信息  </span></div><div class="line">$ docker info</div></pre></td></tr></table></figure>
<h2 id="对image的操作（search、pull、images、rmi、history）"><a href="#对image的操作（search、pull、images、rmi、history）" class="headerlink" title="对image的操作（search、pull、images、rmi、history）"></a>对image的操作（search、pull、images、rmi、history）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 检索image  </span></div><div class="line">$ docker search image_name  </div><div class="line"></div><div class="line"><span class="comment"># 下载image  </span></div><div class="line">$ docker pull image_name  </div><div class="line"></div><div class="line"><span class="comment"># 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs</span></div><div class="line">$ docker images   </div><div class="line"></div><div class="line"><span class="comment"># 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents</span></div><div class="line">$ docker rmi image_name  </div><div class="line"></div><div class="line"><span class="comment"># 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs</span></div><div class="line">$ docker <span class="built_in">history</span> image_name</div></pre></td></tr></table></figure>
<h2 id="启动容器（run）"><a href="#启动容器（run）" class="headerlink" title="启动容器（run）"></a>启动容器（run）</h2><p>docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在容器中运行"echo"命令，输出"hello word"</span></div><div class="line">$ docker run image_name <span class="built_in">echo</span> <span class="string">"hello word"</span></div><div class="line"></div><div class="line"><span class="comment"># 交互式进入容器中</span></div><div class="line">$ docker run -i -t image_name /bin/bash</div><div class="line"></div><div class="line"><span class="comment"># 在容器中安装新的程序</span></div><div class="line">$ docker run image_name apt-get install -y app_name</div></pre></td></tr></table></figure>
<p>Note：  在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。</p>
<h2 id="查看容器（ps）"><a href="#查看容器（ps）" class="headerlink" title="查看容器（ps）"></a>查看容器（ps）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 列出当前所有正在运行的container</span></div><div class="line">$ docker ps  </div><div class="line"><span class="comment"># 列出所有的container  </span></div><div class="line">$ docker ps <span class="_">-a</span>  </div><div class="line"><span class="comment"># 列出最近一次启动的container  </span></div><div class="line">$ docker ps <span class="_">-l</span></div></pre></td></tr></table></figure>
<h2 id="保存对容器的修改（commit）"><a href="#保存对容器的修改（commit）" class="headerlink" title="保存对容器的修改（commit）"></a>保存对容器的修改（commit）</h2><p>当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 保存对容器的修改; -a, --author="" Author; -m, --message="" Commit message  </span></div><div class="line">$ docker commit ID new_image_name</div></pre></td></tr></table></figure>
<p>Note：  image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。</p>
<h2 id="对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）"><a href="#对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）" class="headerlink" title="对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）"></a>对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 删除所有容器  </span></div><div class="line">$ docker rm `docker ps <span class="_">-a</span> -q`  </div><div class="line"></div><div class="line"><span class="comment"># 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container</span></div><div class="line">$ docker rm Name/ID  </div><div class="line"></div><div class="line"><span class="comment"># 停止、启动、杀死一个容器</span></div><div class="line">$ docker stop Name/ID</div><div class="line">$ docker start Name/ID</div><div class="line">$ docker <span class="built_in">kill</span> Name/ID</div><div class="line"></div><div class="line"><span class="comment"># 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps</span></div><div class="line">$ docker logs Name/ID</div><div class="line"></div><div class="line"><span class="comment"># 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的</span></div><div class="line">$ docker diff Name/ID</div><div class="line"></div><div class="line"><span class="comment"># 显示一个运行的容器里面的进程信息</span></div><div class="line">$ docker top Name/ID</div><div class="line"></div><div class="line"><span class="comment"># 从容器里面拷贝文件/目录到本地一个路径</span></div><div class="line">$ docker cp Name:/container_path to_path</div><div class="line">$ docker cp ID:/container_path to_path</div><div class="line"></div><div class="line"><span class="comment"># 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10</span></div><div class="line">$ docker restart Name/ID</div><div class="line"></div><div class="line"><span class="comment"># 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process</span></div><div class="line">$ docker attach ID</div></pre></td></tr></table></figure>
<p>Note： attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。</p>
<h2 id="保存和加载镜像（save、load）"><a href="#保存和加载镜像（save、load）" class="headerlink" title="保存和加载镜像（save、load）"></a>保存和加载镜像（save、load）</h2><p>当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 保存镜像到一个tar包; -o, --output="" Write to an file</span></div><div class="line">$ docker save image_name -o file_path</div><div class="line"><span class="comment"># 加载一个tar包格式的镜像; -i, --input="" Read from a tar archive file</span></div><div class="line">$ docker load -i file_path</div><div class="line"></div><div class="line"><span class="comment"># 机器a</span></div><div class="line">$ docker save image_name &gt; /home/save.tar</div><div class="line"><span class="comment"># 使用scp将save.tar拷到机器b上，然后：</span></div><div class="line">$ docker load &lt; /home/save.tar</div></pre></td></tr></table></figure>
<h1 id="git-初学解决错误"><a href="#git-初学解决错误" class="headerlink" title="git 初学解决错误"></a>git 初学解决错误</h1><p>error: src refspec master does not match any.<br>引起该错误的原因是，目录中没有文件，空目录是不能提交上去的  </p>
<p>error: insufficient permission for adding an object to repository database ./objects<br>服务端没有可写目录的权限  </p>
<p>错误提示：fatal: remote origin already exists.<br>解决办法：$ git remote rm origin  </p>
<p>错误提示：error: failed to push som refs to ……..<br>解决办法：$ git pull origin master //先pull 下来 再push 上去  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis入门教程]]></title>
      <url>http://hangweiping.github.io/2016/05/09/redis%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。<br>redis的官网地址，非常好记，是redis.io。（特意查了一下，域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地）<br>目前，Vmware在资助着redis项目的开发和维护。  </p>
</blockquote>
<a id="more"></a>
<h2 id="学会启动redis"><a href="#学会启动redis" class="headerlink" title="学会启动redis"></a>学会启动redis</h2><p>启动redis非常简单，直接<code>redis-server</code>就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：<br><code>redis-server ../redis.conf</code><br>默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。  </p>
<h2 id="使用redis客户端"><a href="#使用redis客户端" class="headerlink" title="使用redis客户端"></a>使用redis客户端</h2><p>我们直接看一个例子：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//这样来启动redis客户端了  </div><div class="line">$ redis-cli</div><div class="line">//用<span class="keyword">set</span>指令来设置<span class="keyword">key</span>、<span class="keyword">value</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">set</span> <span class="keyword">name</span> <span class="string">"roc"</span></div><div class="line">OK</div><div class="line">//来获取<span class="keyword">name</span>的值</div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">get</span> <span class="keyword">name</span></div><div class="line"><span class="string">"roc"</span></div><div class="line">//通过客户端来关闭redis服务端</div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">shutdown</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</div></pre></td></tr></table></figure>
<h2 id="redis数据结构-–-简介"><a href="#redis数据结构-–-简介" class="headerlink" title="redis数据结构 – 简介"></a>redis数据结构 – 简介</h2><p>redis是一种高级的key:value存储系统，其中value支持五种数据类型：  </p>
<ul>
<li>字符串（strings）  </li>
<li>字符串列表（lists）  </li>
<li>字符串集合（sets）  </li>
<li>有序字符串集合（sorted sets）  </li>
<li>哈希（hashes）  </li>
</ul>
<p>而关于key，有几个点要提醒大家：  </p>
<p>key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>key也不要太短，太短的话，key的可读性会降低；<br>在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。    </p>
<h2 id="redis数据结构-–-strings"><a href="#redis数据结构-–-strings" class="headerlink" title="redis数据结构 – strings"></a>redis数据结构 – strings</h2><p>有人说，如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。这说明strings类型是一个很基础的数据类型，也是任何存储系统都必备的数据类型。  </p>
<p>我们来看一个最简单的例子：    </p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> mystr <span class="comment">"hello world!"</span> //设置字符串类型</div><div class="line">get <span class="comment">mystr</span> //读取字符串类型</div></pre></td></tr></table></figure>
<p>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。<br>另外，我们还可以通过字符串类型进行数值操作：  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">set</span> <span class="selector-tag">mynum</span> "2"</div><div class="line"><span class="selector-tag">OK</span></div><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">get</span> <span class="selector-tag">mynum</span></div><div class="line">"2"</div><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">incr</span> <span class="selector-tag">mynum</span></div><div class="line">(<span class="selector-tag">integer</span>) 3</div><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">get</span> <span class="selector-tag">mynum</span></div><div class="line">"3"</div></pre></td></tr></table></figure>
<p>看，在遇到数值操作时，redis会将字符串类型转换成数值。  </p>
<p>由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果，假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。  </p>
<h2 id="redis数据结构-–-lists"><a href="#redis数据结构-–-lists" class="headerlink" title="redis数据结构 – lists"></a>redis数据结构 – lists</h2><p>redis的另一个重要的数据结构叫做lists，翻译成中文叫做“列表”。  </p>
<p>首先要明确一点，redis中的lists在底层实现上并不是数组，而是链表，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。  </p>
<p>虽然lists有这样的优势，但同样有其弊端，那就是，链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多。  </p>
<p>lists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。我们来看几个例子：  </p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//新建一个<span class="keyword">list</span>叫做mylist，并在列表头部插入元素<span class="string">"1"</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush mylist <span class="string">"1"</span></div><div class="line">//返回当前mylist中的元素个数</div><div class="line">(integer) <span class="number">1</span></div><div class="line">//在mylist右侧插入元素<span class="string">"2"</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpush mylist <span class="string">"2"</span></div><div class="line">(integer) <span class="number">2</span></div><div class="line">//在mylist左侧插入元素<span class="string">"0"</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush mylist <span class="string">"0"</span></div><div class="line">(integer) <span class="number">3</span></div><div class="line">//列出mylist中从编号<span class="number">0</span>到编号<span class="number">1</span>的元素</div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">lrange</span> mylist <span class="number">0</span> <span class="number">1</span></div><div class="line"><span class="number">1</span>) <span class="string">"0"</span></div><div class="line"><span class="number">2</span>) <span class="string">"1"</span></div><div class="line">//列出mylist中从编号<span class="number">0</span>到倒数第一个元素</div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">lrange</span> mylist <span class="number">0</span> <span class="number">-1</span></div><div class="line"><span class="number">1</span>) <span class="string">"0"</span></div><div class="line"><span class="number">2</span>) <span class="string">"1"</span></div><div class="line"><span class="number">3</span>) <span class="string">"2"</span></div></pre></td></tr></table></figure>
<p>lists的应用相当广泛，随便举几个例子：  </p>
<p>我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。<br>利用LRANGE还可以很方便的实现分页的功能。<br>在博客系统中，每片博文的评论也可以存入一个单独的list中。  </p>
<h2 id="redis数据结构-–-集合"><a href="#redis数据结构-–-集合" class="headerlink" title="redis数据结构 – 集合"></a>redis数据结构 – 集合</h2><p>redis的集合，是一种无序的集合，集合中的元素没有先后顺序。<br>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。我们来看例子：  </p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//向集合myset中加入一个新元素<span class="string">"one"</span></div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; sadd myset <span class="string">"one"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; sadd myset <span class="string">"two"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line">//列出集合myset中的所有元素</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; smembers myset</div><div class="line"><span class="number">1</span>) <span class="string">"one"</span></div><div class="line"><span class="number">2</span>) <span class="string">"two"</span></div><div class="line">//判断元素<span class="number">1</span>是否在集合myset中，返回<span class="number">1</span>表示存在</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; sismember myset <span class="string">"one"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line">//判断元素<span class="number">3</span>是否在集合myset中，返回<span class="number">0</span>表示不存在</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; sismember myset <span class="string">"three"</span></div><div class="line">(integer) <span class="number">0</span></div><div class="line">//新建一个新的集合yourset</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; sadd yourset <span class="string">"1"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; sadd yourset <span class="string">"2"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; smembers yourset</div><div class="line"><span class="number">1</span>) <span class="string">"1"</span></div><div class="line"><span class="number">2</span>) <span class="string">"2"</span></div><div class="line">//对两个集合求并集</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; sunion myset yourset</div><div class="line"><span class="number">1</span>) <span class="string">"1"</span></div><div class="line"><span class="number">2</span>) <span class="string">"one"</span></div><div class="line"><span class="number">3</span>) <span class="string">"2"</span></div><div class="line"><span class="number">4</span>) <span class="string">"two"</span></div></pre></td></tr></table></figure>
<p>对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。  </p>
<h2 id="redis数据结构-–-有序集合"><a href="#redis数据结构-–-有序集合" class="headerlink" title="redis数据结构 – 有序集合"></a>redis数据结构 – 有序集合</h2><p>redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。  </p>
<p>很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等  </p>
<p>老规矩，我们来看几个生动的例子：  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1</span></div><div class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> baidu<span class="selector-class">.com</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="comment">//向myzset中新增一个元素360.com，赋予它的序号是3</span></div><div class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">3</span> <span class="number">360</span><span class="selector-class">.com</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="comment">//向myzset中新增一个元素google.com，赋予它的序号是2</span></div><div class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">2</span> google<span class="selector-class">.com</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="comment">//列出myzset的所有元素，同时列出其序号，可以看出myzset已经是有序的了。</span></div><div class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> -<span class="number">1</span> with scores</div><div class="line"><span class="number">1</span>) <span class="string">"baidu.com"</span></div><div class="line"><span class="number">2</span>) <span class="string">"1"</span></div><div class="line"><span class="number">3</span>) <span class="string">"google.com"</span></div><div class="line"><span class="number">4</span>) <span class="string">"2"</span></div><div class="line"><span class="number">5</span>) <span class="string">"360.com"</span></div><div class="line"><span class="number">6</span>) <span class="string">"3"</span></div><div class="line"><span class="comment">//只列出myzset的元素</span></div><div class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> -<span class="number">1</span></div><div class="line"><span class="number">1</span>) <span class="string">"baidu.com"</span></div><div class="line"><span class="number">2</span>) <span class="string">"google.com"</span></div><div class="line"><span class="number">3</span>) <span class="string">"360.com"</span></div></pre></td></tr></table></figure>
<h2 id="redis数据结构-–-哈希"><a href="#redis数据结构-–-哈希" class="headerlink" title="redis数据结构 – 哈希"></a>redis数据结构 – 哈希</h2><p>最后要给大家介绍的是hashes，即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。<br>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。<br>我们来看一个例子：   </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立哈希，并赋值</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HMSET <span class="string">user:</span><span class="number">001</span> username antirez password P1pp0 age <span class="number">34</span></div><div class="line">OK</div><div class="line"><span class="comment">//列出哈希的内容</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL <span class="string">user:</span><span class="number">001</span></div><div class="line"><span class="number">1</span>) <span class="string">"username"</span></div><div class="line"><span class="number">2</span>) <span class="string">"antirez"</span></div><div class="line"><span class="number">3</span>) <span class="string">"password"</span></div><div class="line"><span class="number">4</span>) <span class="string">"P1pp0"</span></div><div class="line"><span class="number">5</span>) <span class="string">"age"</span></div><div class="line"><span class="number">6</span>) <span class="string">"34"</span></div><div class="line"><span class="comment">//更改哈希中的某一个值</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HSET <span class="string">user:</span><span class="number">001</span> password <span class="number">12345</span></div><div class="line">(integer) <span class="number">0</span></div><div class="line"><span class="comment">//再次列出哈希的内容</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; HGETALL <span class="string">user:</span><span class="number">001</span></div><div class="line"><span class="number">1</span>) <span class="string">"username"</span></div><div class="line"><span class="number">2</span>) <span class="string">"antirez"</span></div><div class="line"><span class="number">3</span>) <span class="string">"password"</span></div><div class="line"><span class="number">4</span>) <span class="string">"12345"</span></div><div class="line"><span class="number">5</span>) <span class="string">"age"</span></div><div class="line"><span class="number">6</span>) <span class="string">"34"</span></div></pre></td></tr></table></figure>
<p>有关hashes的操作，同样很丰富，需要时，大家可以从这里查询。  </p>
<h2 id="聊聊redis持久化-–-两种方式"><a href="#聊聊redis持久化-–-两种方式" class="headerlink" title="聊聊redis持久化 – 两种方式"></a>聊聊redis持久化 – 两种方式</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。<br>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；<br>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。  </p>
<p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。<br>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p>
<h2 id="聊聊redis持久化-–-RDB"><a href="#聊聊redis持久化-–-RDB" class="headerlink" title="聊聊redis持久化 – RDB"></a>聊聊redis持久化 – RDB</h2><p>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。  </p>
<p>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。  </p>
<p>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</p>
<p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p>
<p>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</p>
<h2 id="聊聊redis持久化-–-AOF"><a href="#聊聊redis持久化-–-AOF" class="headerlink" title="聊聊redis持久化 – AOF"></a>聊聊redis持久化 – AOF</h2><p>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</p>
<p>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</p>
<p>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</p>
<p>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</p>
<p>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</p>
<p>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</p>
<p>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。</p>
<p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p>
<p>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p>
<p>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</p>
<p>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p>
<p>备份被写坏的AOF文件<br>运行redis-check-aof –fix进行修复<br>用diff -u来看下两个文件的差异，确认问题点<br>重启redis，加载修复后的AOF文件</p>
<h2 id="聊聊redis持久化-–-AOF重写"><a href="#聊聊redis持久化-–-AOF重写" class="headerlink" title="聊聊redis持久化 – AOF重写"></a>聊聊redis持久化 – AOF重写</h2><p>AOF重写的内部运行原理，我们有必要了解一下。</p>
<p>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p>
<p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p>
<p>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p>
<p>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。  </p>
<h2 id="聊聊redis持久化-–-如何选择RDB和AOF"><a href="#聊聊redis持久化-–-如何选择RDB和AOF" class="headerlink" title="聊聊redis持久化 – 如何选择RDB和AOF"></a>聊聊redis持久化 – 如何选择RDB和AOF</h2><p>对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。  </p>
<h2 id="聊聊主从-–-用法"><a href="#聊聊主从-–-用法" class="headerlink" title="聊聊主从 – 用法"></a>聊聊主从 – 用法</h2><p>像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。</p>
<p>主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</p>
<p>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</p>
<p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p>
<p>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</p>
<h2 id="聊聊主从-–-同步原理"><a href="#聊聊主从-–-同步原理" class="headerlink" title="聊聊主从 – 同步原理"></a>聊聊主从 – 同步原理</h2><p>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</p>
<p>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</p>
<p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</p>
<p>主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</p>
<p>增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</p>
<h2 id="聊聊redis的事务处理"><a href="#聊聊redis的事务处理" class="headerlink" title="聊聊redis的事务处理"></a>聊聊redis的事务处理</h2><p>众所周知，事务是指“一个完整的动作，要么全部执行，要么什么也没有做”。</p>
<p>在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。</p>
<ul>
<li>MULTI用来组装一个事务；  </li>
<li>EXEC用来执行一个事务；  </li>
<li>DISCARD用来取消一个事务；  </li>
<li>WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。<br>纸上得来终觉浅，我们来看一个MULTI和EXEC的例子：  </li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">redis&gt; MULTI <span class="comment">//标记事务开始</span></div><div class="line">OK</div><div class="line">redis&gt; INCR user_id <span class="comment">//多条命令按顺序入队</span></div><div class="line">QUEUED</div><div class="line">redis&gt; INCR user_id</div><div class="line">QUEUED</div><div class="line">redis&gt; INCR user_id</div><div class="line">QUEUED</div><div class="line">redis&gt; PING</div><div class="line">QUEUED</div><div class="line">redis&gt; EXEC <span class="comment">//执行</span></div><div class="line"><span class="number">1</span>) (<span class="type">integer</span>) <span class="number">1</span></div><div class="line"><span class="number">2</span>) (<span class="type">integer</span>) <span class="number">2</span></div><div class="line"><span class="number">3</span>) (<span class="type">integer</span>) <span class="number">3</span></div><div class="line"><span class="number">4</span>) PONG</div></pre></td></tr></table></figure>
<p>在上面的例子中，我们看到了QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行。  </p>
<p>对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</p>
<p>有关事务，大家经常会遇到的是两类错误：  </p>
<p>调用EXEC之前的错误<br>调用EXEC之后的错误<br>“调用EXEC之前的错误”，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。我们来看一个这样的例子：    </p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; multi</div><div class="line">OK</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; haha //一个明显错误的指令</div><div class="line">(error) ERR unknown command <span class="string">'haha'</span></div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; ping</div><div class="line">QUEUED</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; exec</div><div class="line">//redis无情的拒绝了事务的执行，原因是“之前出现了错误”</div><div class="line">(error) EXECABORT Transaction discarded because of previous errors.</div></pre></td></tr></table></figure>
<p>而对于“调用EXEC之后的错误”，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。我们也来看一个例子：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; multi</div><div class="line">OK</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">23</span></div><div class="line">QUEUED</div><div class="line">//age不是集合，所以如下是一条明显错误的指令</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; sadd age <span class="number">15</span></div><div class="line">QUEUED</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">29</span></div><div class="line">QUEUED</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; exec //执行事务时，redis不会理睬第<span class="number">2</span>条指令执行错误</div><div class="line"><span class="number">1</span>) OK</div><div class="line"><span class="number">2</span>) (error) WRONGTYPE Operation against a key holding the wrong kind of value</div><div class="line"><span class="number">3</span>) OK</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; get age</div><div class="line"><span class="string">"29"</span> //可以看出第<span class="number">3</span>条指令被成功执行了</div></pre></td></tr></table></figure>
<p>好了，我们来说说最后一个指令“WATCH”，这是一个很好用的指令，它可以帮我们实现类似于“乐观锁”的效果，即CAS（check and set）。</p>
<p>WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。  </p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">23</span></div><div class="line">OK</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; watch age //开始监视age</div><div class="line">OK</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">24</span> //在EXEC之前，age的值被修改了</div><div class="line">OK</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; multi</div><div class="line">OK</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; set age <span class="number">25</span></div><div class="line">QUEUED</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; get age</div><div class="line">QUEUED</div><div class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; exec //触发EXEC</div><div class="line">(nil) //事务无法被执行</div></pre></td></tr></table></figure>
<h2 id="教你看懂redis配置-–-简介"><a href="#教你看懂redis配置-–-简介" class="headerlink" title="教你看懂redis配置 – 简介"></a>教你看懂redis配置 – 简介</h2><p>我们可以在启动redis-server时指定应该加载的配置文件，方法如下：</p>
<p>$ redis-server /path/to/redis.conf<br>接下来，我们就来讲解下redis配置文件的各个配置项的含义，注意，本文是基于redis-2.8.4版本进行讲解的。</p>
<p>redis官方提供的redis.conf文件，足有700+行，其中100多行为有效配置行，另外的600多行为注释说明。</p>
<p>在配置文件的开头部分，首先明确了一些度量单位：</p>
<p> 1k =&gt; 1000 bytes<br> 1kb =&gt; 1024 bytes<br> 1m =&gt; 1000000 bytes<br> 1mb =&gt; 1024<em>1024 bytes<br> 1g =&gt; 1000000000 bytes<br> 1gb =&gt; 1024</em>1024*1024 bytes</p>
<p>可以看出，redis配置中对单位的大小写不敏感，1GB、1Gb和1gB都是相同的。由此也说明，redis只支持bytes，不支持bit单位。</p>
<p>redis支持“主配置文件中引入外部配置文件”，很像C/C++中的include指令，比如：</p>
<p>include /path/to/other.conf<br>如果你看过redis的配置文件，会发现还是很有条理的。redis配置文件被分成了几大块区域，它们分别是：</p>
<ul>
<li>通用（general）</li>
<li>快照（snapshotting）</li>
<li>复制（replication）</li>
<li>安全（security）</li>
<li>限制（limits)</li>
<li>追加模式（append only mode)</li>
<li>LUA脚本（lua scripting)</li>
<li>慢日志（slow log)</li>
<li>事件通知（event notification）</li>
</ul>
<p>下面我们就来逐一讲解。</p>
<h2 id="教你看懂redis配置-通用"><a href="#教你看懂redis配置-通用" class="headerlink" title="教你看懂redis配置-通用"></a>教你看懂redis配置-通用</h2><p>默认情况下，redis并不是以daemon形式来运行的。通过daemonize配置项可以控制redis的运行形式，如果改为yes，那么redis就会以daemon形式运行：</p>
<p>daemonize no<br>当以daemon形式运行时，redis会生成一个pid文件，默认会生成在/var/run/redis.pid。当然，你可以通过pidfile来指定pid文件生成的位置，比如：</p>
<p>pidfile /path/to/redis.pid<br>默认情况下，redis会响应本机所有可用网卡的连接请求。当然，redis允许你通过bind配置项来指定要绑定的IP，比如：</p>
<p>bind 192.168.1.2 10.8.4.2<br>redis的默认服务端口是6379，你可以通过port配置项来修改。如果端口设置为0的话，redis便不会监听端口了。</p>
<p>port 6379<br>有些同学会问“如果redis不监听端口，还怎么与外界通信呢”，其实redis还支持通过unix socket方式来接收请求。可以通过unixsocket配置项来指定unix socket文件的路径，并通过unixsocketperm来指定文件的权限。</p>
<p>unixsocket /tmp/redis.sock<br>unixsocketperm 755<br>当一个redis-client一直没有请求发向server端，那么server端有权主动关闭这个连接，可以通过timeout来设置“空闲超时时限”，0表示永不关闭。</p>
<p>timeout 0<br>TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。所以关闭一个连接最长需要120秒的时间。如果设置为0，则不会进行保活检测。</p>
<p>tcp-keepalive 0<br>redis支持通过loglevel配置项设置日志等级，共分四级，即debug、verbose、notice、warning。</p>
<p>loglevel notice<br>redis也支持通过logfile配置项来设置日志文件的生成位置。如果设置为空字符串，则redis会将日志输出到标准输出。假如你在daemon情况下将日志设置为输出到标准输出，则日志会被写到/dev/null中。</p>
<p>logfile “”<br>如果希望日志打印到syslog中，也很容易，通过syslog-enabled来控制。另外，syslog-ident还可以让你指定syslog里的日志标志，比如：</p>
<p>syslog-ident redis<br>而且还支持指定syslog设备，值可以是USER或LOCAL0-LOCAL7。具体可以参考syslog服务本身的用法。</p>
<p>syslog-facility local0<br>对于redis来说，可以设置其数据库的总数量，假如你希望一个redis包含16个数据库，那么设置如下：</p>
<p>databases 16<br>这16个数据库的编号将是0到15。默认的数据库是编号为0的数据库。用户可以使用select <dbid>来选择相应的数据库。</dbid></p>
<h2 id="教你看懂redis配置-–-快照"><a href="#教你看懂redis配置-–-快照" class="headerlink" title="教你看懂redis配置 – 快照"></a>教你看懂redis配置 – 快照</h2><p>快照，主要涉及的是redis的RDB持久化相关的配置，我们来一起看一看。</p>
<p>我们可以用如下的指令来让数据保存到磁盘上，即控制RDB快照功能：</p>
<p>save <seconds> <changes><br>举例来说：</changes></seconds></p>
<p>save 900 1 //表示每15分钟且至少有1个key改变，就触发一次持久化</p>
<p>save 300 10 //表示每5分钟且至少有10个key改变，就触发一次持久化</p>
<p>save 60 10000 //表示每60秒至少有10000个key改变，就触发一次持久化<br>如果你想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果，就像这样：</p>
<p>save “”<br>如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。</p>
<p>如果下一次RDB持久化成功，redis会自动恢复接受写请求。</p>
<p>当然，如果你不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，你完全可以关闭这个功能，以便在快照写入失败时，也能确保redis继续接受新的写请求。配置项如下：</p>
<p>stop-writes-on-bgsave-error yes<br>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p>
<p>rdbcompression yes<br>在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果你希望获取到最大的性能提升，可以关闭此功能。</p>
<p>rdbchecksum yes<br>我们还可以设置快照文件的名称，默认是这样配置的：</p>
<p>dbfilename dump.rdb<br>最后，你还可以设置这个快照文件存放的路径。比如默认设置就是当前文件夹：</p>
<p>dir ./</p>
<h2 id="教你看懂redis配置-–-复制"><a href="#教你看懂redis配置-–-复制" class="headerlink" title="教你看懂redis配置 – 复制"></a>教你看懂redis配置 – 复制</h2><p>redis提供了主从同步功能。</p>
<p>通过slaveof配置项可以控制某一个redis作为另一个redis的从服务器，通过指定IP和端口来定位到主redis的位置。一般情况下，我们会建议用户为从redis设置一个不同频率的快照持久化的周期，或者为从redis配置一个不同的服务端口等等。</p>
<p>slaveof <masterip> <masterport><br>如果主redis设置了验证密码的话（使用requirepass来设置），则在从redis的配置中要使用masterauth来设置校验密码，否则的话，主redis会拒绝从redis的访问请求。</masterport></masterip></p>
<p>masterauth <master-password><br>当从redis失去了与主redis的连接，或者主从同步正在进行中时，redis该如何处理外部发来的访问请求呢？这里，从redis可以有两种选择：</master-password></p>
<p>第一种选择：如果slave-serve-stale-data设置为yes（默认），则从redis仍会继续响应客户端的读写请求。</p>
<p>第二种选择：如果slave-serve-stale-data设置为no，则从redis会对客户端的请求返回“SYNC with master in progress”，当然也有例外，当客户端发来INFO请求和SLAVEOF请求，从redis还是会进行处理。</p>
<p>你可以控制一个从redis是否可以接受写请求。将数据直接写入从redis，一般只适用于那些生命周期非常短的数据，因为在主从同步时，这些临时数据就会被清理掉。自从redis2.6版本之后，默认从redis为只读。</p>
<p>slave-read-only yes<br>只读的从redis并不适合直接暴露给不可信的客户端。为了尽量降低风险，可以使用rename-command指令来将一些可能有破坏力的命令重命名，避免外部直接调用。比如：</p>
<p>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52<br>从redis会周期性的向主redis发出PING包。你可以通过repl_ping_slave_period指令来控制其周期。默认是10秒。</p>
<p>repl-ping-slave-period 10<br>在主从同步时，可能在这些情况下会有超时发生：</p>
<p>以从redis的角度来看，当有大规模IO传输时。<br>以从redis的角度来看，当数据传输或PING时，主redis超时<br>以主redis的角度来看，在回复从redis的PING时，从redis超时<br>用户可以设置上述超时的时限，不过要确保这个时限比repl-ping-slave-period的值要大，否则每次主redis都会认为从redis超时。</p>
<p>repl-timeout 60<br>我们可以控制在主从同步时是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。如果你关闭了TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。（如果你不了解TCP_NODELAY，可以到这里来科普一下）。</p>
<p>repl-disable-tcp-nodelay no<br>我们还可以设置同步队列长度。队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可。</p>
<p>repl-backlog-size 1mb<br>如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。</p>
<p>repl-backlog-ttl 3600<br>我们可以给众多的从redis设置优先级，在主redis持续工作不正常的情况，优先级高的从redis将会升级为主redis。而编号越小，优先级越高。比如一个主redis有三个从redis，优先级编号分别为10、100、25，那么编号为10的从redis将会被首先选中升级为主redis。当优先级被设置为0时，这个从redis将永远也不会被选中。默认的优先级为100。</p>
<p>slave-priority 100<br>假如主redis发现有超过M个从redis的连接延时大于N秒，那么主redis就停止接受外来的写请求。这是因为从redis一般会每秒钟都向主redis发出PING，而主redis会记录每一个从redis最近一次发来PING的时间点，所以主redis能够了解每一个从redis的运行情况。</p>
<p>min-slaves-to-write 3<br>min-slaves-max-lag 10<br>上面这个例子表示，假如有大于等于3个从redis的连接延迟大于10秒，那么主redis就不再接受外部的写请求。上述两个配置中有一个被置为0，则这个特性将被关闭。默认情况下min-slaves-to-write为0，而min-slaves-max-lag为10。</p>
<h2 id="教你看懂redis配置-–-安全"><a href="#教你看懂redis配置-–-安全" class="headerlink" title="教你看懂redis配置 – 安全"></a>教你看懂redis配置 – 安全</h2><p>我们可以要求redis客户端在向redis-server发送请求之前，先进行密码验证。当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解。</p>
<p>requirepass zhimakaimen<br>这里我们通过requirepass将密码设置成“芝麻开门”。</p>
<p>redis允许我们对redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。比如可以把CONFIG命令改成一个很复杂的名字，这样可以避免外部的调用，同时还可以满足内部调用的需要：</p>
<p>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c89<br>我们甚至可以禁用掉CONFIG命令，那就是把CONFIG的名字改成一个空字符串：</p>
<p>rename-command CONFIG “”<br>但需要注意的是，如果你使用AOF方式进行数据持久化，或者需要与从redis进行通信，那么更改指令的名字可能会引起一些问题。</p>
<h2 id="教你看懂redis配置-限制"><a href="#教你看懂redis配置-限制" class="headerlink" title="教你看懂redis配置 -限制"></a>教你看懂redis配置 -限制</h2><p>我们可以设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。</p>
<p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<p>maxclients 10000<br>我们甚至可以设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>如果redis无法根据移除规则来移除内存中的数据，或者我们设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。</p>
<p>maxmemory <bytes><br>需要注意的一点是，如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</bytes></p>
<p>对于内存移除规则来说，redis提供了多达6种的移除规则。他们是：</p>
<p>volatile-lru：使用LRU算法移除过期集合中的key<br>allkeys-lru：使用LRU算法移除key<br>volatile-random：在过期集合中移除随机的key<br>allkeys-random：移除随机的key<br>volatile-ttl：移除那些TTL值最小的key，即那些最近才过期的key。<br>noeviction：不进行移除。针对写操作，只是返回错误信息。<br>无论使用上述哪一种移除规则，如果没有合适的key可以移除的话，redis都会针对写请求返回错误信息。</p>
<p>maxmemory-policy volatile-lru<br>LRU算法和最小TTL算法都并非是精确的算法，而是估算值。所以你可以设置样本的大小。假如redis默认会检查三个key并选择其中LRU的那个，那么你可以改变这个key样本的数量。</p>
<p>maxmemory-samples 3<br>最后，我们补充一个信息，那就是到目前版本（2.8.4）为止，redis支持的写指令包括了如下这些：</p>
<p>set setnx setex append<br>incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd<br>sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby<br>zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby<br>getset mset msetnx exec sort</p>
<h2 id="教你看懂redis配置-–-追加模式"><a href="#教你看懂redis配置-–-追加模式" class="headerlink" title="教你看懂redis配置 – 追加模式"></a>教你看懂redis配置 – 追加模式</h2><p>默认情况下，redis会异步的将数据持久化到磁盘。这种模式在大部分应用程序中已被验证是很有效的，但是在一些问题发生时，比如断电，则这种机制可能会导致数分钟的写请求丢失。</p>
<p>如博文上半部分中介绍的，追加文件（Append Only File）是一种更好的保持数据一致性的方式。即使当服务器断电时，也仅会有1秒钟的写请求丢失，当redis进程出现问题且操作系统运行正常时，甚至只会丢失一条写请求。</p>
<p>我们建议大家，AOF机制和RDB机制可以同时使用，不会有任何冲突。对于如何保持数据一致性的讨论，请参见本文。</p>
<p>appendonly no<br>我们还可以设置aof文件的名称：</p>
<p>appendfilename “appendonly.aof”<br>fsync()调用，用来告诉操作系统立即将缓存的指令写入磁盘。一些操作系统会“立即”进行，而另外一些操作系统则会“尽快”进行。</p>
<p>redis支持三种不同的模式：</p>
<p>no：不调用fsync()。而是让操作系统自行决定sync的时间。这种模式下，redis的性能会最快。<br>always：在每次写请求后都调用fsync()。这种模式下，redis会相对较慢，但数据最安全。<br>everysec：每秒钟调用一次fsync()。这是性能和安全的折衷。<br>默认情况下为everysec。有关数据一致性的揭秘，可以参考本文。</p>
<p>appendfsync everysec<br>当fsync方式设置为always或everysec时，如果后台持久化进程需要执行一个很大的磁盘IO操作，那么redis可能会在fsync()调用时卡住。目前尚未修复这个问题，这是因为即使我们在另一个新的线程中去执行fsync()，也会阻塞住同步写调用。</p>
<p>为了缓解这个问题，我们可以使用下面的配置项，这样的话，当BGSAVE或BGWRITEAOF运行时，fsync()在主进程中的调用会被阻止。这意味着当另一路进程正在对AOF文件进行重构时，redis的持久化功能就失效了，就好像我们设置了“appendsync none”一样。如果你的redis有时延问题，那么请将下面的选项设置为yes。否则请保持no，因为这是保证数据完整性的最安全的选择。</p>
<p>no-appendfsync-on-rewrite no<br>我们允许redis自动重写aof。当aof增长到一定规模时，redis会隐式调用BGREWRITEAOF来重写log文件，以缩减文件体积。</p>
<p>redis是这样工作的：redis会记录上次重写时的aof大小。假如redis自启动至今还没有进行过重写，那么启动时aof文件的大小会被作为基准值。这个基准值会和当前的aof大小进行比较。如果当前aof大小超出所设置的增长比例，则会触发重写。另外，你还需要设置一个最小大小，是为了防止在aof很小时就触发重写。</p>
<p>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br>如果设置auto-aof-rewrite-percentage为0，则会关闭此重写功能。</p>
<h2 id="教你看懂redis配置-–-LUA脚本"><a href="#教你看懂redis配置-–-LUA脚本" class="headerlink" title="教你看懂redis配置 – LUA脚本"></a>教你看懂redis配置 – LUA脚本</h2><p>lua脚本的最大运行时间是需要被严格限制的，要注意单位是毫秒：</p>
<p>lua-time-limit 5000<br>如果此值设置为0或负数，则既不会有报错也不会有时间限制。</p>
<h2 id="教你看懂redis配置-–-慢日志"><a href="#教你看懂redis配置-–-慢日志" class="headerlink" title="教你看懂redis配置 – 慢日志"></a>教你看懂redis配置 – 慢日志</h2><p>redis慢日志是指一个系统进行日志查询超过了指定的时长。这个时长不包括IO操作，比如与客户端的交互、发送响应内容等，而仅包括实际执行查询命令的时间。</p>
<p>针对慢日志，你可以设置两个参数，一个是执行时长，单位是微秒，另一个是慢日志的长度。当一个新的命令被写入日志时，最老的一条会从命令日志队列中被移除。</p>
<p>单位是微秒，即1000000表示一秒。负数则会禁用慢日志功能，而0则表示强制记录每一个命令。</p>
<p>slowlog-log-slower-than 10000<br>慢日志最大长度，可以随便填写数值，没有上限，但要注意它会消耗内存。你可以使用SLOWLOG RESET来重设这个值。</p>
<p>slowlog-max-len 128</p>
<h2 id="教你看懂redis配置-–-事件通知"><a href="#教你看懂redis配置-–-事件通知" class="headerlink" title="教你看懂redis配置 – 事件通知"></a>教你看懂redis配置 – 事件通知</h2><p>redis可以向客户端通知某些事件的发生。这个特性的具体解释可以参见本文。</p>
<h2 id="教你看懂redis配置-–-高级配置"><a href="#教你看懂redis配置-–-高级配置" class="headerlink" title="教你看懂redis配置 – 高级配置"></a>教你看懂redis配置 – 高级配置</h2><p>有关哈希数据结构的一些配置项：</p>
<p>hash-max-ziplist-entries 512<br>hash-max-ziplist-value 64<br>有关列表数据结构的一些配置项：</p>
<p>list-max-ziplist-entries 512<br>list-max-ziplist-value 64<br>有关集合数据结构的配置项：</p>
<p>set-max-intset-entries 512<br>有关有序集合数据结构的配置项：</p>
<p>zset-max-ziplist-entries 128<br>zset-max-ziplist-value 64<br>关于是否需要再哈希的配置项：</p>
<p>activerehashing yes<br>关于客户端输出缓冲的控制项：</p>
<p>client-output-buffer-limit normal 0 0 0<br>client-output-buffer-limit slave 256mb 64mb 60<br>client-output-buffer-limit pubsub 32mb 8mb 60<br>有关频率的配置项：</p>
<p>hz 10<br>有关重写aof的配置项</p>
<p>aof-rewrite-incremental-fsync yes</p>
<p>至此，redis的入门内容就结束了，内容实在不少，但相对来说都很基础，本文没有涉及redis集群、redis工作原理、redis源码、redis相关LIB库等内容，后续会陆续奉献</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git笔记]]></title>
      <url>http://hangweiping.github.io/2016/05/08/git%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
</blockquote>
<a id="more"></a>
<h3 id="Git-与-SVN-区别"><a href="#Git-与-SVN-区别" class="headerlink" title="Git 与 SVN 区别"></a>Git 与 SVN 区别</h3><p>GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。<br>如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。</p>
<ol>
<li>GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。</li>
<li>GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。    </li>
<li>GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。  </li>
<li>GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。  </li>
<li>GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。    </li>
</ol>
<h2 id="git安装及初始设置"><a href="#git安装及初始设置" class="headerlink" title="git安装及初始设置"></a>git安装及初始设置</h2><p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"Your Name"</span></div><div class="line">$ git config --global user.email <span class="string">"email@example.com"</span></div></pre></td></tr></table></figure>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="基本操作-初始化，添加，提交，查看状态"><a href="#基本操作-初始化，添加，提交，查看状态" class="headerlink" title="基本操作(初始化，添加，提交，查看状态)"></a>基本操作(初始化，添加，提交，查看状态)</h2><p><strong>暂存区是Git非常重要的概念</strong>，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
<p>初始化一个Git仓库，使用<code>git init</code>命令。<br>添加文件到Git仓库，分两步：</p>
<ul>
<li>第一步，使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>第二步，使用命令<code>git commit</code>，完成。</li>
</ul>
<p>要随时掌握工作区的状态，使用<code>git status</code>命令。<br>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<p><strong>add的实质</strong> 理解Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</li>
<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>
</ul>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><ul>
<li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</li>
<li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</li>
<li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</li>
</ul>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。<br>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git鼓励大量使用分支：</p>
<ul>
<li>查看分支：<code>git branch</code></li>
<li>创建分支：<code>git branch &lt;name&gt;</code></li>
<li>切换分支：<code>git checkout &lt;name&gt;</code></li>
<li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></li>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li>
<li>删除分支：<code>git branch -d &lt;name&gt;</code></li>
</ul>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用`git pull，如果有冲突，要先处理冲突。</li>
</ul>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="创作标签"><a href="#创作标签" class="headerlink" title="创作标签"></a>创作标签</h3><ul>
<li>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code>；</li>
<li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li>
<li><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
</ul>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><p>让<strong>Git显示颜色</strong>，会让命令输出看起来更醒目：<br><code>$ git config --global color.ui true</code></p>
<p><strong>忽略某些文件</strong>时，需要编写<code>.gitignore</code>；<br><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p>
<p><strong>配置别名</strong>：Git配置文件都放在<code>.git/config</code>文件中</p>
<p>搭建Git服务器非常简单，通常10分钟即可完成.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5(1)--web worker]]></title>
      <url>http://hangweiping.github.io/2016/05/07/web_worker/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JavaScript语言采用的是单线程模型，也就是说，所有任务排成一个队列，一次只能做一件事。随着电脑计算能力的增强，尤其是多核CPU的出现，这一点带来很大的不便，无法充分发挥JavaScript的潜力。</p>
</blockquote>
<p>Web Worker的目的，就是为JavaScript创造多线程环境，允许主线程将一些任务分配给子线程。在主线程运行的同时，子线程在后台运行，两者互不干扰。等到子线程完成计算任务，再把结果返回给主线程。因此，每一个子线程就好像一个“工人”（worker），默默地完成自己的工作。这样做的好处是，一些高计算量或高延迟的工作，被worker线程负担了，所以主进程（通常是UI进程）就会很流畅，不会被阻塞或拖慢。</p>
<a id="more"></a>
<h4 id="Worker线程分成好几种。"><a href="#Worker线程分成好几种。" class="headerlink" title="Worker线程分成好几种。"></a>Worker线程分成好几种。</h4><ul>
<li>普通的Worker：只能与创造它们的主进程通信。</li>
<li>Shared Worker：能被所有同源的进程获取（比如来自不同的浏览器窗口、iframe窗口和其他Shared worker），它们必须通过一个端口通信。</li>
<li>ServiceWorker：实际上是一个在网络应用与浏览器或网络层之间的代理层。它可以拦截网络请求，使得离线访问成为可能。</li>
</ul>
<h4 id="Web-Worker有以下几个特点："><a href="#Web-Worker有以下几个特点：" class="headerlink" title="Web Worker有以下几个特点："></a>Web Worker有以下几个特点：</h4><ul>
<li><strong>同域限制</strong>。子线程加载的脚本文件，必须与主线程的脚本文件在同一个域。</li>
<li><strong>DOM限制</strong>。子线程所在的全局对象，与主进程不一样，它无法读取网页的DOM对象，即<code>document</code>、<code>window</code>、<code>parent</code>这些对象，子线程都无法得到。（但是，<code>navigator</code>对象和<code>location</code>对象可以获得。）</li>
<li><strong>脚本限制</strong>。子线程无法读取网页的全局变量和函数，也不能执行alert和confirm方法，不过可以执行setInterval和setTimeout，以及使用XMLHttpRequest对象发出AJAX请求。</li>
<li><strong>文件限制</strong>。子线程无法读取本地文件，即子线程无法打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</li>
</ul>
<h4 id="我们可以做什么："><a href="#我们可以做什么：" class="headerlink" title="我们可以做什么："></a>我们可以做什么：</h4><ol>
<li>可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信</li>
<li>可以在worker中通过importScripts(url)加载另外的脚本文件</li>
<li>可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval()</li>
<li>可以使用XMLHttpRequest来发送请求</li>
<li>可以访问navigator的部分属性</li>
</ol>
<h4 id="有那些局限性："><a href="#有那些局限性：" class="headerlink" title="有那些局限性："></a>有那些局限性：</h4><ol>
<li>不能跨域加载JS</li>
<li>worker内代码不能访问DOM</li>
<li>各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行</li>
<li>不是每个浏览器都支持这个新特性</li>
</ol>
<p>使用之前，检查浏览器是否支持这个API。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.Worker) &#123;</div><div class="line">  <span class="comment">// 支持</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 不支持</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="新建和启动子线程"><a href="#新建和启动子线程" class="headerlink" title="新建和启动子线程"></a>新建和启动子线程</h2><p>主线程采用<code>new</code>命令，调用<code>Worker</code>构造函数，可以新建一个子线程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'work.js'</span>);</div></pre></td></tr></table></figure>
<p>Worker构造函数的参数是一个脚本文件，这个文件就是子线程所要完成的任务，上面代码中是<code>work.js</code>。由于子线程不能读取本地文件系统，所以这个脚本文件必须来自网络端。如果下载没有成功，比如出现404错误，这个子线程就会默默地失败。</p>
<p>子线程新建之后，并没有启动，必需等待主线程调用<code>postMessage</code>方法，即发出信号之后才会启动。<code>postMessage</code>方法的参数，就是主线程传给子线程的信号。它可以是一个字符串，也可以是一个对象。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">worker</span><span class="selector-class">.postMessage</span>("<span class="selector-tag">Hello</span> <span class="selector-tag">World</span>");</div><div class="line"><span class="selector-tag">worker</span><span class="selector-class">.postMessage</span>(&#123;<span class="attribute">method</span>: <span class="string">'echo'</span>, args: [<span class="string">'Work'</span>]&#125;);</div></pre></td></tr></table></figure>
<p>只要符合父线程的同源政策，Worker线程自己也能新建Worker线程。Worker线程可以使用XMLHttpRequest进行网络I/O，但是<code>XMLHttpRequest</code>对象的<code>responseXML</code>和<code>channel</code>属性总是返回<code>null</code>。</p>
<h2 id="子线程的事件监听"><a href="#子线程的事件监听" class="headerlink" title="子线程的事件监听"></a>子线程的事件监听</h2><p>在子线程内，必须有一个回调函数，监听message事件。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* File: work.js */</span></div><div class="line"></div><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</div><div class="line">  <span class="keyword">self</span>.postMessage(<span class="string">'You said: '</span> + e.data);</div><div class="line">&#125;, <span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<p>self代表子线程自身，self.addEventListener表示对子线程的message事件指定回调函数（直接指定onmessage属性的值也可）。回调函数的参数是一个事件对象，它的data属性包含主线程发来的信号。self.postMessage则表示，子线程向主线程发送一个信号。</p>
<p>根据主线程发来的不同的信号值，子线程可以调用不同的方法。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* File: work.js */</span></div><div class="line"></div><div class="line">self.onmessage = function(event) &#123;</div><div class="line">  <span class="built_in">var</span> <span class="built_in">method</span> = event.data.<span class="built_in">method</span>;</div><div class="line">  <span class="built_in">var</span> <span class="built_in">args</span> = event.data.<span class="built_in">args</span>;</div><div class="line"></div><div class="line">  <span class="built_in">var</span> reply = doSomething(<span class="built_in">args</span>);</div><div class="line">  self.postMessage(&#123;<span class="built_in">method</span>: <span class="built_in">method</span>, reply: reply&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="主线程的事件监听"><a href="#主线程的事件监听" class="headerlink" title="主线程的事件监听"></a>主线程的事件监听</h2><p>主线程也必须指定message事件的回调函数，监听子线程发来的信号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* File: main.js */</span></div><div class="line"></div><div class="line">worker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(e.data);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>主线程可以监听子线程是否发生错误。如果发生错误，会触发主线程的error事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">worker.onerror(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(event);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"></div><div class="line">worker.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(event);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="关闭子线程"><a href="#关闭子线程" class="headerlink" title="关闭子线程"></a>关闭子线程</h2><p>使用完毕之后，为了节省系统资源，我们必须在主线程调用terminate方法，手动关闭子线程。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker<span class="selector-class">.terminate</span>();</div></pre></td></tr></table></figure>
<p>也可以子线程内部关闭自身。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self<span class="selector-class">.close</span>();</div></pre></td></tr></table></figure>
<h2 id="主线程与子线程的数据通信"><a href="#主线程与子线程的数据通信" class="headerlink" title="主线程与子线程的数据通信"></a>主线程与子线程的数据通信</h2><p>前面说过，主线程与子线程之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，子线程对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给子线程，后者再将它还原。</p>
<p>主线程与子线程之间也可以交换二进制数据，比如File、Blob、ArrayBuffer等对象，也可以在线程之间发送。</p>
<p>但是，用拷贝方式发送二进制数据，会造成性能问题。比如，主线程向子线程发送一个500MB文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做<a href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#transferable-objects" target="_blank" rel="external">Transferable Objects</a>。</p>
<p>如果要使用该方法，postMessage方法的最后一个参数必须是一个数组，用来指定前面发送的哪些值可以被转移给子线程。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">worker</span><span class="selector-class">.postMessage</span>(<span class="selector-tag">arrayBuffer</span>, <span class="selector-attr">[arrayBuffer]</span>);</div><div class="line"><span class="selector-tag">window</span><span class="selector-class">.postMessage</span>(<span class="selector-tag">arrayBuffer</span>, <span class="selector-tag">targetOrigin</span>, <span class="selector-attr">[arrayBuffer]</span>);</div></pre></td></tr></table></figure>
<h2 id="同页面的Web-Worker"><a href="#同页面的Web-Worker" class="headerlink" title="同页面的Web Worker"></a>同页面的Web Worker</h2><p>通常情况下，子线程载入的是一个单独的JavaScript文件，但是也可以载入与主线程在同一个网页的代码。假设网页代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"worker"</span> <span class="attr">type</span>=<span class="string">"app/worker"</span>&gt;</span><span class="actionscript"></span></div><div class="line"></div><div class="line">            addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">                postMessage(<span class="string">'Im reading Tech.pro'</span>);</div><div class="line">            &#125;, <span class="literal">false</span>);</div><div class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们可以读取页面中的script，用worker来处理。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'#worker'</span>).textContent]);</div></pre></td></tr></table></figure>
<p>这里需要把代码当作二进制对象读取，所以使用Blob接口。然后，这个二进制对象转为URL，再通过这个URL创建worker。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">url</span> = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line"><span class="built_in">var</span> worker = <span class="keyword">new</span> Worker(<span class="built_in">url</span>);</div></pre></td></tr></table></figure>
<p>部署事件监听代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">worker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(e.data);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>最后，启动worker。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">worker<span class="selector-class">.postMessage</span>(<span class="string">''</span>);</div></pre></td></tr></table></figure>
<p>整个页面的代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"worker"</span> <span class="attr">type</span>=<span class="string">"app/worker"</span>&gt;</span><span class="actionscript"></span></div><div class="line">    addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">      postMessage(<span class="string">'Work done!'</span>);</div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">document</span>.querySelector(<span class="string">'#worker'</span>).textContent]);</div><div class="line">      <span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line">      <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</div><div class="line"></div><div class="line">      worker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(e.data);</div><div class="line">      &#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line">      worker.postMessage(<span class="string">''</span>);</div><div class="line">    &#125;)();</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到，主线程和子线程的代码都在同一个网页上面。</p>
<p>上面所讲的Web Worker都是专属于某个网页的，当该网页关闭，worker就自动结束。除此之外，还有一种共享式的Web Worker，允许多个浏览器窗口共享同一个worker，只有当所有网口关闭，它才会结束。这种共享式的Worker用SharedWorker对象来建立，因为适用场合不多，这里就省略了。</p>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>Service worker是一个在浏览器后台运行的脚本，与网页不相干，专注于那些不需要网页或用户互动就能完成的功能。它主要用于操作离线缓存。</p>
<p>Service Worker有以下特点。</p>
<ul>
<li>属于JavaScript Worker，不能直接接触DOM，通过<code>postMessage</code>接口与页面通信。</li>
<li>不需要任何页面，就能执行。</li>
<li>不用的时候会终止执行，需要的时候又重新执行，即它是事件驱动的。</li>
<li>有一个精心定义的升级策略。</li>
<li>只在HTTPs协议下可用，这是因为它能拦截网络请求，所以必须保证请求是安全的。</li>
<li>可以拦截发出的网络请求，从而控制页面的网路通信。</li>
<li>内部大量使用Promise。</li>
</ul>
<p>Service worker的常见用途。</p>
<ul>
<li>通过拦截网络请求，使得网站运行得更快，或者在离线情况下，依然可以执行。</li>
<li>作为其他后台功能的基础，比如消息推送和背景同步。</li>
</ul>
<p>使用Service Worker有以下步骤。</p>
<p>首先，需要向浏览器登记Service Worker。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">if</span> (<span class="string">'serviceWorker'</span> in navigator) &#123;</div><div class="line">  <span class="selector-tag">navigator</span><span class="selector-class">.serviceWorker</span><span class="selector-class">.register</span>(<span class="string">'/sw.js'</span>)</div><div class="line">    <span class="selector-class">.then</span>(function(registration) &#123;</div><div class="line">    <span class="comment">// 登记成功</span></div><div class="line">    console<span class="selector-class">.log</span>(<span class="string">'ServiceWorker登记成功，范围为'</span>, registration.scope);</div><div class="line">    &#125;)<span class="selector-class">.catch</span>(function(err) &#123;</div><div class="line">    <span class="comment">// 登记失败</span></div><div class="line">      console<span class="selector-class">.log</span>(<span class="string">'ServiceWorker登记失败：'</span>, err);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码向浏览器登记<code>sw.js</code>脚本，实质就是浏览器加载<code>sw.js</code>。这段代码可以多次调用，浏览器会自行判断<code>sw.js</code>是否登记过，如果已经登记过，就不再重复执行了。注意，Service worker脚本必须与页面在同一个域，且必须在HTTPs协议下正常运行。</p>
<p><code>sw.js</code>位于域名的根目录下，这表明这个Service worker的范围（scope）是整个域，即会接收整个域下面的<code>fetch</code>事件。如果脚本的路径是<code>/example/sw.js</code>，那么Service worker只对<code>/example/</code>开头的URL有效（比如<code>/example/page1/</code>、<code>/example/page2/</code>）。如果脚本不在根目录下，但是希望对整个域都有效，可以指定<code>scope</code>属性。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">navigator.serviceWorker.<span class="keyword">register</span>(<span class="string">'/path/to/serviceworker.js'</span>, &#123;</div><div class="line">  scope: <span class="string">'/'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一旦登记完成，这段脚本就会用户的浏览器之中长期存在，不会随着用户离开你的网站而消失。</p>
<p><code>.register</code>方法返回一个Promise对象。</p>
<p>登记成功后，浏览器执行下面步骤。</p>
<ol>
<li>下载资源（Download）</li>
<li>安装（Install）</li>
<li>激活（Activate）</li>
</ol>
<p>安装和激活，主要通过事件来判断。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">event</span>)</span> <span class="comment">&#123;</span></span></div><div class="line">  event.waitUntil(</div><div class="line">    fetchStuffAndInitDatabases()</div><div class="line">  );</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">event</span>)</span> <span class="comment">&#123;</span></span></div><div class="line">  // You're good to go!</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Service worker一旦激活，就开始控制页面。网页加载的时候，可以选择一个Service worker作为自己的控制器。不过，页面第一次加载的时候，它不受Service worker控制，因为这时还没有一个Service worker在运行。只有重新加载页面后，Service worker才会生效，控制加载它的页面。</p>
<p>你可以查看<code>navigator.serviceWorker.controller</code>，了解当前哪个ServiceWorker掌握控制权。如果后台没有任何Service worker，<code>navigator.serviceWorker.controller</code>返回<code>null</code>。</p>
<p>Service worker激活以后，就能监听<code>fetch</code>事件。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">event</span>)</span> <span class="comment">&#123;</span></span></div><div class="line">  console.log(event.request);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>fetch</code>事件会在两种情况下触发。</p>
<ul>
<li>用户访问Service worker范围内的网页。</li>
<li>这些网页发出的任何网络请求（页面本身、CSS、JS、图像、XHR等等），即使这些请求是发向另一个域。但是，<code>iframe</code>和``标签发出的请求不会被拦截。</li>
</ul>
<p><code>fetch</code>事件的<code>event</code>对象的<code>request</code>属性，返回一个对象，包含了所拦截的网络请求的所有信息，比如URL、请求方法和HTTP头信息。</p>
<p>Service worker的强大之处，在于它会拦截请求，并会返回一个全新的回应。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</div><div class="line">  event.respondWith(<span class="keyword">new</span> Response(<span class="string">"Hello world!"</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>respondWith</code>方法的参数是一个Response对象实例，或者一个Promise对象（resolved以后返回一个Response实例）。上面代码手动创造一个Response实例。</p>
<p>下面是完整的<a href="https://github.com/jakearchibald/isserviceworkerready/tree/gh-pages/demos/manual-response" target="_blank" rel="external">代码</a>。</p>
<p>先看网页代码<code>index.html</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">body</span> &#123;</div><div class="line">      <span class="attribute">white-space</span>: pre-line;</div><div class="line">      <span class="attribute">font-family</span>: monospace;</div><div class="line">      <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">", "</span>) + <span class="string">'\n'</span>));</div><div class="line">      <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      log(<span class="string">"Error"</span>, err);</div><div class="line">    &#125;;</div><div class="line">    navigator.serviceWorker.register(<span class="string">'sw.js'</span>, &#123;</div><div class="line">      scope: <span class="string">'./'</span></div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">sw</span>) </span>&#123;</div><div class="line">      log(<span class="string">"Registered!"</span>, sw);</div><div class="line">      log(<span class="string">"You should get a different response when you refresh"</span>);</div><div class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      log(<span class="string">"Error"</span>, err);</div><div class="line">    &#125;);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后是Service worker脚本<code>sw.js</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The SW will be shutdown when not in use to save memory,</span></div><div class="line"><span class="comment">// be aware that any global state is likely to disappear</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"SW startup"</span>);</div><div class="line"></div><div class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"SW installed"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"SW activated"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Caught a fetch!"</span>);</div><div class="line">  event.respondWith(<span class="keyword">new</span> Response(<span class="string">"Hello world!"</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>每一次浏览器向服务器要求一个文件的时候，就会触发<code>fetch</code>事件。Service worker可以在发出这个请求之前，前拦截它。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(<span class="keyword">event</span>)</span> <span class="comment">&#123;</span></span></div><div class="line">  var request = event.request;</div><div class="line">  ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>实际应用中，我们使用<code>fetch</code>方法去抓取资源，该方法返回一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="regexp">/\.jpg$/</span>.test(event.request.url)) &#123;</div><div class="line">    event.respondWith(</div><div class="line">      fetch(<span class="string">'//www.google.co.uk/logos/example.gif'</span>, &#123;</div><div class="line">        mode: <span class="string">'no-cors'</span></div><div class="line">      &#125;)</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，如果网页请求JPG文件，就会被Service worker拦截，转而返回一个Google的Logo图像。<code>fetch</code>方法默认会加上CORS信息头，，上面设置了取消这个头。</p>
<p>下面的代码是一个将所有JPG、PNG图片请求，改成WebP格式返回的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// Listen to fetch events</span></div><div class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Check if the image is a jpeg</span></div><div class="line">  <span class="keyword">if</span> (<span class="regexp">/\.jpg$|.png$/</span>.test(event.request.url)) &#123;</div><div class="line">    <span class="comment">// Inspect the accept header for WebP support</span></div><div class="line">    <span class="keyword">var</span> supportsWebp = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (event.request.headers.has(<span class="string">'accept'</span>))&#123;</div><div class="line">      supportsWebp = event.request.headers.get(<span class="string">'accept'</span>).includes(<span class="string">'webp'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If we support WebP</span></div><div class="line">    <span class="keyword">if</span> (supportsWebp) &#123;</div><div class="line">      <span class="comment">// Clone the request</span></div><div class="line">      <span class="keyword">var</span> req = event.request.clone();</div><div class="line">      <span class="comment">// Build the return URL</span></div><div class="line">      <span class="keyword">var</span> returnUrl = req.url.substr(<span class="number">0</span>, req.url.lastIndexOf(<span class="string">"."</span>)) + <span class="string">".webp"</span>;</div><div class="line">      event.respondWith(fetch(returnUrl, &#123;</div><div class="line">        mode: <span class="string">'no-cors'</span></div><div class="line">      &#125;));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果请求失败，可以通过Promise的<code>catch</code>方法处理。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</div><div class="line">  event.respondWith(</div><div class="line">    fetch(event.request).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">"Request failed!"</span>);</div><div class="line">    &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>登记成功后，可以在Chrome浏览器访问<code>chrome://inspect/#service-workers</code>，查看整个浏览器目前正在运行的Service worker。访问<code>chrome://serviceworker-internals</code>，可以查看浏览器目前安装的所有Service worker。</p>
<p>一个已经登记过的Service worker脚本，如果发生改动，浏览器就会重新安装，这被称为“升级”。</p>
<p>Service worker有一个Cache API，用来缓存外部资源。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</div><div class="line">  <span class="comment">// pre cache a load of stuff:</span></div><div class="line">  event.waitUntil(</div><div class="line">    caches.open(<span class="string">'myapp-static-v1'</span>).then(<span class="function"><span class="keyword">function</span><span class="params">(cache)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> cache.addAll([</div><div class="line">        <span class="string">'/'</span>,</div><div class="line">        <span class="string">'/styles/all.css'</span>,</div><div class="line">        <span class="string">'/styles/imgs/bg.png'</span>,</div><div class="line">        <span class="string">'/scripts/all.js'</span></div><div class="line">      ]);</div><div class="line">    &#125;)</div><div class="line">  )</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</div><div class="line">  event.respondWith(</div><div class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span><span class="params">(response)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> response || fetch(event.request);</div><div class="line">    &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，<code>caches.open</code>方法用来建立缓存，然后使用<code>addAll</code>方法添加资源。<code>caches.match</code>方法则用来建立缓存以后，匹配当前请求是否在缓存之中，如果命中就取出缓存，否则就正常发出这个请求。一旦一个资源进入缓存，它原来指定是否过期的HTTP信息头，就会被忽略。缓存之中的资源，只在你移除它们的时候，才会被移除。</p>
<p>单个资源可以使用<code>cache.put(request, response)</code>方法添加。</p>
<p>下面是一个在安装阶段缓存资源的例子。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> staticCacheName = <span class="string">'static'</span>;</div><div class="line"><span class="keyword">var</span> version = <span class="string">'v1::'</span>;</div><div class="line"></div><div class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</div><div class="line">  event.waitUntil(updateStaticCache());</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateStaticCache</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> caches.open(version + staticCacheName)</div><div class="line">    .then(<span class="function"><span class="keyword">function</span> <span class="params">(cache)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> cache.addAll([</div><div class="line">        <span class="string">'/path/to/javascript.js'</span>,</div><div class="line">        <span class="string">'/path/to/stylesheet.css'</span>,</div><div class="line">        <span class="string">'/path/to/someimage.png'</span>,</div><div class="line">        <span class="string">'/path/to/someotherimage.png'</span>,</div><div class="line">        <span class="string">'/'</span>,</div><div class="line">        <span class="string">'/offline'</span></div><div class="line">      ]);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码将JavaScript脚本、CSS样式表、图像文件、网站首页、离线页面，存入浏览器缓存。这些资源都要等全部进入缓存之后，才会安装。</p>
<p>安装以后，就需要激活。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  event.waitUntil(</div><div class="line">    caches.keys()</div><div class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">keys</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keys</div><div class="line">          .filter(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> key.indexOf(version) !== <span class="number">0</span>;</div><div class="line">          &#125;)</div><div class="line">          .map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> caches.delete(key);</div><div class="line">          &#125;)</div><div class="line">        );</div><div class="line">      &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Worker的其他尝试"><a href="#Worker的其他尝试" class="headerlink" title="Worker的其他尝试"></a>Worker的其他尝试</h3><p>我们已经知道Worker通过接收一个URL来创建一个worker，那么我们是否可以利用web worker来做一些类似jsonp的请求呢，大家知道jsonp是通过插入script标签来加载json数据的，而script元素在加载和执行过程中都是阻塞式的，如果能利用web worker实现异步加载将会非常不错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// /aj/webWorker/core.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">$E</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</div><div class="line">&#125;</div><div class="line">onload =<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//通过web worker加载</span></div><div class="line">    $E(<span class="string">'workerLoad'</span>).onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> url =<span class="string">'http://js.wcdn.cn/aj/mblog/face2'</span>;</div><div class="line">        <span class="keyword">var</span> d = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</div><div class="line">        <span class="keyword">var</span> worker =<span class="keyword">new</span> Worker(url);</div><div class="line">        worker.onmessage =<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'web worker: '</span>+ ((<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf() - d));</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//通过jsonp加载</span></div><div class="line">    $E(<span class="string">'jsonpLoad'</span>).onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> url =<span class="string">'http://js.wcdn.cn/aj/mblog/face1'</span>;</div><div class="line">        <span class="keyword">var</span> d = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</div><div class="line">        STK.core.io.scriptLoader(&#123;</div><div class="line">            method:<span class="string">'post'</span>,</div><div class="line">            url : url,</div><div class="line">            onComplete : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'jsonp: '</span>+ ((<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf() - d));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//通过ajax加载</span></div><div class="line">    $E(<span class="string">'ajaxLoad'</span>).onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> url =<span class="string">'http://js.wcdn.cn/aj/mblog/face'</span>;</div><div class="line">        <span class="keyword">var</span> d = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</div><div class="line">        STK.core.io.ajax(&#123;</div><div class="line">            url : url,</div><div class="line">            onComplete : <span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'ajax: '</span>+ ((<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf() - d));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>HTML页面：/aj/webWorker/worker.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Worker example: load data<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://js.t.sinajs.cn/STK/js/gaea.1.14.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://js.wcdn.cn/aj/webWorker/core.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"workerLoad"</span> <span class="attr">value</span>=<span class="string">"web worker加载"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"jsonpLoad"</span> <span class="attr">value</span>=<span class="string">"jsonp加载"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"ajaxLoad"</span> <span class="attr">value</span>=<span class="string">"ajax加载"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>得到控制台输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">web worker: <span class="number">174</span></div><div class="line">jsonp: <span class="number">25</span></div><div class="line">ajax: <span class="number">38</span></div></pre></td></tr></table></figure>
<p>这个例子将通过 web worker、jsonp、ajax三种不同的方式来加载一个169.42KB大小的JSON数据高位，所以用web worker来加载数据还是比较慢的，即便是大数据量情况下也没任何优势，可能是Worker初始化新起线程比较耗时间。除了在加载过程中是无阻塞的之外没有任何优势。</p>
<p>web worker是不支持跨域加载JS的，这对于将静态文件部署到单独的静态服务器的网站来说是个坏消息。所以web worker只能用来加载同域下的json数据，而这方面ajax已经可以做到了，而且效率更高更通用。还是让Worker做它自己擅长的事吧。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Matt West, <a href="http://blog.teamtreehouse.com/using-web-workers-to-speed-up-your-javascript-applications" target="_blank" rel="external">Using Web Workers to Speed-Up Your JavaScript Applications</a></li>
<li>Eric Bidelman, <a href="http://www.html5rocks.com/en/tutorials/workers/basics/" target="_blank" rel="external">The Basics of Web Workers</a></li>
<li>Eric Bidelman, <a href="http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast" target="_blank" rel="external">Transferable Objects: Lightning Fast!</a></li>
<li>Jesse Cravens, <a href="http://tech.pro/tutorial/1487/web-worker-patterns" target="_blank" rel="external">Web Worker Patterns</a></li>
<li>Bipin Joshi, <a href="http://www.developer.com/lang/jscript/7-things-you-need-to-know-about-web-workers.html" target="_blank" rel="external">7 Things You Need To Know About Web Workers</a></li>
<li>Jeremy Keith, <a href="https://adactio.com/journal/9775" target="_blank" rel="external">My first Service Worker</a></li>
<li>Alex Russell, <a href="https://github.com/slightlyoff/ServiceWorker" target="_blank" rel="external">ServiceWorker</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5(2)--web storage]]></title>
      <url>http://hangweiping.github.io/2016/05/06/web_storage/</url>
      <content type="html"><![CDATA[<p>WebStorage是HTML5中本地存储的解决方案之一，在HTML5的WebStorage概念引入之前除去IE User Data、Flash Cookie、Google Gears等看名字就不靠谱的解决方案，浏览器兼容的本地存储方案只有使用cookie。有同学可能会问，既然有了cookie本地存储，为什么还要引入WebStorage的概念？</p>
<a id="more"></a>
<h3 id="Cookie肿么了"><a href="#Cookie肿么了" class="headerlink" title="Cookie肿么了"></a>Cookie肿么了</h3><p>cookie的缺陷是非常明显的</p>
<p>\1. 数据大小：作为存储容器，cookie的大小限制在4KB左右这是非常坑爹的，尤其对于现在复杂的业务逻辑需求，4KB的容量除了存储一些配置字段还简单单值信息，对于绝大部分开发者来说真的不知指望什么了。</p>
<p>\2. 安全性问题：由于在HTTP请求中的cookie是明文传递的（HTTPS不是），带来的安全性问题还是很大的。</p>
<p>\3. 网络负担：我们知道cookie会被附加在每个HTTP请求中，在HttpRequest 和HttpResponse的header中都是要被传输的，所以无形中增加了一些不必要的流量损失。</p>
<h3 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h3><p>WebStorage是HTML新增的本地存储解决方案之一，但并不是为了取代cookie而制定的标准，cookie作为HTTP协议的一部分用来处理客户端和服务器通信是不可或缺的，session正是依赖于实现的客户端状态保持。WebStorage的意图在于解决本来不应该cookie做，却不得不用cookie的本地存储。</p>
<p>WebStorage提供两种类型的API：localStorage和sessionStorage，两者的区别看名字就有大概了解，localStorage在本地永久性存储数据，除非显式将其删除或清空，sessionStorage存储的数据只在会话期间有效，关闭浏览器则自动删除。两个对象都有共同的API</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> <span class="title">Storage</span> &#123;</div><div class="line">  <span class="keyword">readonly</span> attribute unsigned <span class="keyword">long</span> length;</div><div class="line">  DOMString? key(unsigned <span class="keyword">long</span> index);</div><div class="line">  <span class="function">getter DOMString <span class="title">getItem</span>(<span class="params">DOMString key</span>)</span>;</div><div class="line">  <span class="function">setter creator <span class="keyword">void</span> <span class="title">setItem</span>(<span class="params">DOMString key, DOMString <span class="keyword">value</span></span>)</span>;</div><div class="line">  <span class="function">deleter <span class="keyword">void</span> <span class="title">removeItem</span>(<span class="params">DOMString key</span>)</span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span>(<span class="params"></span>)</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>length:唯一的属性，只读，用来获取storage内的键值对数量。</li>
<li>key：根据index获取storage的键名</li>
<li>getItem：根据key获取storage内的对应value</li>
<li>setItem：为storage内添加键值对</li>
<li>removeItem：根据键名，删除键值对</li>
<li>clear：清空storage对象</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在实现了WebStorage的浏览器中，页面有两个全局的对象localStorage和sessionStorage</p>
<p><img src="http://img0.tuicool.com/vaeArq.png!web" alt="image"></p>
<p>以localStorage为例，看一段简单的操作代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ls=localStorage;</div><div class="line">            <span class="built_in">console</span>.log(ls.length);<span class="comment">//0</span></div><div class="line">            ls.setItem(<span class="string">'name'</span>,<span class="string">'Byron'</span>);</div><div class="line">            ls.setItem(<span class="string">'age'</span>,<span class="string">'24'</span>);</div><div class="line">            <span class="built_in">console</span>.log(ls.length);<span class="comment">//2</span></div><div class="line">            </div><div class="line">            <span class="comment">//遍历localStorage</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ls.length;i++)&#123;</div><div class="line">                <span class="comment">/*</span></div><div class="line">                    age : 24 </div><div class="line">                    name : Byron </div><div class="line">                */</div><div class="line">                <span class="keyword">var</span> key=ls.key(i);</div><div class="line">                <span class="built_in">console</span>.log(key+<span class="string">' : '</span>+ls.getItem(key));</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            ls.removeItem(<span class="string">'age'</span>);</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ls.length;i++)&#123;</div><div class="line">                <span class="comment">/*</span></div><div class="line">                    name : Byron </div><div class="line">                */</div><div class="line">                <span class="keyword">var</span> key=ls.key(i);</div><div class="line">                <span class="built_in">console</span>.log(key+<span class="string">' : '</span>+ls.getItem(key));</div><div class="line">            &#125;</div><div class="line">            ls.clear();<span class="comment">//0</span></div><div class="line">            <span class="built_in">console</span>.log(ls.length);</div></pre></td></tr></table></figure>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>同时HTML5规定了一个storage事件，在WebStorage发生变化的时候触发，可以用此监视不同页面对storage的修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface StorageEvent : Event &#123;</div><div class="line">  readonly attribute DOMString key;</div><div class="line">  readonly attribute DOMString? oldValue;</div><div class="line">  readonly attribute DOMString? newValue;</div><div class="line">  readonly attribute DOMString url;</div><div class="line">  readonly attribute Storage? storageArea;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>key:键值对的键</li>
<li>oldValue：修改之前的value</li>
<li>newValue：修改之后的value</li>
<li>url：触发改动的页面url</li>
<li>StorageArea：发生改变的Storage</li>
</ul>
<p><em>在index.php中定义</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"test.php"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(e.key+<span class="string">' is changed form '</span>+e.oldValue+<span class="string">' to '</span>+e.newValue+<span class="string">' by      '</span>+e.url );</div><div class="line">      <span class="built_in">console</span>.log(e.storageArea ==localStorage);</div><div class="line">&#125;,<span class="literal">false</span>);</div><div class="line">            </div><div class="line">localStorage.setItem(<span class="string">'userName'</span>,<span class="string">'Byron'</span>);</div></pre></td></tr></table></figure>
<p><em>test.php</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localStorage.setItem(<span class="string">'userName'</span>,<span class="string">'Casper'</span>);</div></pre></td></tr></table></figure>
<p>在index.php页面点击链接访问test.php时可以看到index.php的控制台输出log</p>
<h3 id="为什么比cookie好"><a href="#为什么比cookie好" class="headerlink" title="为什么比cookie好"></a>为什么比cookie好</h3><ol>
<li>从容量上讲WebStorage一般浏览器提供5M的存储空间，用来存储视频、图片神马的不够，但对于绝大部分操作足矣.</li>
<li>安全性上WebStorage并不作为HTTP header发送的浏览器，所以相对安全</li>
<li>从流量上讲，因为WebStorage不传送到服务器，所以不必要的流量可以节省，这样对于高频次访问或者针对手机移动设备的网页还是很不错的。</li>
<li>这并不意味着WebStorage可以取代cookie，而是有了WebStorage后cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。所以仅仅作为本地存储解决方案WebStorage是优于cookie的。</li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1.浏览器兼容性，这个几乎是所有HTML5新特性中最容易实施的了，因为IE8+的浏览器都支持，在IE7、IE6中可以使用IE User Data实现。</p>
<p><img src="http://img2.tuicool.com/myaA73.jpg!web" alt="2011052411384081"> </p>
<p>2.由于localStorage和sessionStorage都是对象，所以我饿每年也可以通过”.key”或”[key]”的方式获取、修改键值对，但不推荐这么做</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">localStorage.userName=<span class="string">'Frank'</span>;</div><div class="line"><span class="built_in">console</span>.log(localStorage[<span class="string">'userName'</span>]);</div></pre></td></tr></table></figure>
<p>3.虽然localStorage存储在本地，但不同的浏览器存储存储数据是独立的，所以在Chrome上存储的localStorage在FireFox上是获取不到的。</p>
<p>4.localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理，低版本IE可以使用 <a href="https://github.com/douglascrockford/JSON-js/blob/master/json2.js" target="_blank" rel="external">json2.js</a></p>
<p>5.现在很多浏览器都提供了“匿名访问”，“安全模式”，“隐身窗口”等等功能。在这种情况下，浏览器都是会重新建立一个新的localStorage，所以这些模式下的页面是没法访问在正常模式下的页面中的数据。</p>
<p>6.除了控制台，Chrome还为本地存储提供了非常直观的显示方式，调试的时候很方便</p>
<p><img src="http://img0.tuicool.com/RVzQFb.png!web" alt="image"></p>
<h3 id="引入实例"><a href="#引入实例" class="headerlink" title="引入实例"></a>引入实例</h3><p>今天给大家分享一个留言实时保存的例子。</p>
<p>js代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">function</span> <span class="title">upInfo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="number">2</span>     <span class="keyword">var</span> lStorage = <span class="built_in">window</span>.localStorage;</div><div class="line"> <span class="number">3</span>     <span class="keyword">var</span> show = <span class="built_in">window</span>.document.getElementById(<span class="string">"show"</span>);</div><div class="line"> <span class="number">4</span>     <span class="keyword">if</span> (<span class="built_in">window</span>.localStorage.myBoard) &#123;</div><div class="line"> <span class="number">5</span>         show.value = <span class="built_in">window</span>.localStorage.myBoard;</div><div class="line"> <span class="number">6</span>     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">7</span>         <span class="keyword">var</span> info = <span class="string">"还没有留言"</span>;</div><div class="line"> <span class="number">8</span>         show.value = <span class="string">"还没有留言"</span>;</div><div class="line"> <span class="number">9</span>     &#125;</div><div class="line"><span class="number">10</span> &#125;</div><div class="line"><span class="number">11</span> <span class="function"><span class="keyword">function</span> <span class="title">addInfo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="number">12</span>     <span class="keyword">var</span> info = <span class="built_in">window</span>.document.getElementById(<span class="string">"t1"</span>);</div><div class="line"><span class="number">13</span>     <span class="keyword">var</span> lStorage = <span class="built_in">window</span>.localStorage;</div><div class="line"><span class="number">14</span>     <span class="keyword">if</span> (lStorage.myBoard) &#123;</div><div class="line"><span class="number">15</span>         <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="number">16</span>         lStorage.myBoard += t1.value + <span class="string">"\n发表时间："</span> + date.toLocaleString() + <span class="string">"\n"</span>;</div><div class="line"><span class="number">17</span>     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">18</span>         <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="number">19</span>         lStorage.myBoard = t1.value + <span class="string">"\n发表时间："</span> + date.toLocaleString() + <span class="string">"\n"</span>;</div><div class="line"><span class="number">20</span>     &#125;</div><div class="line"><span class="number">21</span>     upInfo();</div><div class="line"><span class="number">22</span> &#125;</div><div class="line"><span class="number">23</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanInfo</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="number">24</span>     <span class="built_in">window</span>.localStorage.removeItem(<span class="string">"myBoard"</span>);</div><div class="line"><span class="number">25</span>     upInfo();</div><div class="line"><span class="number">26</span> &#125;</div><div class="line"><span class="number">27</span> upInfo();</div></pre></td></tr></table></figure>
<p>html如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> 1 <span class="tag">&lt;<span class="name">body</span>&gt;</span> </div><div class="line"> 2   <span class="tag">&lt;<span class="name">div</span>&gt;</span> </div><div class="line"> 3    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>简单的web存储留言板<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </div><div class="line"> 4    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"t1"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> </div><div class="line"> 5    <span class="tag">&lt;<span class="name">br</span> /&gt;</span> </div><div class="line"> 6    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"addInfo()"</span> <span class="attr">value</span>=<span class="string">"留言"</span> /&gt;</span> </div><div class="line"> 7    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"cleanInfo()"</span> <span class="attr">value</span>=<span class="string">"清除留言"</span> /&gt;</span> </div><div class="line"> 8    <span class="tag">&lt;<span class="name">br</span> /&gt;</span> </div><div class="line"> 9    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span> </div><div class="line">10    <span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">"shows"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span> </div><div class="line">11    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"show"</span> <span class="attr">readonly</span>=<span class="string">"readonly"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> </div><div class="line">12   <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">13  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>运行效果，如下：</p>
<p><img src="http://img0.tuicool.com/QbQNVv2.png!web" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5(3)--web socket]]></title>
      <url>http://hangweiping.github.io/2016/05/05/web_socket/</url>
      <content type="html"><![CDATA[<p>HTTP协议是一种无状态协议，服务器端本身不具有识别客户端的能力，必须借助外部机制，比如session和cookie，才能与特定客户端保持对话。这多多少少带来一些不便，尤其在服务器端与客户端需要持续交换数据的场合（比如网络聊天），更是如此。为了解决这个问题，HTML5提出了浏览器的<a href="http://dev.w3.org/html5/websockets/" target="_blank" rel="external">WebSocket API</a>。</p>
<blockquote>
<p>WebSocket的主要作用是，允许服务器端与客户端进行全双工（full-duplex）的通信。举例来说，HTTP协议有点像发电子邮件，发出后必须等待对方回信；WebSocket则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。</p>
<a id="more"></a>
</blockquote>
<p>WebSocket协议完全可以取代Ajax方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。</p>
<p>WebSocket不使用HTTP协议，而是使用自己的协议。浏览器发出的WebSocket请求类似于下面的样子：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Host</span>: example.com</div><div class="line"><span class="attribute">Origin</span>: null</div><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: sN9cRrP/n9NdMgdcy2VJFQ==</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure>
<p>上面的头信息显示，有一个HTTP头是Upgrade。HTTP1.1协议规定，Upgrade头信息表示将通信协议从HTTP/1.1转向该项所指定的协议。“Connection: Upgrade”就表示浏览器通知服务器，如果可以，就升级到webSocket协议。Origin用于验证浏览器域名是否在服务器许可的范围内。Sec-WebSocket-Key则是用于握手协议的密钥，是base64编码的16字节随机字符串。</p>
<p>服务器端的WebSocket回应则是</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</div><div class="line"><span class="string">Connection:</span> Upgrade</div><div class="line"><span class="string">Upgrade:</span> websocket</div><div class="line">Sec-WebSocket-<span class="string">Accept:</span> fFBooB7FAkLlXgRSz0BT3v4hq5s=</div><div class="line">Sec-WebSocket-<span class="string">Origin:</span> <span class="literal">null</span></div><div class="line">Sec-WebSocket-<span class="string">Location:</span> <span class="string">ws:</span><span class="comment">//example.com/</span></div></pre></td></tr></table></figure>
<p>服务器端同样用“Connection: Upgrade”通知浏览器，需要改变协议。Sec-WebSocket-Accept是服务器在浏览器提供的Sec-WebSocket-Key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 字符串，然后再取sha-1的hash值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了webSocket请求。Sec-WebSocket-Location表示进行通信的WebSocket网址。</p>
<blockquote>
<p>请注意，WebSocket协议用ws表示。此外，还有wss协议，表示加密的WebSocket协议，对应HTTPs协议。</p>
</blockquote>
<p>完成握手以后，WebSocket协议就在TCP协议之上，开始传送数据。</p>
<p>WebSocket协议需要服务器支持，目前比较流行的实现是基于node.js的<a href="http://socket.io/" target="_blank" rel="external">socket.io</a>，更多的实现可参阅<a href="http://en.wikipedia.org/wiki/WebSocket#Server_side" target="_blank" rel="external">Wikipedia</a>。至于浏览器端，目前主流浏览器都支持WebSocket协议（包括IE 10+），仅有的例外是手机端的Opera Mini和Android Browser。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>浏览器端对WebSocket协议的处理，无非就是三件事：</p>
<ul>
<li>建立连接和断开连接</li>
<li>发送数据和接收数据</li>
<li>处理错误</li>
</ul>
<h3 id="建立连接和断开连接"><a href="#建立连接和断开连接" class="headerlink" title="建立连接和断开连接"></a>建立连接和断开连接</h3><p>首先，客户端要检查浏览器是否支持WebSocket，使用的方法是查看window对象是否具有WebSocket属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket != <span class="literal">undefined</span>) &#123;</div><div class="line">    <span class="comment">// WebSocket代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，开始与服务器建立连接（这里假定服务器就是本机的1740端口，需要使用ws协议）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket != <span class="literal">undefined</span>) &#123;</div><div class="line">    <span class="keyword">var</span> connection = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:1740'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建立连接以后的WebSocket实例对象（即上面代码中的connection），有一个readyState属性，表示目前的状态，可以取4个值：</p>
<ul>
<li>0： 正在连接</li>
<li>1： 连接成功</li>
<li>2： 正在关闭</li>
<li>3： 连接关闭</li>
</ul>
<p>握手协议成功以后，readyState就从0变为1，并触发open事件，这时就可以向服务器发送信息了。我们可以指定open事件的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">connection.onopen = wsOpen;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wsOpen</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Connected to: '</span> + event.currentTarget.URL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关闭WebSocket连接，会触发close事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">connection.onclose = wsClose;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wsClose</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Closed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">connection.close();</div></pre></td></tr></table></figure>
<h3 id="发送数据和接收数据"><a href="#发送数据和接收数据" class="headerlink" title="发送数据和接收数据"></a>发送数据和接收数据</h3><p>连接建立后，客户端通过send方法向服务器端发送数据。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connection<span class="selector-class">.send</span>(message);</div></pre></td></tr></table></figure>
<p>除了发送字符串，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用ArrayBuffer发送canvas图像数据</span></div><div class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</div><div class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="type">Uint8Array</span>(img.data.length);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</div><div class="line">    binary[i] = img.data[i];</div><div class="line">&#125;</div><div class="line">connection.send(binary.buffer);</div><div class="line"></div><div class="line"><span class="comment">// 使用Blob发送文件</span></div><div class="line"><span class="keyword">var</span> file = document.querySelector(<span class="symbol">'input</span>[<span class="class"><span class="keyword">type</span></span>=<span class="string">"file"</span>]').files[<span class="number">0</span>];</div><div class="line">connection.send(file);</div></pre></td></tr></table></figure>
<p>客户端收到服务器发送的数据，会触发message事件。可以通过定义message事件的回调函数，来处理服务端返回的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">connection.onmessage = wsMessage;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wsMessage</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的回调函数wsMessage的参数为事件对象event，该对象的data属性包含了服务器返回的数据。</p>
<p>如果接收的是二进制数据，需要将连接对象的格式设为blob或arraybuffer。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">connection.binaryType = <span class="string">'arraybuffer'</span>;</div><div class="line"></div><div class="line">connection.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e.data.byteLength); <span class="comment">// ArrayBuffer对象有byteLength属性</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>如果出现错误，浏览器会触发WebSocket实例对象的error事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">connection.onerror = wsError;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wsError</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Error: "</span> + event.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>服务器端需要单独部署处理WebSocket的代码。下面用node.js搭建一个服务器环境。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>假设监听1740端口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.listen(<span class="number">1740</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">' Server is listening on port 1740'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>接着启动WebSocket服务器。这需要加载websocket库，如果没有安装，可以先使用npm命令安装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'websocket'</span>).server;</div><div class="line"><span class="keyword">var</span> wsServer = <span class="keyword">new</span> WebSocketServer(&#123;</div><div class="line">    httpServer: server</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>WebSocket服务器建立request事件的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> connection;</div><div class="line"></div><div class="line">wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req</span>)</span>&#123;</div><div class="line">    connection = req.accept(<span class="string">'echo-protocol'</span>, req.origin);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码的回调函数接受一个参数req，表示request请求对象。然后，在回调函数内部，建立WebSocket连接connection。接着，就要对connection的message事件指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;</div><div class="line">    connection = req.accept(<span class="string">'echo-protocol'</span>, req.origin);</div><div class="line"></div><div class="line">    connection.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> msgString = message.utf8Data;</div><div class="line">        connection.sendUTF(msgString);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后，监听用户的disconnect事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reasonCode, description</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(connection.remoteAddress + <span class="string">' disconnected.'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用<a href="https://github.com/einaros/ws" target="_blank" rel="external">ws</a>模块，部署一个简单的WebSocket服务器非常容易。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server;</div><div class="line"><span class="keyword">var</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; port: <span class="number">8080</span> &#125;);</div><div class="line"></div><div class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</div><div class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'received: %s'</span>, message);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  ws.send(<span class="string">'something'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Socket-io简介"><a href="#Socket-io简介" class="headerlink" title="Socket.io简介"></a>Socket.io简介</h2><p><a href="http://socket.io/" target="_blank" rel="external">Socket.io</a>是目前最流行的WebSocket实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持WebSocket的浏览器，会自动降为Ajax连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。</p>
<p>第一步，在服务器端的项目根目录下，安装socket.io模块。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> socket.io</div></pre></td></tr></table></figure>
<p>第二步，在根目录下建立app.js，并写入以下代码（假定使用了Express框架）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</div><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(app);</div><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>).listen(server);</div><div class="line"></div><div class="line">server.listen(<span class="number">80</span>);</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码表示，先建立并运行HTTP服务器。Socket.io的运行建立在HTTP服务器之上。</p>
<p>第三步，将Socket.io插入客户端网页。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后，在客户端脚本中，建立WebSocket连接。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> socket = io.connect(<span class="symbol">'http</span>:<span class="comment">//localhost');</span></div></pre></td></tr></table></figure>
<p>由于本例假定WebSocket主机与客户端是同一台机器，所以connect方法的参数是<code>http://localhost</code>。接着，指定news事件（即服务器端发送news）的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">socket.on(<span class="string">'news'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后，用emit方法向服务器端发送信号，触发服务器端的anotherNews事件。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket<span class="selector-class">.emit</span>(<span class="string">'anotherNews'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>请注意，emit方法可以取代Ajax请求，而on方法指定的回调函数，也等同于Ajax的回调函数。</p>
</blockquote>
<p>第四步，在服务器端的app.js，加入以下代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">io.sockets.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  socket.emit(<span class="string">'news'</span>, &#123; hello: <span class="string">'world'</span> &#125;);</div><div class="line">  socket.on(<span class="string">'anotherNews'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码的io.sockets.on方法指定connection事件（WebSocket连接建立）的回调函数。在回调函数中，用emit方法向客户端发送数据，触发客户端的news事件。然后，再用on方法指定服务器端anotherNews事件的回调函数。</p>
<p>不管是服务器还是客户端，socket.io提供两个核心方法：emit方法用于发送消息，on方法用于监听对方发送的消息。</p>
<h3 id="WebSockets支持及时数据交换，并被所有现代浏览器支持。"><a href="#WebSockets支持及时数据交换，并被所有现代浏览器支持。" class="headerlink" title="WebSockets支持及时数据交换，并被所有现代浏览器支持。"></a>WebSockets支持及时数据交换，并被所有现代浏览器支持。</h3><p>没有其他技术能够像WebSocket一样提供真正的双向通信，许多web开发者仍然是依赖于ajax的长轮询来实现。（注：我认为长轮询是富于创造性和多功能性的，虽然这只是一个不太完美的解决办法（hack））对Websocket缺少热情，也许是因为多年前他的安全性的脆弱，抑或者是缺少浏览器的支持，不管怎样，这两个问题都已经被解决了。</p>
<p><strong>决定手头的工作是否需要使用WebSocket技术的方法很简单：</strong></p>
<ul>
<li>你的应用提供多个用户相互交流吗？</li>
<li>你的应用是展示服务器端经常变动的数据吗？</li>
</ul>
<p>如果你的回答是肯定的，那么请考虑使用WebSocket。如果你仍然不确定，并想要更多的灵感，这有一些杀手锏的案例。</p>
<p><strong>1.社交订阅</strong></p>
<p>对社交类的应用的一个裨益之处就是能够即时的知道你的朋友正在做什么。虽然听起来有点可怕，但是我们都喜欢这样做。你不会想要在数分钟之后才能知道一个家庭成员在馅饼制作大赛获胜或者一个朋友订婚的消息。你是在线的，所以你的订阅的更新应该是实时的。</p>
<p><strong>2.多玩家游戏</strong></p>
<p>网络正在迅速转变为游戏平台。在不使用插件（我指的是Flash）的情况下，网络开发者现在可以在浏览器中实现和体验高性能的游戏。无论你是在处理DOM元素、CSS动画，HTML5的canvas或者尝试使用WebGL，玩家之间的互动效率是至关重要的。我不想在我扣动扳机之后，我的对手却已经移动位置。</p>
<p><strong>3.协同编辑/编程</strong></p>
<p>我们生活在分布式开发团队的时代。平时使用一个文档的副本就满足工作需求了，但是你最终需要有一个方式来合并所有的编辑副本。版本控制系统，比如Git能够帮助处理某些文件，但是当Git发现一个它不能解决的冲突时,你仍然需要去跟踪人们的修改历史。通过一个协同解决方案，比如WebSocket，我们能够工作在同一个文档，从而省去所有的合并版本。这样会很容易看出谁在编辑什么或者你在和谁同时在修改文档的同一部分。</p>
<p><strong>4.点击流数据</strong></p>
<p>分析用户与你网站的互动是提升你的网站的关键。HTTP的开销让我们只能优先考虑和收集最重要的数据部分。然后，经过六个月的线下分析，我们意识到我们应该收集一个不同的判断标准——一个看起来不是那么重要但是现在却影响了一个关键的决定。与HTTP请求的开销方式相比，使用Websocket，你可以由客户端发送不受限制的数据。想要在除页面加载之外跟踪鼠标的移动？只需要通过WebSocket连接发送这些数据到服务器，并存储在你喜欢的NoSQL数据库中就可以了（MongoDB是适合记录这样的事件的）。现在你可以通过回放用户在页面的动作来清楚的知道发生了什么。</p>
<p><strong>5.股票基金报价</strong></p>
<p>金融界瞬息万变——几乎是每毫秒都在变化。我们人类的大脑不能持续以那样的速度处理那么多的数据，所以我们写了一些算法来帮我们处理这些事情。虽然你不一定是在处理高频的交易，但是，过时的信息也只能导致损失。当你有一个显示盘来跟踪你感兴趣的公司时，你肯定想要随时知道他们的价值，而不是10秒前的数据。使用WebSocket可以流式更新这些数据变化而不需要等待。</p>
<p><strong>6.体育实况更新</strong></p>
<p>现在我们开始讨论一个让人们激情澎湃的愚蠢的东西——体育。我不是运动爱好者，但是我知道运动迷们想要什么。当爱国者在打比赛的时候，我的妹夫将会沉浸于这场比赛中而不能自拔。那是一种疯狂痴迷的状态，完全发自内心的。我虽然不理解这个，但是我敬佩他们与运动之间的这种强烈的联系，所以，最后我能做的就是给他的体验中降低延迟。如果你在你的网站应用中包含了体育新闻，WebSocket能够助力你的用户获得实时的更新。</p>
<p><strong>7.多媒体聊天</strong>视频会议并不能代替和真人相见，但当你不能在同一个屋子里见到你谈话的对象时，视频会议是个不错的选择。尽管视频会议私有化做的“不错”，但其使用还是很繁琐。我可是开放式网络的粉丝，所以用WebSockets getUserMedia API和HTML5音视频元素明显是个不错的选择。WebRTC的出现顺理成章的成为我刚才概括的组合体，它看起来很有希望，但其缺乏目前浏览器的支持，所以就取消了它成为候选人的资格。</p>
<p><strong>8.基于位置的应用</strong>越来越多的开发者借用移动设备的GPS功能来实现他们<a href="http://www.infoworld.com/d/application-development/use-mongodb-make-your-app-location-aware-229403" target="_blank" rel="external">基于位置的网络应用</a>。如果你一直记录用户的位置(比如运行应用来记录运动轨迹)，你可以收集到更加细致化的数据。如果你想实时的更新网络数据仪表盘(可以说是一个监视运动员的教练)，HTTP协议显得有些笨拙。借用WebSocket TCP链接可以让数据飞起来。</p>
<p><strong>9.在线教育</strong>上学花费越来越贵了，但互联网变得更快和更便宜。<a href="http://www.infoworld.com/d/application-development/200k-computer-science-degree-or-these-free-online-classes-218565" target="_blank" rel="external">在线教育</a>是学习的不错方式，尤其是你可以和老师以及其他同学一起交流。很自然，WebSockets是个不错的选择，可以多媒体聊天、文字聊天以及其它优势如与别人合作一起在公共数字黑板上画画…</p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/" target="_blank" rel="external">WebSocket 实战</a>简要介绍了 WebSocket 的由来，原理机制以及服务端/客户端实现，并以实际客户案例指导并讲解了如何使用 WebSocket 解决实时响应及服务端消息推送方面的问题。本文适用于熟悉 HTML 协议规范和 J2EE Web 编程的读者，旨在帮助读者快速熟悉 HTML5 WebSocket 的原理和开发应用。文中的服务端及客户端项目代码可供下载，修改后可用于用户基于 WebSocket 的 HTTP 长连接的实际生产环境中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker总结]]></title>
      <url>http://hangweiping.github.io/2016/05/04/docker%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
</blockquote>
<a id="more"></a>
<h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul>
<li>Web 应用的自动化打包和发布。  </li>
<li>自动化测试和持续集成、发布。  </li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。  </li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li>
</ul>
<h2 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h2><ol>
<li>简化程序：<br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。  </li>
<li>避免选择恐惧症：<br>如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。  </li>
<li>节省开支：<br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。  </li>
</ol>
<h2 id="容器运行方式"><a href="#容器运行方式" class="headerlink" title="容器运行方式"></a>容器运行方式</h2><h3 id="输出Hello-world"><a href="#输出Hello-world" class="headerlink" title="输出Hello world"></a>输出Hello world</h3><pre><code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;
</code></pre><p>各个参数解析：  </p>
<ul>
<li>css设计指南-定位.mdocker: Docker 的二进制执行文件。  </li>
<li>run:与前面的 docker 组合来运行一个容器。  </li>
<li>ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。  </li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令  </li>
</ul>
<p>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</p>
<h3 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h3><p>我们通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力</p>
<pre><code>docker run -i -t ubuntu:15.10 /bin/bash
</code></pre><p>各个参数解析：  </p>
<ul>
<li>-i:在新容器内指定一个伪终端或终端。  </li>
<li>-t:允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
<p>此时我们已进入一个 ubuntu15.10系统的容器<br>我们尝试在容器中运行命令 cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表</p>
<h3 id="启动容器（后台模式）"><a href="#启动容器（后台模式）" class="headerlink" title="启动容器（后台模式）"></a>启动容器（后台模式）</h3><p>使用以下命令创建一个以进程方式运行的容器   </p>
<pre><code>docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
</code></pre><h2 id="Docker-实例"><a href="#Docker-实例" class="headerlink" title="Docker 实例"></a>Docker 实例</h2><h3 id="Docker-安装-MySQL"><a href="#Docker-安装-MySQL" class="headerlink" title="Docker 安装 MySQL"></a>Docker 安装 MySQL</h3><p>默认会在 3306 端口启动数据库</p>
<pre><code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=password -d mysql:latest
</code></pre><p>之后就可以使用其它应用来连接到该容器。</p>
<pre><code>docker run --name some-app --link some-mysql:mysql -d application-that-uses-mysql
</code></pre><p>或者通过 mysql</p>
<pre><code>docker run -it --link some-mysql:mysql --rm mysql sh -c &apos;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&apos;
</code></pre><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><pre><code>docker rm `docker ps -a -q`  //删除所有容器
docker images //列出本地主机上的镜像
docker pull ubuntu:13.10 //获取一个新的镜像
docker search httpd //查找镜像
</code></pre><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。  </p>
<ol>
<li>从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>使用 Dockerfile 指令来创建一个新的镜像</li>
</ol>
<h3 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h3><p>更新镜像之前，我们需要使用镜像来创建一个容器。</p>
<pre><code>docker run -t -i ubuntu:15.10 /bin/bash
root@e218edb10161:/# //在运行的容器内使用 apt-get update 命令进行更新。
</code></pre><p>在完成操作之后，输入 exit命令来退出这个容器。<br>此时ID为e218edb10161的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit来提交容器副本。</p>
<pre><code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2
</code></pre><p>各个参数说明：</p>
<ul>
<li>-m:提交的描述信息</li>
<li>-a:指定镜像作者</li>
<li>e218edb10161：容器ID</li>
<li>runoob/ubuntu:v2:指定要创建的目标镜像名</li>
</ul>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p>
<h3 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h3><p>我们可以使用 docker tag 命令，为镜像添加一个新的标签。  </p>
<pre><code>docker tag 860c279d2fec runoob/centos:dev
</code></pre><p>docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。</p>
<h3 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h3><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。<br>docker有一个连接系统允许将多个容器连接在一起，共享连接信息。<br>docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大前端工具集]]></title>
      <url>http://hangweiping.github.io/2016/04/01/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇文章记录了一枚程序猿的百宝箱。PS：每个分类的都按照推荐的先后排列。</p>
<p>主要内容是一些使用过的库、工具、套路或关注的前端组织等等，反正用 <strong>前端瑞士军刀</strong> 来总结这篇文章再合适不过鸟。</p>
</blockquote>
 <a id="more"></a>
<h4 id="您可以通过以下方式联系到我："><a href="#您可以通过以下方式联系到我：" class="headerlink" title="您可以通过以下方式联系到我："></a>您可以通过以下方式联系到我：</h4><ul>
<li>微博 <a href="http://weibo.com/darrencode" title="Darren 聂微东" target="_blank" rel="external">@聂微东</a></li>
<li>个人 Blog <a href="http://www.fefork.com/" title="一枚 Web 技术领域的手艺人" target="_blank" rel="external">fefork.com</a></li>
<li>博客园 <a href="http://www.cnblogs.com/Darren_code/" title="关注前端技术" target="_blank" rel="external">犀利的东哥</a></li>
<li>QQ 群 <strong>214199415</strong>，群名<strong>前端 Club</strong>。PS：入群务必请提供 <strong>有内容的 git 或 blog 地址</strong>，否则进不去哈:)</li>
</ul>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#blogs">前端组织/前端博客</a></li>
<li><a href="#blog_build">博客搭建</a></li>
<li><a href="#html">HTML</a></li>
<li><a href="#css">CSS</a></li>
<li><a href="#javascript">浏览端 JS</a></li>
<li><a href="#project_build">Project Build</a></li>
<li><a href="#node_package">Node Package</a></li>
<li><a href="#node_project">Node Project</a></li>
<li><a href="#read">精选阅读</a><ul>
<li><a href="#fedev">前端技术</a></li>
<li><a href="#node_read">Node 学习资料</a></li>
<li><a href="#interview">前端面试</a></li>
<li><a href="#otherdev">其他技术</a></li>
</ul>
</li>
<li><a href="#tools">工具/软件</a><ul>
<li><a href="#web">Web</a></li>
<li><a href="#app">APP</a></li>
<li><a href="#mac_soft">Mac 软件篇</a></li>
<li><a href="#mac_dev">Mac 开发篇</a></li>
<li><a href="#linux">Linux</a></li>
</ul>
</li>
<li><a href="#BrowserPlugins">Chrome Plugins</a></li>
<li><a href="#git">Git</a></li>
<li><a href="#servers">服务端</a></li>
<li><a href="#backend">数据端</a></li>
<li><a href="#ux">设计/交互</a></li>
<li><a href="#handbook">速查手册</a></li>
<li><a href="#other">杂七杂八</a></li>
<li><a href="#cool">前端炫技-炫酷狂拽叼炸天的 Web</a></li>
<li><a href="#summary">小结</a></li>
<li><a href="#todo">TODO</a></li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="blogs">前端组织/前端博客</h3>

<blockquote>
<p>虽混过外企俩家，但劳资英文这项的技能点还是灰色的…so，俺关注的站点主要以中文为主</p>
</blockquote>
<ul>
<li><a href="https://github.com" target="_blank" rel="external">GitHub</a> - 没 <em>Github</em> 都不好意思面基有木有！！！</li>
<li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">MDN</a> - 无数的资源再等着你探索，追标准和新特性肯定得关注的网站</li>
<li><a href="https://www.awesomes.cn/" target="_blank" rel="external">Awesomes.cn</a> - 国人维护的前端资源库，深度对接到 <em>Github</em>，分类和展现清晰，值得收藏</li>
<li><a href="https://uptodate.frontendrescue.org/zh/" target="_blank" rel="external">如何跟上前端开发的最新前沿</a> - RT，不解释</li>
<li><a href="http://www.imooc.com/" target="_blank" rel="external">慕课</a> - 大量的在线计算机课程。 虽然初、中级居多，但是不乏有巨作值得细细品尝</li>
<li><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="external">阮一峰</a> - 关注多年，拜读其 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ES6</a> 系列。虽网传靠写书进鸟阿里，但博客内容确实够丰富</li>
<li><a href="http://www.w3cplus.com/" target="_blank" rel="external">W3Cplus</a> - 大漠(《图解 CSS3》作者)在国内的影响力杠杠的，<em>Sass</em> 专家级</li>
<li><a href="http://taobaofed.org/" target="_blank" rel="external">淘宝前端团队</a> - 内容涵盖 <em>Web</em> 和 <em>Node</em>，要深度游深度，要广度有广度</li>
<li><a href="http://www.75team.com/" target="_blank" rel="external">奇舞团博客</a> - 坚持是最宝贵的，别人的奇舞周刊早已经过百期了</li>
<li><a href="http://fex.baidu.com/" target="_blank" rel="external">百度 FEX</a> - 代表作 <em>FIS</em>、<em>UEditor</em>、<em>WebUploader</em>、<em>KityMinder</em></li>
<li><a href="http://www.alloyteam.com/" target="_blank" rel="external">腾讯全端 AlloyTeam</a> - 腾讯 Web 前端团队，博客真的有点丑…</li>
<li><a href="http://blog.fens.me/" target="_blank" rel="external">粉丝日志 for 张丹</a> - 大爱作者写的 <em>Node</em> 系列</li>
<li><a href="http://www.zhangxinxu.com/wordpress/" target="_blank" rel="external">张鑫旭</a> - 成名多年的、高产的前端大湿，<em>CSS</em>猛人</li>
</ul>
<h3 id="blog_build">博客搭建</h3>

<ul>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a> - 快速、简洁且高效的博客框架，照着文档分分钟就可以在本地跑起来。<em>Github</em> 地址:<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a></li>
<li><a href="http://jekyll.bootcss.com/" target="_blank" rel="external">Jekyll</a> - 将纯文本转化为静态网站和博客。由于环境依赖的问题，所以安装起来可能稍费劲那么一点。<em>Github</em> 地址：<a href="https://github.com/jekyll/jekyll" target="_blank" rel="external">Jekyll</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="external">GithubPages</a> - 免费的静态站点。配合着 <em>Hexo</em> 或 <em>Jekyll</em> 的模板，分分搭建出一套炫酷的个人博客</li>
<li><a href="https://www.tumblr.com/" target="_blank" rel="external">Tumblr</a> - 轻博客的祖师爷，各种各样的主题感觉不错</li>
<li><a href="https://zh-cn.wordpress.com/" target="_blank" rel="external">Wordpress</a> - 这玩意古老到都不想介绍</li>
</ul>
<blockquote>
<p>使用 <em>Hexo/Jekyll + GitPage</em>，前端搭建静态博客那是相当 easy。用 <em>Markdown</em> 写文章做记录，再 <em>push</em> 到 <em>Github</em> 上，分分钟高大上有木有</p>
</blockquote>
<p>再推荐三款视觉效果极佳的 <em>Hexo</em> 主题，且在 <em>Github</em> 上的 <em>star</em> 都很不错：</p>
<ul>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a></li>
<li><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a></li>
<li><a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak" target="_blank" rel="external">Tranquilpeak</a></li>
</ul>
<p>不能偏心，所以也推荐三款 <em>Jekyll</em> 的好主题：</p>
<ul>
<li><a href="https://github.com/mmistakes/so-simple-theme" target="_blank" rel="external">So Simple</a> 如果你看过俺的博客，对这个主题就肯定不会陌生啦</li>
<li><a href="https://github.com/mmistakes/hpstr-jekyll-theme" target="_blank" rel="external">HPSTR</a> 当初 <a href="http://www.fefork.com/" target="_blank" rel="external">fefork</a> 差点选这个主题:)</li>
<li><a href="https://github.com/daattali/beautiful-jekyll#readme" target="_blank" rel="external">beautiful</a></li>
</ul>
<h3 id="html">HTML</h3>

<p>纯 <em>HTML</em> 相关其实没有好玩的项目，所以这儿展示的内容主要都是一些模板，而且以下列出来的都是免费的，方便拿取搭架后台或者博客</p>
<ul>
<li><a href="https://github.com/joshbuchea/HEAD" target="_blank" rel="external">HEAD</a> - 最全的 <em><head></head></em> 列表，真心佩服这种偏执的整理能力</li>
<li><a href="https://github.com/akveo/blur-admin" target="_blank" rel="external">blur-admin</a> - 视觉冲击极强的管理后台，各种动画效果。PS：因为团队有<a href="https://github.com/ant-design/ant-design" target="_blank" rel="external">ant-design</a>的使用经验，感觉使用起来不是很顺畅，这套后台又是基于<em>AngularJS</em>，所以再三权限之后还是没实际使用，劳资还是别给团队添乱了，囧…</li>
<li><a href="https://github.com/almasaeed2010/AdminLTE" target="_blank" rel="external">AdminLTE</a> - 很小清新的后台模板，每次看<a href="https://almsaeedstudio.com/preview" target="_blank" rel="external">preview</a> 页面都觉得很有视觉冲击</li>
<li><a href="https://github.com/puikinsh/gentelella" target="_blank" rel="external">gentelella</a> - 刚用这个搭建了我司内部用的的数据平台，效果喜人。模板实现的功能比较全，比如登录、注册甚至各种 <em>widget</em>，所以最终交付的时候，自己几乎没写几行CSS。</li>
<li><a href="https://github.com/google/material-design-lite" target="_blank" rel="external">material-design-lite</a> - <em>Star</em> 数超过2W的开源模板项目，包含了多套简洁的 <em>templates</em>，可以用于博客、后台或者企业首页。</li>
</ul>
<h3 id="css">CSS</h3>

<ul>
<li><a href="http://metroui.org.ua/" target="_blank" rel="external">MetroUI</a> - 好看好用，重点是样式特别、个性</li>
<li><a href="http://fontawesome.io/" target="_blank" rel="external">Font-Awesome</a> - 图标字体库。相类似的库有不少，大厂都喜欢造轮子嘛:)</li>
<li><a href="https://connoratherton.com/loaders" target="_blank" rel="external">LoadersCSS</a> - 用 CSS 技术实现 loading 动画； 补一句，想熟悉、理解 <em>keyframes、animation、transform、transition</em> 的童鞋可以直接去读其源码(只有千把行代码)，读完就算出师鸟:)</li>
<li><a href="https://github.com/weui/weui" target="_blank" rel="external">WeUI</a> - 一套同微信原生视觉体验一致的基础样式库 为微信 Web 开发量身设计，令用户的使用感知更加统一</li>
<li><a href="https://github.com/postcss/postcss" target="_blank" rel="external">PostCSS</a> - 最近才知道大名鼎鼎<a href="https://github.com/postcss/autoprefixer" target="_blank" rel="external">Autoprefixer</a>是其插件 推荐大漠的文章<a href="http://www.w3cplus.com/PostCSS/postcss-deep-dive-what-you-need-to-know.html" target="_blank" rel="external">《PostCSS深入学习》</a>，有关 PostCSS 不是什么？PostCSS 是什么？PostCSS 可以做什么等等问题，文章里面有答案</li>
<li><a href="https://github.com/una/CSSgram" target="_blank" rel="external">CSSgram</a> - 图片滤镜库，终于可以用 CSS 在 web 上实现滤镜的效果鸟 IE不支持，不过新的移动设备支持没问题 <a href="http://caniuse.com/#search=CSS%20Blend%20Modes" target="_blank" rel="external">Can I Use</a></li>
<li><a href="https://github.com/chinchang/hint.css" target="_blank" rel="external">HINT.css</a> - 一款非常小巧的提示框效果</li>
<li><a href="http://kazzkiq.github.io/balloon.css/" target="_blank" rel="external">Balloon.css</a>| |同上，一款非常小巧的提示框效果</li>
<li><a href="http://ianlunn.github.io/Hover/" target="_blank" rel="external">Hover.css</a> - 很多鼠标 Hover 态的效果，可以给产品学习一下:)</li>
<li><a href="http://css-cursor.techstream.org/" target="_blank" rel="external">Cursor</a> - 记录各浏览器对Cursor的支持情况</li>
<li><a href="https://github.com/zmoazeni/csscss" target="_blank" rel="external">csscss</a> - 用于检查 CSS 代码冗余</li>
<li><a href="http://purecss.io/" target="_blank" rel="external">purecss</a> - 小巧的响应式 CSS 库，Yahoo!出品</li>
<li><a href="https://jonsuh.com/hamburgers/" target="_blank" rel="external">hamburgers</a> - 简单的动画库，让 Click(or Tap) 变得美妙</li>
<li><a href="http://www.cssmatic.com" target="_blank" rel="external">cssmatic</a> - 一个帮忙调试CSS效果的工具</li>
</ul>
<h3 id="javascript">浏览端 JS</h3>

<ul>
<li><a href="https://github.com/requirejs/requirejs" target="_blank" rel="external">requirejs</a> - JS模块化是构建复杂项目的第一步 中文学习文档奉上：<a href="http://www.requirejs.cn/" target="_blank" rel="external">RequireJS 中文网</a></li>
<li><a href="http://echarts.baidu.com/index.html" target="_blank" rel="external">ECharts</a> - 好用，最关键的是支持的图表展示非常之多，强烈推荐</li>
<li><a href="http://www.swiper.com.cn" target="_blank" rel="external">Swiper</a> - 强大的 Slider 库 其实这类效果库非常多，但文档能那么专业的就很少鸟</li>
<li><a href="https://babeljs.io/" target="_blank" rel="external">babel</a> - <em>ES6</em> 用起来。这个插件可以让我们用新的 <strong>标准/提案</strong> 写 <em>JavaScript</em> 代码，然后再向下 <strong>转换编译</strong>，最终生成随处可用的 <em>JavaScript</em> 代码。中文文档奉上<a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/README.md" target="_blank" rel="external">《babel-handbook》</a></li>
<li><a href="http://alvarotrigo.com/fullPage/" target="_blank" rel="external">fullPage</a> - 非常好用的全屏滑动库，看 Demo 就明白</li>
<li><a href="http://photoswipe.com/" target="_blank" rel="external">PhotoSwipe</a> - 偶常用的 js 库 官网上有这么一句很关键、重要”no dependencies”</li>
<li><a href="http://cn.vuejs.org" target="_blank" rel="external">Vuejs</a> - 比较喜欢其作者… 所以劳资正在看源码学习学习</li>
<li><a href="http://lab.ejci.net/favico.js/" target="_blank" rel="external">favico.js</a> - 动态改变浏览器标签栏中的网站图标，非常好玩</li>
<li><a href="http://ant.design" target="_blank" rel="external">ant.design</a> - 蚂蚁金服搞的良心项目，文档美好的令人发指 样式优雅，强烈推荐内部系统尝试此库</li>
<li><a href="https://highlightjs.org/" target="_blank" rel="external">highlightjs</a> - 代码高亮库，支持非常多的语言</li>
<li><a href="http://www.daterangepicker.com" target="_blank" rel="external">daterangepicker</a> - 时间选择插件的不二选择，基于 <em>Bootstrap</em> 和 <a href="http://momentjs.com/" target="_blank" rel="external">Moment.js</a></li>
<li><a href="https://github.com/ksky521/nodePPT" target="_blank" rel="external">nodePPT</a> - 前同事三水的大作，好用必须得支持:) 用 Markdown 写 PPT，还可以 HTML 混排，上手飞快</li>
<li><a href="https://github.com/RubaXa/Sortable" target="_blank" rel="external">Sortable</a> - 拖拽神器，用了就知道</li>
<li><a href="https://github.com/CodeSeven/toastr" target="_blank" rel="external">toastr</a> - 信息提示的库，推荐的原因是卖相好、功能强大  <a href="http://codeseven.github.io/toastr/demo.html" target="_blank" rel="external">demo</a></li>
<li><a href="http://benpickles.github.io/peity/" target="_blank" rel="external">peity.js</a> - jQuery的图表插件，特别cute，感觉萌萌哒 将HTML转换成一个小的<em><svg/></em>饼图、圆环图、折线图等等</li>
<li><a href="https://github.com/Ranks/emojify.js" target="_blank" rel="external">emojify.js</a> - 能够将<em>emoji</em>关键词转换为<em>emoji</em>图片的<em>JS</em>插件 可以快速的为你的网站提供<em>emoji</em>表情支持</li>
<li><a href="https://github.com/Nickersoft/push.js" target="_blank" rel="external">Push.js</a> - 基于 <em>Notification API</em> 实现的桌面效果的提示栏。浏览器支持情况不错，如<a href="http://caniuse.com/#search=Notification" target="_blank" rel="external">http://caniuse.com/#search=Notification</a></li>
<li><a href="http://www.hcharts.cn/" target="_blank" rel="external">Highcharts</a>| |Highcharts 中文网，又是一个图表库 确实功能强大，但是觉得不好看… PS：官网就做的不好看，脏脏的赶脚</li>
<li><a href="https://github.com/rstacruz/nprogress/" target="_blank" rel="external">NProgress</a> - 使页面加载时有更好的loading效果</li>
<li><a href="https://github.com/jaredreich/notie.js" target="_blank" rel="external">Noticejs</a> - 一个简单的通知库，木有依赖</li>
<li><a href="https://github.com/peachananr/onepage-scroll" target="_blank" rel="external">onepage-scroll</a> - 依赖 jQuery 的单页滚动库，和 <a href="http://alvarotrigo.com/fullPage/" target="_blank" rel="external">fullPage</a> 类似</li>
<li><a href="http://videojs.com/" target="_blank" rel="external">videojs</a> - 当下视频需求都用上<em><video></video></em>鸟 样式和交互统一的问题交给 videojs 搞定:)</li>
<li><a href="http://zenorocha.github.io/clipboard.js/" target="_blank" rel="external">clipboard</a> - 仅 2KB 大小，搞定剪贴板功能，屌不屌~ 但是，Safari 不支持…</li>
<li><a href="https://github.com/impress/impress.js" target="_blank" rel="external">impress.js</a> -  用来写 PPT 不错，偶也曾为其写过一篇<a href="http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html" target="_blank" rel="external">impress.js 初体验</a></li>
<li><a href="http://fengyuanchen.github.io/cropper/" target="_blank" rel="external">Cropper</a> - 国人开发的图片裁剪库</li>
</ul>
<blockquote>
<p><strong><em><em>Swiper/PhotoSwipe/fullPage</em> 有这仨库，微信里常见的 H5 页完全不是问题哒</em></strong></p>
</blockquote>
<h3 id="project_build">Project Build</h3>

<ul>
<li><a href="https://www.npmjs.com/package/pm2" target="_blank" rel="external">pm2</a> - 是一个带有负载均衡功能的 Node 应用的进程管理器； 是 <a href="https://www.npmjs.com/package/forever" target="_blank" rel="external">Forever</a> 的进阶库，想了解的可以看这篇文章<a href="http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/" target="_blank" rel="external">《拥抱PM2》</a></li>
<li><a href="http://webpack.github.io/" target="_blank" rel="external">Webpack</a> - 项目构建工具，由于过于复杂和太强大，所以劳资还没去深入研究。</li>
<li><a href="https://github.com/gulpjs/gulp/" target="_blank" rel="external">Gulp</a> - Gulp 是基于 Node 实现 Web 前端自动化开发的工具。 俺总结了篇<a href="http://www.fefork.com/gulp_1/" target="_blank" rel="external">《gulp使用小结》</a>，推荐您阅读:)</li>
<li><a href="http://bower.io/" target="_blank" rel="external">Bower</a> - 前端项目的包管理其实是件复杂的事 谁谁谁依赖谁谁谁，谁谁谁依赖谁谁谁的某个版本…卧槽 Bower 就是搞定这件事儿的，亲爹是 Twitter 推荐篇 Bower 的中文文章：<a href="http://blog.fens.me/nodejs-bower-intro/" target="_blank" rel="external">《bower 解决 js 的依赖管理》</a></li>
<li><a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a> - 和 Gulp 类似，都是项目构建的常见选择 对比这俩的文章可谓不少，推荐篇<a href="http://www.benben.cc/blog/?p=407" target="_blank" rel="external">《Gulp vs Grunt》</a> 英盲又想看文档，可以去<a href="http://www.gruntjs.net/" target="_blank" rel="external">Grunt 中文网</a></li>
<li><a href="http://fex-team.github.io/fis3/" target="_blank" rel="external">FIS</a> - 度厂出品的前端构建工具 文档清晰，功能强大，推荐了解和使用</li>
<li><a href="https://ci.gitlab.org/" target="_blank" rel="external">Gitlab CI</a> - 一套基于<a href="https://about.gitlab.com/" target="_blank" rel="external">Gitlab</a>的持续集成服务</li>
</ul>
<blockquote>
<p>Gulp + Webpack 的使用<strong>套路</strong>参考: <a href="https://github.com/demohi/learning-gulp" target="_blank" rel="external">learning-gulp</a></p>
<p>Gulp 资料收集：<a href="https://github.com/Platform-CUF/use-gulp" target="_blank" rel="external">use-gulp</a></p>
<p>推荐篇与 Webpack 相关的文章《<a href="http://boke.io/tan-tan-css-modules/" target="_blank" rel="external">CSS Modules</a>》</p>
<p>Webpack 用起来吼吼：<a href="https://github.com/petehunt/webpack-howto" target="_blank" rel="external">webpack-howto</a></p>
</blockquote>
<h3 id="node_package">Node Package</h3>

<blockquote>
<p>作为一名大前端甚至是多端，<em>Node</em> 绝逼是必备的一块</p>
<p>有关 <em>Node</em> 的学习资料，请访问</p>
</blockquote>
<h5 id="这里介绍些有特色且前端有必要知道的包"><a href="#这里介绍些有特色且前端有必要知道的包" class="headerlink" title="这里介绍些有特色且前端有必要知道的包"></a>这里介绍些有特色且前端有必要知道的包</h5><ul>
<li><a href="https://www.npmjs.com/package/anywhere" target="_blank" rel="external">anywhere</a> - 随时随地将你的当前目录变成一个静态文件服务器的根目录</li>
<li><a href="https://www.npmjs.com/package/supervisor" target="_blank" rel="external">supervisor</a> - 监控 Node 代码，自动重启。 A supervisor program for running nodejs programs</li>
<li><a href="https://github.com/remy/nodemon" target="_blank" rel="external">nodemon</a> - 监控 Node 代码，自动重启。 Nodemon is a utility that will monitor for any changes in your source and automatically restart your server.</li>
<li><a href="https://www.npmjs.com/package/pm2" target="_blank" rel="external">pm2</a> - 是一个带有负载均衡功能的 Node 应用的进程管理器； 是 <a href="https://www.npmjs.com/package/forever" target="_blank" rel="external">Forever</a> 的进阶库，想了解的可以看这篇文章<a href="http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/" target="_blank" rel="external">《拥抱PM2》</a></li>
<li><a href="https://www.npmjs.com/package/async" target="_blank" rel="external">async</a> - 一个流程控制工具包，提供直接而强大的异步功能</li>
<li><a href="https://www.npmjs.com/package/lodash" target="_blank" rel="external">lodash</a> - JS 工具库 <em>Underscore.js</em>的一个 fork 发展而来</li>
<li><a href="https://github.com/socketio/socket.io" target="_blank" rel="external">socket.io</a> - 预计 Node 的实时框架 聊天室、页游等对实时性有高要求的较适用</li>
<li><a href="https://github.com/Automattic/mongoose" target="_blank" rel="external">Mongoose</a> - 让 NodeJS 更容易操作 Mongodb 数据库；  附上一篇<a href="https://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="external">Mongoose 学习参考文档</a></li>
<li><a href="http://npm.taobao.org/" target="_blank" rel="external">CNPM</a> - 淘宝 NPM 镜像，提供了 NPM 同步的服务 当然可不仅仅这样，利用 CNPM 可以打造<strong>企业/个人</strong>私有的 NPM 服务 推荐篇搭建私有NPM的文章：<a href="http://blog.fens.me/nodejs-cnpm-npm/" target="_blank" rel="external">《CNPM搭建私有的NPM服务》</a></li>
<li><a href="http://koajs.com/" target="_blank" rel="external">koa</a> - 玩 Node 都知道 express，但使用 koa 的就少很多，门槛比 Ex 稍高 通过 generator 避免繁琐的回调函数嵌套，强烈推崇 <a href="https://github.com/guo-yu/koa-guide" target="_blank" rel="external">官方的文章教程</a></li>
<li><a href="https://github.com/shipitjs/shipit" target="_blank" rel="external">Shipit</a> - 一个强大的自动化部署工具。 shipit 很多地方非常类似 gulp，他们的核心都是任务系统。</li>
<li><a href="https://www.npmjs.com/package/node-inspector" target="_blank" rel="external">node-inspector</a> - Node 调试工具，使用起来跟 Chrome 的 JS 调试器很相似</li>
<li><a href="https://www.npmjs.com/package/winston" target="_blank" rel="external">winston</a> - Node 服务最流行的日志库之一</li>
<li><a href="https://www.npmjs.com/package/co" target="_blank" rel="external">co</a> - 用 generator 写法让异步代码同步</li>
<li><a href="https://www.npmjs.com/package/thenify-all" target="_blank" rel="external">thenify-all</a> - 把异步的方法变成 Promise 的 Promisifies all the selected functions in an object</li>
<li><a href="http://phantomjs.org/" target="_blank" rel="external">PhantomJS</a> - 一般用来做抓取截图和无界面测试 也可以用来操作 DOM 和网络监测，很好玩的库 <a href="http://phantomjs.org/quick-start.html" target="_blank" rel="external">Quick Start</a></li>
<li><a href="https://www.npmjs.com/package/ava" target="_blank" rel="external">ava</a> - 偶是应TJ大神推荐而得之的 <em>ava</em> 未来的测试运行器</li>
<li><a href="https://github.com/mochajs/mocha" target="_blank" rel="external">Mocha</a> - Node 里最常用的测试框架； 它支持多种 Node 的 Assert libs； 同时支持异步和同步的测试，同时支持多种方式导出结果； 也支持直接在 browser 上跑 JS 代码测试。</li>
<li><a href="https://www.npmjs.com/package/koa-validate" target="_blank" rel="external">koa-validate</a> - <em>koa</em> 的校验库 可以非常方便的对 <em>queryString</em> 或 <em>postBody</em> 的信息进行验证</li>
<li><a href="https://www.npmjs.com/package/line-reader" target="_blank" rel="external">line-reader</a> - 基于<em>steam</em>的按行读文件，偶处理日志时用哒 要不实现一个按行读文件，又得 <em>steam</em>、 又得 <em>chunk</em>，还是比较麻烦的</li>
<li><a href="https://www.npmjs.com/package/everyauth" target="_blank" rel="external">everyauth</a>| |OAuth 的集成解决方案</li>
<li><a href="http://documentup.com/shelljs/shelljs" target="_blank" rel="external">shelljs</a> - 写 Node 时难免需要用 shell 去操作些神马 shelljs 是基于 Node 的 shell 工具，API 及其简单</li>
<li><a href="https://www.npmjs.com/package/hashids" target="_blank" rel="external">hashids</a> - 看名称就懂，给 userid 加解密用的</li>
<li><a href="https://github.com/coopernurse/node-pool" target="_blank" rel="external">node-pool</a> - 让 <em>Node</em> 有连接池的概念</li>
<li><a href="https://www.npmjs.com/package/colors" target="_blank" rel="external">colors</a> - 花俏的小工具 让打印<em>console.log</em>时有更好的展示样式</li>
<li><a href="https://www.npmjs.com/package/n" target="_blank" rel="external">n</a> - 控制Node的版本，想升级一行代码搞定</li>
</ul>
<blockquote>
<p><em>supervisor</em> 和 <em>nodemon</em> 这俩都是监控 Node 代码，使得每次修改代码后会，开发 Node 程序必备</p>
<p>以上库俺都有使用过，甚至有不少都是项目开发中、各种特定场景下必用的，有任何使用问题欢迎沟通哈:)</p>
</blockquote>
<h3 id="node_project">Node Project</h3>

<p><em>暂无</em></p>
<h2 id="read">精选阅读</h2>

<h3 id="fedev">前端技术</h3>

<ul>
<li><a href="http://www.imooc.com/learn/590" target="_blank" rel="external">2015D2前端论坛</a> - Node方向非常值得看，有干货，相信东哥推荐哈</li>
<li><a href="http://zhibimo.com/read/Ashu/front-end-style-guide/index.html" target="_blank" rel="external">前端开发规范手册</a> -  此手册主要实现的目标：代码一致性和最佳实践</li>
<li><a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/README.md" target="_blank" rel="external">《babel-handbook》</a> - 可以用新的规范(如 <em>ES6</em>)写代码，经过 <em>babel</em> 编译后生成没有兼容问题的代码</li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6入门</a> - 阮一峰大神所著，一本开源的JS教程 全面介绍 ECMAScript 6新引入的语法特性</li>
<li><a href="http://wiki.jikexueyuan.com/project/react-native/" target="_blank" rel="external">ReactNative 中文版</a> - 翻译自官方的中文文档</li>
<li><a href="https://fakefish.github.io/react-webpack-cookbook/index.html" target="_blank" rel="external">ReactWebpackCookBook</a> |  |此书会引导读者是进入<em>React</em>和<em>Webpack</em>的世界。 俩都是非常前沿的技术，同时使用会更有趣。</li>
<li><a href="https://github.com/ele828/react-native-guide" target="_blank" rel="external">ReactNative 学习指南</a> - 新玩意层出不穷… 对于能持续学习的童鞋，这是个美好的时代</li>
<li><a href="http://www.css88.com/doc/codeguide/" target="_blank" rel="external">HTML/CSS 编码规范</a> - 编写灵活、稳定、高质量的<em>HTML</em>和<em>CSS</em>代码的规范</li>
<li><a href="http://gold.xitu.io/entry/56c29abfa34131005b8cb1f3" target="_blank" rel="external">移动前端入门</a> - 入门价值高，移动方向常见问题的较好总结</li>
<li><a href="https://github.com/nimojs/gulp-book" target="_blank" rel="external">GulpBook</a> - Gulp 是基于 Node 实现 Web 前端自动化开发的工具</li>
</ul>
<h3 id="node_read">Node 学习资料</h3>

<ul>
<li><a href="https://github.com/youyudehexie/node123" target="_blank" rel="external">Node.js 中文资料导航</a> - Node 的中文资料导航，<em>start1300+</em></li>
<li><a href="http://blog.fens.me/series-nodejs/" target="_blank" rel="external">从零开始 NodeJS 系列文章</a> - 基本上每一篇都看过，强烈推荐</li>
<li><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">Node.js 包教不包会</a> - 值得阅读，看完绝不用买书鸟</li>
<li><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="external">七天学会 NodeJS</a> - 劳资还没看，不过看目录还不错:)</li>
<li><a href="https://github.com/dead-horse/node-style-guide" target="_blank" rel="external">Style Guide</a> - 这是一份关于如何写出一致且美观的 <em>Node</em> 代码的风格指南</li>
<li><a href="http://book.apebook.org/minghe/koa-action/index.html" target="_blank" rel="external">koa实战</a> - “<a href="https://github.com/minghe" target="_blank" rel="external">明河</a>出品”这四字已经说明一切。PS：正在连载中</li>
<li><a href="https://github.com/jabez128/stream-handbook" target="_blank" rel="external">stream-handbook</a> - 如果学习 NodeJS，那么流一定是需要掌握的概念</li>
</ul>
<h3 id="interview">前端面试</h3>

<ul>
<li><a href="http://dongfei.baijia.baidu.com/article/52449" target="_blank" rel="external">在 LinkedIn 做面试官的故事</a> - 非面试题，介绍 LinkedIn 的面试过程 文章有很多中肯的建议和想法，推荐阅读</li>
<li><a href="http://www.w3cplus.com/css/write-to-front-end-developer-interview.html" target="_blank" rel="external">大漠：写给前端面试者</a> - 这篇文章不涉及任何的面试题 大漠与大家聊聊面试者与被面者之间的感受…</li>
<li><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Chinese" target="_blank" rel="external">前端面试题</a> - Git 上非常火的前端面试题，<em>start17k+</em></li>
<li><a href="https://github.com/paddingme/Front-end-Web-Development-Interview-Question" target="_blank" rel="external">前端面经</a> - 主要内容是些前端面试笔试题和面试套路，值得阅读</li>
</ul>
<h3 id="otherdev">其他技术</h3>

<ul>
<li><a href="https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/MongoDB%20%E6%9E%81%E7%AE%80%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8.md" target="_blank" rel="external">MongoDB 极简实践入门</a> - 入门推荐的套路，非常浅显易懂</li>
<li><a href="https://github.com/macdao/ocds-guide-to-setting-up-mac" target="_blank" rel="external">Mac 设置指南</a> - Mac 使用必看 尤其适合 偏执狂/强迫症 患者:)</li>
<li><a href="https://github.com/xirong/my-markdown" target="_blank" rel="external">Markdown 资料</a> - 简单看些语法入门，快速用起来</li>
</ul>
<h2 id="tools">工具/软件</h2>

<h3 id="web">Web</h3>

<ul>
<li><a href="http://caniuse.com/" target="_blank" rel="external">CanIuse</a> - <strong>前端必备</strong>；查看浏览器对各种新特性的兼容情况</li>
<li><a href="http://overapi.com/" target="_blank" rel="external">overapi</a> - 最全的开发人员在线速查手册</li>
<li><a href="http://naotu.baidu.com" target="_blank" rel="external">百度脑图</a> - 非常方便的思维导图工具</li>
<li><a href="https://www.processon.com/" target="_blank" rel="external">ProcessOn</a> - 和百度脑图的功能类似，脑图工具。</li>
<li><a href="http://vimawesome.com/" target="_blank" rel="external">VimAwesome</a> - Vim 插件集合，<strong>Vim 党必备</strong></li>
<li><a href="https://tower.im" target="_blank" rel="external">Tower</a> - 小而美的多人协同工具。 不光只有 Web 版，还有 iPhone、iPad、Android、微信版。</li>
<li><a href="https://slides.com/" target="_blank" rel="external">Slides</a> - 一个所见即所得的 WebPPT 编辑器，非常推荐</li>
<li><a href="http://www.faviconer.co/" target="_blank" rel="external">faviconer.co</a> - 一个所见即所得的icon生成器，很好用</li>
<li><a href="http://smallpdf.com/cn" target="_blank" rel="external">smallpdf</a> - 提供各种格式和 PDF 互相转换</li>
<li><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">Cmd Markdown</a> - 好用的 Web 版 Markdown 编辑器</li>
<li><a href="https://stackedit.io/editor" target="_blank" rel="external">StackEdit</a> - 又是一款 Web 版 Markdown 编辑器</li>
<li><a href="https://modao.cc/" target="_blank" rel="external">墨刀</a> - 一个在线移动应用原型制作工具。 旨在帮助产品经理快速制作可在手机端展示的移动应用原型。</li>
<li><a href="http://www.htm2pdf.co.uk" target="_blank" rel="external">htm2pdf</a>| |HTML to PDF</li>
<li><a href="https://speakerdeck.com/p/featured" target="_blank" rel="external">Speaker Deck</a> - 在线的演讲稿展示平台</li>
<li><a href="http://runjs.cn/" target="_blank" rel="external">RunJS</a> - 在线编辑、展示、分享、交流你的 <em>JavaScript</em> 代码</li>
<li><a href="https://bootswatch.com/" target="_blank" rel="external">Bootswatch</a> - <em>Bootstrap</em> 的免费模板</li>
<li><a href="https://github.com/almasaeed2010/AdminLTE/" target="_blank" rel="external">AdminLTE</a> -  又是一个 <em>Bootstrap</em> 的免费管理后台</li>
</ul>
<h3 id="app">APP</h3>

<blockquote>
<p>以下列表中的 APP 都是不区分系统平台的</p>
</blockquote>
<ul>
<li><a href="https://www.yinxiang.com/" target="_blank" rel="external">印象笔记</a> - 免费账号完全够用，跨平台跨终端的记录软件</li>
<li><a href="http://www.365rili.com/" target="_blank" rel="external">365日历</a> - 首先肯定比系统自带的日历强大，要不推荐个蛋蛋 俺一般用来搞目标管理，比如学习计划和工作计划 生活中会订阅演唱会、电影首映的信息</li>
<li><a href="http://www.duokan.com/" target="_blank" rel="external">多看阅读</a> - kindle 确实好，但是懒得随身带着 多看还算不错，书较多且偶尔有特价比较爽</li>
<li><a href="https://itunes.apple.com/cn/app/surge-web-developer-tool-proxy/id1040100637?mt=8&amp;v0=WWW-GCCN-ITSTOP100-PAIDAPPS&amp;l=&amp;ign-mpt=uo%3D4" target="_blank" rel="external">Surge</a> - 非免费 牛逼的网络开发与调试工具，前端必备</li>
<li><a href="https://github.com/coderyi/Monkey" target="_blank" rel="external">Monkey</a> - Monkey 是 iPhone 上一个 GitHub 第三方客户端。 展示 GitHub 上的开发者的排名，以及仓库的排名</li>
</ul>
<h3 id="mac_soft">Mac 软件篇</h3>

<blockquote>
<p>对于美好事务的追求无论何时都不算晚，前年公司给配了台 Mac 用做测试开发机，于是开始在 Mac 下办公。 <strong>Windows？</strong> 回不去鸟…</p>
</blockquote>
<ul>
<li><a href="https://www.macupdate.com/app/mac/34344/alfred" target="_blank" rel="external">Alfred</a> - 绝对的Top1。除了打开应用程序之外，查找文件、全文检索、调起浏览器搜索和计数器都是俺经常使用的功能。如果想知道具体咋用，推荐阅读老池(池建强)的一篇文章：<a href="http://www.cnblogs.com/chijianqiang/p/alfred.html" target="_blank" rel="external">《神兵利器—Alfred》</a></li>
<li><a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a> - 没它程序猿没法好好干活… <em>Homebrew</em>使<em>OS X</em>更完美。 使用<em>gem</em>来安装<em>gems</em>、用<em>brew</em>来搞定那些依赖包</li>
<li><a href="https://bahoom.com/hyperdock/" target="_blank" rel="external">HyperDock</a> - 价格￥68，但感觉还是比较值的。预览和快速切换不说，能用快捷键控制窗口，能让拖拽到边缘的窗口自动调整大小(window早就有的功能)，真心能提高效率。推荐篇中文的文章：<a href="http://www.cnblogs.com/ider/p/let-mac-window-fly-with-hyperdock.html" target="_blank" rel="external">让Mac的窗口飞</a></li>
<li><a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2</a> - Mac 终端功能少又不好看，iTerm2 可以解救你~  推荐篇文章：<a href="http://swiftcafe.io/2015/07/25/iterm/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">《让你的命令行丰富多彩》</a></li>
<li><a href="https://itunes.apple.com/cn/app/browseshot/id615916400" target="_blank" rel="external">BrowseShot</a> - 偶正在使用的网页截图工具，强烈推荐</li>
<li><a href="http://www.scootersoftware.com" target="_blank" rel="external">BeyondCompare</a> - 在Windows下就开始用了 比对文件和文件夹杠杠好使，Merge必备工具</li>
<li><a href="https://www.mediaatelier.com/CheatSheet/" target="_blank" rel="external">CheatSheet</a> - 能够显示当前程序的快捷键列表，默认的快捷键是长按 ⌘</li>
<li><a href="http://www.sequelpro.com" target="_blank" rel="external">Sequel Pro</a> - 免费好用的Mysql工具</li>
<li><a href="http://www.cockos.com/licecap/" target="_blank" rel="external">LICEcap</a> - 屏幕录制工具，支持导出 GIF 动画图片格式 轻量级、使用简单，录制过程中可以改变录屏范围</li>
<li><a href="https://www.macbartender.com/" target="_blank" rel="external">Bartender</a> - 有免费试用版(一个月)。Mac右上角菜单的管理工具，试用之后右上角的菜单瞬间清爽了</li>
<li><a href="http://manico.im/" target="_blank" rel="external">Manico</a> - 快捷启动和切换 APP 的工具，高效的第一步 AppStore 上收费，不过可以免费试用</li>
<li><a href="http://www.jetbrains.com/webstorm/" target="_blank" rel="external">WebStorm</a> - 功能超强的前端 IDE，不多介绍，谁用谁知道 PS：貌似俺插件装多了，用着卡卡的，风扇呼呼转…</li>
<li><a href="https://atom.io" target="_blank" rel="external">Atom</a> - 2015 年 7 月之前，在桌面环境下我最喜欢的编辑器是 Sublime。 但之后就是 Atom，俺也专门为它写了篇<strong><em><a href="https://github.com/nieweidong/learn-atom" target="_blank" rel="external">使用纪要</a></em></strong></li>
<li><a href="http://www.getmarkman.com/" target="_blank" rel="external">马克鳗</a> - MarkMan，非常强大好用的标注、测量工具。 日常工作免费版就完全可以满足，<strong>强烈推荐</strong></li>
<li><a href="https://www.wireshark.org/" target="_blank" rel="external">Wireshark</a> - 说实话，Mac 下木有 Fiddler 挺不习惯，不过在有更强大的替代品</li>
<li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a> - 一款好用的的 Git 客户端工具，重点是支持中文:)</li>
<li><a href="https://www.focusboosterapp.com/" target="_blank" rel="external">focus booster</a> - 因为比较在意时间管理，所以这软件是俺工作时间的必备之物</li>
<li><a href="http://25.io/mou/" target="_blank" rel="external">Mou</a> - 我曾使用过的 mk 编辑器。原本准备去掉这个推荐，但是我想让大家了解下这个有意思的事情：<a href="http://matrix.sspai.com/p/c7a3c9c0" target="_blank" rel="external">《一年了，那个闻名遐迩的 Mou 你还记得吗？》</a></li>
</ul>
<h3 id="mac_dev">Mac 开发篇</h3>

<p><strong>暂无</strong></p>
<h3 id="linux">Linux</h3>

<ul>
<li><a href="http://ohmyz.sh/" target="_blank" rel="external">oh-my-zsh</a> - <strong><em>终端党</em></strong> 必用的好工具，强烈推荐</li>
<li><a href="http://www.cnblogs.com/iadanac/p/3859481.html" target="_blank" rel="external">tree</a> - linux 以树状图逐级列出目录的内容</li>
<li><a href="http://www.oneapm.com/" target="_blank" rel="external">oneapm</a> - 强大的运维工具，提供多种监控客户端； 有采集、分析、展示等一套功能； PS：我这用了服务器监控(免费哦)</li>
<li><a href="https://github.com/jkbrzt/httpie" target="_blank" rel="external">httpie</a> - 一个 CLI 中的 HTTP 客户端 用法简单、易读</li>
</ul>
<h3 id="BrowserPlugins">Chrome 浏览器插件</h3>

<blockquote>
<p><em>Chrome</em> 应用商店必定是需要翻墙的哈。</p>
</blockquote>
<p>以下插件都是俺多年积累淘出来的，数量不多，所以就不区分 <em>Github</em> 插件和非 <em>Github</em> 插件了。按照俺推荐的强度自上向下展示，且大多数插件就是偶工作和生活必备，希望能对大家有用。后续如有新发现好插件，偶也会及时更新哒。</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="external">Postman</a> - <em>POST</em> 接口调试终结者，异常强大的接口调试工具。稍稍有一点学习成本，推荐之</li>
<li><a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc" target="_blank" rel="external">JSONView</a> - 就是个 <em>JSON</em> 格式的查看工具，可以很方便的展示数据，麻麻再也不用担心偶调试接口啦。PS：同类插件有不少，所以用的开心就行</li>
<li><a href="https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/pflgjjogbmmcmfhfcnlohagkablhbpmg" target="_blank" rel="external">二维码生成器</a> - RT。PS：这FF早已经自带生成二维码工具了，<em>Chrome</em> 还得装插件才行，任性…</li>
<li><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="external">WEB前端助手(FeHelper)</a> - <a href="https://www.baidufe.com/" target="_blank" rel="external">百度FE</a>出品，功能超全的 Chrome 插件。简单列一下其功能：QR码生成器、字符串编解码工具、JSON格式化查看器、前端编码规范检测、代码压缩工具、页面取色工具、统计并分析网页加载性能等等</li>
<li><a href="https://chrome.google.com/webstore/detail/eye-dropper/hmdcmlfkchdmnmnmheododdhjedfccka" target="_blank" rel="external">Eye Dropper</a> - 前端必备的颜色提取神器，操作简单容易上手</li>
<li><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="external">Vimium</a> 和 <em>Vim</em> 快捷键一样，浏览网站时不需要鼠标咯</li>
<li><a href="https://chrome.google.com/webstore/detail/page-ruler/jlpkojjdgbllmedoapgfodplfhcbnbpn" target="_blank" rel="external">Page Ruler</a> - 前端必备的尺子。计算页面元素间距、位置等信息的时候，你就知道它的好了，无脑上手，你值得拥有</li>
<li><a href="https://chrome.google.com/webstore/detail/capture-webpage-screensho/mcbpblocgmgfnpjjppndjkmgjaogfceg" target="_blank" rel="external">FireShot</a> - 可以截取整个网页、部分页面，然后支持导出为各种格式。俺微博上发的网页全景图都是靠这个插件截取的</li>
<li><a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="external">Infinity</a> - 好不好用有点见仁见智了，但是我个人比较喜欢。使用后会让你的 <strong>新标签页</strong> 耳目一新，有漂亮的背景和各种常用的功能，比如地图、天气、<em>Gmail</em>、<em>Chrome</em>商店等等。当然，在这个插件的设置中还可以设置壁纸、动画效果等等</li>
<li><a href="https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca" target="_blank" rel="external">Momentum</a> - 同样也是 <strong>新标签页</strong> 的插件，但是不管是视觉上(高清大图)还是功能上，都比 <a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="external">Infinity</a> 高大上不少，<em>Setting</em> 里面有不少设置和快捷键，都很好上手的。<a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="external">Infinity</a>胜在中文和直观，<a href="https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca" target="_blank" rel="external">Momentum</a>胜在视觉冲击。俺基本上这俩款看心情换着用，所以希望你也都能喜欢:)</li>
<li><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="external">Google翻译</a> - 英文不好又得经常浏览英文资料的，一般都准备好了翻译工具。不过能在浏览器里达到划词翻译的方案就不多了，偶推荐这个Google翻译(PS：如不能翻墙，有道词典的扩展也同样支持划词翻译)。</li>
<li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="external">Octotree</a> - 在浏览器左侧展示 <em>Github</em> 项目的文件导航，使目录结构一目了然，而且我们国内 <em>Github</em> 的访问速度又不稳定，用这个工具也就很提效率了。对经常使用 <em>Github</em> 的同学强烈推荐</li>
<li><a href="https://chrome.google.com/webstore/detail/builtwith-technology-prof/dapjbgnjinbpoindlpdmhochffioedbn" target="_blank" rel="external">BuiltWith</a> / <a href="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg" target="_blank" rel="external">wappalyzer</a> / <a href="https://chrome.google.com/webstore/detail/chrome-sniffer-plus/fhhdlnnepfjhlhilgmeepgkhjmhhhjkh" target="_blank" rel="external">Chrome Sniffer Plus</a> - 几款超强的网站分析工具，可以给出网站非常多的技术栈信息。大到 <em>Web Servers</em>、服务端的 <em>Frameworks</em> 或 <em>JS</em> 框架，小到 <em>meta</em>、编码格式甚至 <em>Analytics</em>，非常推荐</li>
<li><a href="https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb/related" target="_blank" rel="external">Adblock Plus</a> - 非常非常有名的免费的过滤广告的插件。PS：广告屏蔽这个见仁见智，其实俺个人还是比较接受一些个性化推荐的广告</li>
<li><a href="https://chrome.google.com/webstore/detail/wide-github/kaalofacklcidaampbokdplbklpeldpj/related" target="_blank" rel="external">Wide Github</a> - 无聊又实用的 <em>Github</em> 插件。无聊是因为这个插件就特么一个功能，<strong>加宽</strong>，能让 <em>Github</em> 页面变宽，每行展示更多的内容，尤其配合着<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="external">Octotree</a>，展示效果极佳。非常推荐 <em>Mac</em> 用户实用，因为屏幕比较不大，变宽后阅读感觉更好</li>
<li><a href="https://chrome.google.com/webstore/detail/google-mail-checker/mihcahmgecmbnbcchbopgniflfhgnkff" target="_blank" rel="external">Gmail</a> - 方便查看自己的 <em>Gmail</em> 邮件</li>
<li><a href="https://chrome.google.com/webstore/detail/devtools-author/egfhcfdfnajldliefpdoaojgahefjhhi" target="_blank" rel="external">DevTools Author</a> - 纯装逼的插件，可以选择你的 <em>Chrome</em> 开发者工具的主题，且支持的主题超过25种，视觉装逼控必备。设置分大概三步，官网有文字说明，<em>youtube</em> 上的视频教程奉上(Customization With DevTools Author)[<a href="https://www.youtube.com/watch?v=AUZagMLMAJc" target="_blank" rel="external">https://www.youtube.com/watch?v=AUZagMLMAJc</a>]</li>
<li><a href="https://chrome.google.com/webstore/detail/porter-plug/lngoojfoglemfpbeiomhgheccpdheilp" target="_blank" rel="external">GitPlug</a> - 在 <em>Github</em> 项目页中嵌入有关的图表信息，直观的展示当前项目的 <em>Star Trend</em>，能方便看到当前这个开源项目的发起时间，火爆趋势；对比较知名的项目还有相关的 <em>News</em> 展示</li>
<li><a href="https://chrome.google.com/webstore/detail/octolinker/jlmafbaeoofdegohdhinkhilhclaklkp" target="_blank" rel="external">OctoLinker</a> - 在 <em>package.json</em> 或任意 <em>.js</em> 文件中，可以方便的对 <em>require()</em> 的 <em>package</em> 进去点击，跳转去对应的 <em>Github</em> 页面。PS：特么不太好表达，建议你去这个插件的概述页，里面有个十来秒的视频，看完就明白鸟</li>
</ul>
<p>补充：</p>
<ol>
<li>翻墙代理的插件偶没使用，偶手机和电脑的翻墙都是配的 <em>Surge</em> 无脑搞定，不过翻墙代理插件推荐<a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm" target="_blank" rel="external">Proxy SwitchySharp</a>，熊掌公司里大多用的都是它</li>
<li>日常开发相关的插件就以上这些，还有几款如知乎的插件、购物插件等这类与开发效率不沾边的，俺就不这上头列了哈</li>
</ol>
<h3 id="git">Git</h3>

<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git 教程-廖雪峰</a> - 俺有看过不少 Git 的文章，确实这个系列是最通俗易懂的</li>
<li><a href="http://github-awards.com/" target="_blank" rel="external">GitAwards</a> - Git 工具，可以查看 Git 排名</li>
<li><a href="https://github.com/flyhigher139/Git-Cheat-Sheet/blob/master/Git%20Cheat%20Sheet-Zh.md" target="_blank" rel="external">Git 速查</a> - 分类清晰的速查表</li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">Git 简明指南</a> - 入门<em>Github</em>的简明指南，木有高深内容:)</li>
<li><a href="https://github.com/xirong/my-git" target="_blank" rel="external">Git 学习资料整理</a>| |内容包括很多 Git 的相关资料，<em>star 1200+</em></li>
<li><a href="https://github.com/phodal/github-roam" target="_blank" rel="external">GitHub 漫游指南</a> - 一篇还算不错的 Git 学习总结，就是乱了点… 我理解作者<strong><em>漫游</em></strong>的意思是漫无目的想到哪写到哪~ 看到作者为鸟达成 Git 连击的成就，也是蛮拼的:)</li>
</ul>
<h3 id="servers">服务端</h3>

<p>如 <em>Ruby、Python、Perl</em> 等相似的服务端语言的学习资源。</p>
<p><em>暂无</em></p>
<h3 id="backend">数据端</h3>

<ul>
<li><a href="https://github.com/Automattic/mongoose" target="_blank" rel="external">Mongoose</a> - 让 NodeJS 更容易操作 Mongodb 数据库。  附上一篇<a href="https://cnodejs.org/topic/504b4924e2b84515770103dd" target="_blank" rel="external">Mongoose 学习参考文档</a></li>
</ul>
<h3 id="ux">设计/交互</h3>

<blockquote>
<p>作为负责最终效果呈现的前端工程师，多少得了解些 <strong>设计和交互</strong> 的，这也是为什么 fetool 会单独的存在这一章…当然话又说回来了，偶毕业的第一份工作是设计:)</p>
</blockquote>
<ul>
<li><a href="http://www.zcool.com.cn/works/" target="_blank" rel="external">站酷</a> - 里面好东西太多，俺当年真没少再上面淘素材</li>
<li><a href="http://www.ui.cn/list.html" target="_blank" rel="external">UI中国</a> - 光听名字就知道有多高大上鸟:)</li>
</ul>
<h3 id="handbook">速查手册</h3>

<blockquote>
<p>RT，这篇都是些文档或者API，一般这类东西都在大家浏览器的书签内，偶这也列一下大前端常用的手册地址</p>
</blockquote>
<ul>
<li><a href="https://github.com/joshbuchea/HEAD" target="_blank" rel="external">HEAD</a> - 最全的 <em><head></head></em> 列表，真心佩服这种偏执的整理能力</li>
<li><a href="http://cdn.code.baidu.com/" target="_blank" rel="external">百度CDN公共库</a> - 基本常见的库都收录拉，搞 demo 的时候特方便</li>
<li><a href="http://codeguide.bootcss.com/" target="_blank" rel="external">HTML 和 CSS 代码规范</a> - 编写灵活、稳定、高质量的 HTML 和 CSS 代码的规范</li>
<li><a href="http://linux.51yip.com" target="_blank" rel="external">Linux命令中文手册</a> - 木有系统的好好学习 Linux，所以命令更不熟悉 真羡慕那些CLI玩的飞起的:)</li>
<li><a href="https://github.com/flyhigher139/Git-Cheat-Sheet/blob/master/Git%20Cheat%20Sheet-Zh.md" target="_blank" rel="external">Git 速查</a> - 分类清晰的速查表</li>
<li><a href="http://jquery.cuishifeng.cn/" target="_blank" rel="external">jQueryAPI 1.11.3</a> - ZeptoAPI 基本和 jQuery 一样，所以看一份就好</li>
<li><a href="http://www.php100.com/manual/css3_0/index.html" target="_blank" rel="external">CSS3</a> - CSS3 的在线手册</li>
<li><a href="http://www.expressjs.com.cn/4x/api.html" target="_blank" rel="external">Express API</a> - 中文手册:) 4.x和3.x都有</li>
<li><a href="http://codeigniter.org.cn/user_guide/index.html" target="_blank" rel="external">CI用户指南</a> - 一个轻量级的 PHP 框架用户指南 推荐指数低的原因是劳资PHP比较弱，囧</li>
<li><a href="http://www.laruence.com/manual/" target="_blank" rel="external">Yaf</a> - 鸟哥(惠新宸)所写的 PHP 框架 推荐指数低的原因同上…</li>
</ul>
<h3 id="other">杂七杂八</h3>

<blockquote>
<p>放些开发中较有用的杂物在这儿</p>
</blockquote>
<ul>
<li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="external">提問的智慧</a> - RT，<a href="https://github.com/FredWe/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md" target="_blank" rel="external">简体版</a>。“當你拋出一個技術問題時，最終是否能得到有用的回答，往往取決於你所提問和追問的方式。本指南將教你如何正確的提問以獲得你滿意的答案。”——摘自原文</li>
<li><a href="https://github.com/soulteary/tenant-point" target="_blank" rel="external">租房要点</a> - 适用于北上广深杭，大城市打拼<strong>租房</strong>确实是硬伤</li>
<li><a href="https://github.com/jsfront/src/blob/master/qq.md" target="_blank" rel="external">QQ 群规</a> - 突然某天，有个 QQ 群让我加群 原本我是拒绝的，但当我看完这篇 QQ 群规后… 劳资真的被感动到了，太牛逼、够专业！ 最后，我默默加群鸟:)</li>
<li><a href="https://github.com/github/gitignore" target="_blank" rel="external">.gitignore 文件</a> - 介绍不同语言项目的 gitignore 模板</li>
<li><a href="https://github.com/easychen/howto-make-more-money" target="_blank" rel="external">程序员如何优雅的挣零花钱？</a> - 中肯的文章，如果读完能有些许收获，那么恭喜你</li>
<li><a href="https://github.com/ben174/git-draw" target="_blank" rel="external">git-draw</a> - 黑魔法，可以修改自己 Git 上的 Contributions</li>
<li><a href="https://www.gitbook.com" target="_blank" rel="external">GitBook</a> - 写记录的好地方</li>
<li><a href="https://codebabes.com/" target="_blank" rel="external">Codebabes</a> - 学编程的网站。 重点是每通过一个测试，尼玛对应的妞会脱一件衣服… PS：要翻墙哦~</li>
<li><a href="http://emailframe.work/" target="_blank" rel="external">emailframe</a> - 邮件展示确实比较坑，建议有需要的收藏</li>
<li><a href="https://github.com/nieweidong/ReadmeSample" target="_blank" rel="external">ReadmeSample</a>| |项目高大上的第一步就是<strong>包装</strong>，所以来看看 <em>README</em> 的书写套路吧 PS：劳资怎么这么无聊…</li>
</ul>
<h3 id="cool">前端炫技-<em>炫酷狂拽叼炸天站点</em></h3>

<ul>
<li><a href="http://www.windows93.net/" target="_blank" rel="external">windows93</a> - 模拟 Win93 桌面，思路、体验和整体效果比较有意思</li>
<li><a href="http://geektyper.com/" target="_blank" rel="external">GeekTyper</a> - 好玩又具有 Geek 精神的网站，虽然创建的目的是个恶作剧 PS：网站需要翻墙</li>
<li><a href="http://2016.makemepulse.com/" target="_blank" rel="external">2016.makemepulse.com</a> - 帅哭了。请使用现代浏览器打开</li>
<li><a href="http://skill.phodal.com/" target="_blank" rel="external">前端技能栈</a> - 好玩的前端技能栈展示</li>
<li><a href="https://www.mapbox.com/" target="_blank" rel="external">Mapbox</a> - 非常叼的开源项目，有方便的 JSAPI(还有 SDK)。 不过免费版只能浅尝，流量有限。 PS：网站需要翻墙</li>
<li><a href="http://www.clarkduvall.com/" target="_blank" rel="external">Clark Duvall</a> - 一枚歪果仁的个人 blog，范儿叼叼的</li>
<li><a href="http://johnpolacek.github.io/superscrollorama/" target="_blank" rel="external">SuperScrollorama</a> - 好玩好看的动画库，链接是 SuperScrollorama 的展示页</li>
<li><a href="http://matthew.wagerfield.com/parallax/" target="_blank" rel="external">parallax.js</a> - 一个视差引擎的官网，在电脑和手机上都有很好的体验</li>
<li><a href="http://yusugomori.com/projects/css-sans/fonts" target="_blank" rel="external">CSS字母</a> - 用 CSS 实现英文字母，叼叼的</li>
<li><a href="https://modao.cc/" target="_blank" rel="external">墨刀</a> - 一个在线移动应用原型制作工具。 旨在帮助产品经理快速制作可在手机端展示的移动应用原型。</li>
</ul>
<h3 id="summary">小结</h3>

<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>  俺算个比较能自我总结的码农，所以偶尔喜欢写点东西做些记录或者自我熏陶陶醉一下。<br>  可写着写着发现<em>Evernote</em>里面的东西太尼玛多(乱)了，于是想着把一些技术相关的资料都整理整理，都丢到<em>Github</em>上沉淀下来。 这样Evernote就可以只需要记录些偏生活方便的，看着清爽一些…</p>
<p>  所以，这篇记录其实只是为偶自己而写，确信以后也一直会这样~~~</p>
<h5 id="说说目标"><a href="#说说目标" class="headerlink" title="说说目标"></a>说说目标</h5><p>  其实与这篇记录类似的文章太多鸟，俺也不愿意成为一个单纯的收集资料，分享资料的这么个东西。<br>  我希望 fetool 能更生动、更个性，最好能更另类点，对于每样工具的思考和解析更多点，吐槽也必须有理有据，然后再配上劳资收集的 low 图，完美！<br>  <strong>希望通过不停的完善这篇记录，能Push劳资多了解业内的新玩具和新创意，然后围绕这些新东西，客观的再写点好东西，比如文章、资料、开源项目这些，让其他伙伴们少走弯路或学的更顺畅点儿</strong></p>
<blockquote>
<p>所以劳资对自己的要求是：这篇记录里列出的每样东西，自己都得的去了解、去尝试，然后再列出来。 能举一反三最好，如果达不到至少也能清楚的认识：列出来的这玩意对程序员有没有卵用，解决了啥痛点。</p>
</blockquote>
<h3 id="todo">TODO</h3>

<ol>
<li><p>继续完善和扩充内容</p>
</li>
<li><p>“备注/说明”这一栏不够犀利，希望再多加入自己的理解、点评、吐槽，让这篇记录更犀利和生动</p>
</li>
<li><p>支持导出多种格式，如<em>.pdf</em>、<em>.epub</em>、<em>.mobi</em>等</p>
</li>
<li><p>后续看看如果有必要，可以单独搞个页面，优化下阅读和展示效果</p>
</li>
</ol>
<hr>
<p>以下是 <a href="http://weibo.com/jayli" target="_blank" rel="external">@拔赤</a> 总结的前端技能图：<br><img src="https://raw.githubusercontent.com/nieweidong/fetool/master/img/fe.jpg" alt="拔赤总结的前端技能图"></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端工程构建乱弹]]></title>
      <url>http://hangweiping.github.io/2016/01/02/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA%E4%B9%B1%E5%BC%B9/</url>
      <content type="html"><![CDATA[<blockquote>
<p>webpack是一个比browserify功能更强大的模块加载器。既然是模块加载器，当然就包括对各种各样模块的加载，包括SASS/LESS/CoffeeScript/png/jpg等，以及webpack对于node_module模块加载已经非常完善了。<br>那么，为什么还需要bower呢？由于前端开发很多第三方模块并非都以标准npm包形式存在，有一些非主流，或者各种原因没放到npm上的包，可以在bower找到。<br>基于这个原因，使用webpack时候，凭着能用npm就用（依赖加载更加方便，功能更加强大），不能用的时候使用bower声明第三方模块依赖，然后使用js/css加载方式进行加载。<br>值得一提的是，webpack官方也提供非常便利的方式加载bower模块（模块的主要文件，被声明在bower.json main属性里面）,通过配置后就可以很方便地沿用require来加载bower模块。</p>
</blockquote>
<a id="more"></a>
<p><strong>按需决定是否需要bower</strong></p>
<p>Yeamon帮助你快速的开展一个项目工程，提供最佳实践和工具，来让你保持高效率编码。</p>
<p>他们自己提供了一个构建生态系统，主要通过‘yo’这个命令来构建一个完整的项目或者项目的一部分。</p>
<p>通过官方的生成器，他们建立了一个Yeoman的工作流，这个流是由一个强大的,固定的客户端组建，包含工具和框架帮助开发者快速建立牛逼的web应用。他们尽量提供了开发者所需的东西。</p>
<p>作为良好文档和深入思考构建过程的思想者，Yeoman包含了检测（静态检测）、测试以及压缩等等一系列工具，让开发者能够更加专注于思考解决方案。</p>
<p>Yeoman其实是3个工具的总和：  </p>
<ul>
<li>yo — 脚手架，自动生成工具</li>
<li>Grunt、gulp — 构建工具 （最初只有grunt，后面gulp火了添加进来的）</li>
<li>Bower、npm — 包管理工具 （原来是 bower，后面添加了npm）  </li>
</ul>
<blockquote>
<p>gulp是工具链，可以配合各种插件做js压缩，css压缩，less编译等工作<br>webpack是文件打包工具，可以把项目的各种js文、css文件等打包合并成一个或多个文件<br>bower是包管理器，用来管理你项目里的那些外部依赖的。  </p>
</blockquote>
<p>上面的三个是各自独立发展和运行的，混合后效果就不一样，主要在于yo，相当于一个粘合剂一样，把grunt这些工具粘合在一起。</p>
<p>我们可以看到的是，几个简单的命令，Yeoman就帮助我们建立一个项目，而且项目已经填充了不少代码，我们可以选择一个自己喜欢的，来沿着别人的已经搭建好的构架来编写业务即可，这对很多新手来说是非常好的一种提高方式，所以建议大家选star多的 —代码风格好，文件夹规划清晰，js的模块拆分细致合理。  </p>
<hr>
<p>bower已經過時了，npm足矣。如果用WebPack就不需要Gulp和Browserify，用Redux就不需要其他Flux框架，精簡下React+Redux+WebPack。另外ES6和Babel其實少不了要了解下的.</p>
<p>一个package同时存在多个版本了，下面是 @sheerun 给出的解决方案（修改项目根目录的bower.json文件内的dependencies即可）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"font-awesome"</span>: <span class="string">"~4.2.0"</span>,</div><div class="line">    <span class="attr">"font-awesome-old"</span>: <span class="string">"font-awesome#3.2.1"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后来又仔细的查看了bower官方文档，发现里面已经有了对应的安装方法，可能是我以前没注意到， 官方安装方法(英文) ，下面我把常用的几种安装方法说一下：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 基于bower.json安装</div><div class="line">#基于bower.json安装</div><div class="line">bower install <span class="meta">[&lt;options&gt;]</span></div><div class="line"><span class="number">2.</span> 安装指定的package， 比如一次性安装jquery, bootstrap, underscore：</div><div class="line"># jquery, bootstrap, underscore</div><div class="line">bower install jquery bootstrap underscore <span class="meta">[&lt;options&gt;]</span></div><div class="line"><span class="number">3.</span> 安装指定版本的package, 比如安装jquery v1<span class="number">.9</span><span class="number">.0</span>:</div><div class="line">#安装jquery v1<span class="number">.9</span><span class="number">.0</span></div><div class="line">bower install jquery#<span class="number">1.9</span><span class="number">.0</span> <span class="meta">[&lt;options&gt;]</span></div><div class="line"><span class="number">4.</span> 同时安装一个package的不同版本（多版本共存）, 比如安装jquery v1<span class="number">.7</span><span class="number">.0</span>，并且安装v1<span class="number">.9</span><span class="number">.1</span>以及最新版本的jquery（目前是<span class="number">2.1</span><span class="number">.1</span>）， 像下面这样安装完成后，你的bower_components目录下就会同时存在jquery-older目录(<span class="number">1.7</span><span class="number">.0</span>)， jquery-old目录（<span class="number">1.9</span><span class="number">.1</span>）, jquery目录（最新版）。</div><div class="line"># 安装jquery v1<span class="number">.7</span><span class="number">.0</span></div><div class="line">bower install jquery-older=juqery#<span class="number">1.7</span><span class="number">.0</span> <span class="meta">[&lt;options&gt;]</span></div><div class="line"># 安装jquery v1<span class="number">.9</span><span class="number">.0</span></div><div class="line">bower install jquery-old=juqery#<span class="number">1.9</span><span class="number">.1</span> <span class="meta">[&lt;options&gt;]</span></div><div class="line"># 安装最新版jquery</div><div class="line">bower install jquery <span class="meta">[&lt;options&gt;]</span></div></pre></td></tr></table></figure></p>
<p>上面的脚本中的安装选项<options>有以下几个可选项( 官方说明 )：</options></p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">F, --force-latest <span class="comment"># 安装时若有冲突则强制安装最新版；</span></span></div><div class="line">-<span class="ruby">p, --production <span class="comment"># 不要安装开发依赖的package（一般用于生产环境）；</span></span></div><div class="line">-<span class="ruby">S, --save <span class="comment"># 安装完成后将此package记录在bower.json文件的dependencies项中；</span></span></div><div class="line">-<span class="ruby">D, --save-dev <span class="comment"># 安装完成后将此package记录在bower.json文件的devDependencies项中(一般用于开发环境)；</span></span></div></pre></td></tr></table></figure>
<p>webpack可以理解为专门针对前端代码打包的集成方案, gulp可以做到webpack做的, 但webpack做不到gulp能做的. webpack只是针对前端代码的, 例如前端代码的合并,压缩, 把ES6代码转成ES3代码, sass转css等.<br>gulp 还可以对node 的服务器端的程序做处理,例如批量生成文件, 运行启动服务等等.<br>至于选择哪个一般看个人喜好和项目要求, 一般react的项目用webpack比较多,其他的项目用gulp比较多.<br>webpack是静态资源打包工具，grunt和gulp是自动化构建工具，grunt和gulp二选一就可以，用gulp的比较多，gulp可以和webpack搭配使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[7大查找算法]]></title>
      <url>http://hangweiping.github.io/2015/01/01/7%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<ol>
<li>顺序查找 2. 二分查找 3. 插值查找 4. 斐波那契查找 5. 树表查找 6. 分块查找 7. 哈希查找</li>
</ol>
</blockquote>
<p>　　查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。树表查找和哈希查找会在后续的博文中进行详细介绍。</p>
<a id="more"></a>
<p>　　查找定义：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>
<p>　　查找算法分类：<br>　　1）静态查找和动态查找；<br>　　　　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。<br>　　2）无序查找和有序查找。<br>　　　　无序查找：被查找数列有序无序均可；<br>　　　　有序查找：被查找数列必须为有序数列。<br>　　平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。<br>　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。<br>　　Pi：查找表中第i个数据元素的概率。<br>　　Ci：找到第i个数据元素时已经比较过的次数。  </p>
<ol>
<li>顺序查找<br>　　说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。<br>　　基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。<br>　　复杂度分析：  　<br>　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;<br>　　当查找不成功时，需要n+1次比较，时间复杂度为O(n);<br>　　所以，顺序查找的时间复杂度为O(n)。    </li>
<li>二分查找<br>　　说明：元素必须是有序的，如果是无序的则要先进行排序操作。<br>　　基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。<br>　　复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；<br>　　注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》  
　</li>
<li>插值查找  </li>
</ol>
<p>　　在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？<br>　　打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。<br>　　同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。<br>　　经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：  </p>
<p>　　mid=(low+high)/2, 即mid=low+1/2<em>(high-low);<br>　　通过类比，我们可以将查找的点改进为如下：<br>　　mid=low+(key-a[low])/(a[high]-a[low])\</em>(high-low);  </p>
<p>　　也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。<br>　　基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。<br>　　注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。<br>　　复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。    </p>
<ol>
<li>斐波那契查找  </li>
</ol>
<p>　　在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。<br>　　黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。<br>　　0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。<br>　　大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。  </p>
<p>　　基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。<br>　　相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：<br>　　1）相等，mid位置的元素即为所求<br>　　2）&gt;，low=mid+1;<br>   3）&lt;，high=mid-1。<br>　　斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;<br> 开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种<br>　　1）相等，mid位置的元素即为所求<br>　　2）&gt;，low=mid+1,k-=2;<br>　　说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。<br>　　3）&lt;，high=mid-1,k-=1。<br>　　说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归的应用斐波那契查找。<br>　　复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。  
　</p>
<ol>
<li><p>树表查找<br>　　5.1 最简单的树表查找算法——二叉树查找算法。<br>　　基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。<br>　　二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：<br>　　1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>　　2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>　　3）任意节点的左、右子树也分别为二叉查找树。<br>　　二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。<br>　　不同形态的二叉查找树如下图所示：</p>
<p>　　复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。<br>　　下图为二叉树查找和顺序查找以及二分查找性能的对比图：</p>
</li>
</ol>
<p>　　基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。<br>　　5.2 平衡查找树之2-3查找树（2-3 Tree）<br>　　2-3查找树定义：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：<br>　　1）要么为空，要么：<br>　　2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。<br>　　3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。<br>Definition of 2-3 tree<br>　　2-3查找树的性质：<br>　　1）如果中序遍历2-3查找树，就可以得到排好序的序列；<br>　　2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）<br>　　性质2）如下图所示：  </p>
<p>　　复杂度分析：<br>　　2-3树的查找效率与树的高度是息息相关的。<br>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN<br>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN<br>　　距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。<br>　　对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率：<br>analysis of 2-3 tree  </p>
<p>　　5.3 平衡查找树之红黑树（Red-Black Tree）<br>　　2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。<br>　　基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。<br>Red black tree<br>　　红黑树的定义：<br>　　红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：<br>红色节点向左倾斜<br>一个节点不可能有两个红色链接<br>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。<br>　　下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。<br>1-1 correspondence between 2-3 and LLRB<br>　　红黑树的性质：整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。<br>　　复杂度分析：最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。<br>　　下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：<br>a typic red black tree<br>　　红黑树的平均高度大约为logn。<br>　　下图是红黑树在各种情况下的时间复杂度，可以看出红黑树是2-3查找树的一种实现，它能保证最坏情况下仍然具有对数的时间复杂度。  </p>
<p>　　红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：<br>Java中的java.util.TreeMap,java.util.TreeSet；<br>C++ STL中的：map,multimap,multiset；<br>.NET中的：SortedDictionary,SortedSet 等。<br>　　5.4 B树和B+树（B Tree/B+ Tree）<br>　　平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。<br>　　维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。<br>　　B树定义：<br>　　B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。<br>根节点至少有两个子节点<br>每个节点有M-1个key，并且以升序排列<br>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间<br>其它节点至少有M/2个子节点<br>　　下图是一个M=4 阶的B树:  </p>
<p>　　可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。<br>　　B+树定义：<br>　　B+树是对B树的一种变形树，它与B树的差异在于：<br>有k个子结点的结点必然有k个关键码；<br>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。<br>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。<br>　<br>　　B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。<br>　　B+ 树的优点在于：<br>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。<br>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。<br>　　但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。<br>　　下面是B 树和B+树的区别图：<br>Different between B tree and B plus tree<br>　　B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如：<br>Windows：HPFS文件系统；<br>Mac：HFS，HFS+文件系统；<br>Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；<br>数据库：ORACLE，MYSQL，SQLSERVER等中。<br>　　树表查找总结：<br>　　二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。<br>　　除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。  </p>
<ol>
<li><p>分块查找<br>　　分块查找又称索引顺序查找，它是顺序查找的一种改进方法。<br>　　算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……<br>　　算法流程：<br>　　step1 先选取各块中的最大关键字构成一个索引表；<br>　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。  </p>
</li>
<li><p>哈希查找<br>　　什么是哈希表（Hash）？<br>　　我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。<br>　　总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。<br>　　什么是哈希函数？<br>　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。<br>　　算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。<br>　　算法流程：<br>　　1）用给定的哈希函数构造哈希表；<br>　　2）根据选择的冲突处理方法解决地址冲突；<br>　　　　常见的解决冲突的方法：拉链法和线性探测法。<br>　　3）在哈希表的基础上执行哈希查找。<br>　　哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。<br>　　复杂度分析：<br>　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。<br>　　使用Hash，我们付出了什么？<br>　　我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？<br>　　Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。  </p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[css文本和字体]]></title>
      <url>http://hangweiping.github.io/2014/12/30/css%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E4%BD%93/</url>
      <content type="html"><![CDATA[<p>字体是“文字的不同体式”或者“字的形体结构”。对于英文而言，每种字体都是由一组具有独特样式的字母、数字和符号组成的。根据外观，字体可以分为不同的类别（font collection），包括衬线字体（serif）、无衬线字体（sans-serif）和等宽字体（monospace）。每一类字体可以分成不同的字体族（font family），比如 Times 和 Helvetica。而字体族中又可以包含不同的字型（font face），反映了相应字体族基本设计的不同变化，例如 Times Roman、 Times Bold、 Helvetica Condensed 和 Bodoni italic。CSS字体属性主要描述一类字体的大小和外观，比如：使用什么字体族（是 Times，还是 Helvitica），多大字号，粗体还是斜体。</p>
<a id="more"></a>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">font</span>-maily：字体簇</div><div class="line"><span class="built_in">font</span>-<span class="built_in">size</span>：字体大小</div><div class="line"><span class="built_in">font</span>-weight：字体粗细</div><div class="line"><span class="built_in">font</span>-style：字体样式</div><div class="line"><span class="built_in">font</span>-<span class="built_in">variant</span>：字体变化</div><div class="line"><span class="built_in">font</span>：字体简写</div><div class="line">字体簇</div></pre></td></tr></table></figure>
<p>font-family 用于设定元素中的文本使用什么字体，具体用法参考 font-family ，其常见应用和问题如下：</p>
<h3 id="字体来源"><a href="#字体来源" class="headerlink" title="字体来源"></a>字体来源</h3><p>用户机器中安装的字体；<br>保存在第三方网站上的字体，如：Typeket和Google Fonts<br>保存在自身Web服务器上的字体，这些字体通过@font-face引入；  </p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>font-family是可以继承的属性，因此它的值会遗传给所有后代元素。在实际应用font-family的时候，应该给整个页面设定一种主字体，然后只对那些需要使用不同字体的元素再应用 font-family。要为整个页面指定字体，可以设定 body 元素的 font-family 属性。  </p>
<h3 id="字体栈"><a href="#字体栈" class="headerlink" title="字体栈"></a>字体栈</h3><p>每种操作系统自带的字体不多，而且用户随时会安装和删除字体，因此不敢保证一定能应用某种字体来显示网页。为此，在指定文本的字体时，需要多列出几种后备字体，以防第一种字体无效。这个列表也叫字体栈，例如： body {font-family:”trebuchet ms”, tahoma, sans-serif;} 。注意，字体栈的最后一项要指定一个通用的字体类，如： sans-serif 。通用的字体类有：<br>serif：衬线字体，字符笔画的末端会有一些装饰线；<br>sans-serif：无衬线字体，字符笔画的末端没有装饰线；<br>monospace：等宽字体，每个字符的宽度相等（也称代码体）；<br>cursive：草书体或手写体；<br>fantasy：不能归入其他类别的字体（一般都是奇形怪状的字体）。  </p>
<h3 id="字体搭配"><a href="#字体搭配" class="headerlink" title="字体搭配"></a>字体搭配</h3><p>常见搭配<br>verdana, tahoma, sans-serif<br>helvetica, arial, sans-serif</p>
<p>如果字体名像 Trebuchet MS 一样多于一个单词（有空格），应该加上引号<br>font-family 的值（字体名）不区分大小写</p>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p>浏览器样式表默认为每个 HTML 元素都设定了 font-size，因此你在设定 font-size 的时候，其实是在修改默认值。由于字体大小在标记层次中是可以继承的，假如你对使用的字体大小单位怎么影响继承不十分了解，那很容易碰到有些字体莫名其妙变大或变小的问题。字体的具体用法可以参考 font-size ，常见应用和问题如下：</p>
<p>字体大小的默认值：16px<br>绝对单位 VS 相对单位</p>
<ul>
<li>绝对单位：<br>简介：使用像素、派卡（pica）或英寸设定字体大小，另外<br>优点：实际字体设定多大就多大，与祖先元素的字体大小无关。<br>缺点：在需要调整页面所有元素的字体大小时，必须一个一个地修改样式表中的 font-size，相当麻烦。<br>其他：设定绝对字体大小时，也可以使用关键字值，比如：x-small、medium、x-large等。具体可参考 Using_Keywords</li>
<li>相对单位<br>简介：使用百分比、 em 或 rem（根元素的字体大小）设定字体大小。<br>优点：使用相对大小后，通过调整 body 元素的字体大小，可以成比例地改变所有元素的字体大小。或者，至少能通过改变某个祖先元素，只影响它的所有子元素。在反复修改布局设计的时候，这样显然能节省时间<br>缺点：可能会出现意外的“连锁反应”<br>其他：设定相对字体大小时，也可以使用关键字值，比如：smaller、larger。</li>
<li>使用rem<br>简介：rem(root em)是CSS3新增的字体大小单位，也是相对单位，但rem是相对于HTML根元素的单位。<br>优点：既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。<br>缺点：存在浏览器兼容性问题，除了 IE8 及更早版本外，所有浏览器均已支持rem。<br>实际应用：对于不支持它的浏览器，需要多写一个绝对单位的声明，例如： p {font-size:14px; font-size:.875rem;}<br>浏览器缩放与字体大小调整对字体大小的影响<br>浏览器缩放：整体调整<br>字体大小调整：相对单位调整，绝对单位不变</li>
</ul>
<h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><p>字体样式默认是正体，也可以是斜体，具体用法参考 font-style 。在实际应用中，英文中的斜体主要表示强调，如果是为了表示强调设置font-style，那么在在 HTML 标记中直接使用 <em> 标签即可。</em></p>
<h3 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h3><p>字体粗体的主要作用是表示重要，具体用法参考 font-weight 。<br>在实际应用中，由于浏览器对font-weight的数字值实现各不相同，所以从常规字体到粗体的切换可能发生在不同的数值上——通常是 400。所以，对于font-weight属性来说，最好只用 bold 和 normal 这两个值。<br>此外，HTML 元素 strong 也表示重要，而它的默样式就是粗体，如果要突出文本中的某一个字或次，请使用strong。  </p>
<h3 id="字体变化"><a href="#字体变化" class="headerlink" title="字体变化"></a>字体变化</h3><p>font-variant属性除了normal，就只有一个值，即 small-caps——导致所有小写英文字母变成小型大写字母，具体用法请参考 font-variant</p>
<h3 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h3><p>font 属性是一个简写形式，通过它只要一条 CSS 声明就可以设定所有字体属性，例如： p {font: bold italic small-caps .9em helvetica, arial, sans-serif;} 。具体规则如下：</p>
<p>必须声明 font-size 和 font-family 的值<br>所有值必须按如下顺序声明：<br>font-weight、 font-style、 font-variant 不分先后；<br>然后是 font-size；<br>然后是 font-size；<br>font属性除了用于字体属性的简写外，还可以给它指定一些特殊的值，如下所示：</p>
<p>caption：使用有标题的系统控件的文本字体（如按钮，菜单等）（CSS2）<br>icon：使用图标标签的字体（CSS2）<br>menu：使用菜单的字体（CSS2）<br>message-box：使用信息对话框的文本字体（CSS2）<br>small-caption：使用小控件的字体（CSS2）<br>status-bar：使用窗口状态栏的字体（CSS2）</p>
<p>font<br>其他属性</p>
<p>font-stretch<br>font-size-adjust</p>
<h2 id="Web字体"><a href="#Web字体" class="headerlink" title="Web字体"></a>Web字体</h2><p>Web字体指的是非用户机器中的字体。目前，可以通过使用@font-face规则在网页中嵌入Web字体，并且该功能已经得到了浏览器广泛支持。设定Web字体的方式如下所示：<br>使用Google Web Fonts或Adobe的Typekit等公共字体<br>以Google Web Fonts为例，访问 <a href="https://www.google.com/fonts" target="_blank" rel="external">https://www.google.com/fonts</a> ，找到想要的字体，单击“Add To Collection”，然后单击页面底部的 Use 按钮。Google 就会生成一个指向刚刚选定字体的 <link> 标签，直接把它复制粘贴到你的 HTML 文件中即可。例如： <link href="https://fonts.googleapis.com/css?family=Open+Sans|Roboto" rel="stylesheet" type="text/css"> ，在CSS中引用下载的字体： font-family: ‘Open Sans’, Roboto, sans-serif;</p>
<p>使用@font-face规则使用@font-face规则的前提是可以从网站或第三方Web服务器下载到相应的字体包，以这种方式提供的字体，会在使用该字体的页面第一次加载时被浏览器下载并缓存起来，以后就不用下载了。使用@font-face的一个问题是不同的浏览器要求的字体格式不同，具体如下所示：</p>
<p>Firefox/Safari/Chrome/IOS Safari4.1以上版本：OTF——OpeType，TTF——TrueType；<br>IE：EOT——Embedded Open Type；<br>IOS Safari4.1之前版本：SVG——Scalable Vector Graphics；<br>Font Squirrel 提供了很多现成的字体包，每个字体包中都包含所有必要格式的字体和为每款浏览器提供正确格式的 CSS 代码。另外，Font Squirrel还有一个转换程序，能够把你上传的字体转换成字体包。下面就是 Font Squirrel 为 Ubuntu Titling Bold 字体生成的@font-face 代码。对于其他来源的字体，这种格式也是适用的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span> &#123;</div><div class="line">  <span class="comment">/*这就是将来在字体栈中引用的字体族的名字*/</span></div><div class="line">  <span class="attribute">font-family</span>:<span class="string">'UbuntuTitlingBold'</span>;</div><div class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'UbuntuTitling-Bold-webfont.eot'</span>);</div><div class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'UbuntuTitling-Bold-webfont.eot?#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>),</div><div class="line">    <span class="built_in">url</span>(<span class="string">'UbuntuTitling-Bold-webfont.woff'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</div><div class="line">    <span class="built_in">url</span>(<span class="string">'UbuntuTitling-Bold-webfont.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),</div><div class="line">    <span class="built_in">url</span>(<span class="string">'UbuntuTitling-Bold-webfont.svg#UbuntuTitlingBold'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);</div><div class="line">  <span class="attribute">font-weight</span>: normal;</div><div class="line">  <span class="attribute">font-style</span>: normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Web字体的其他问题：</p>
<p>Web字体可能导致机器中出现同名字体，以至混淆。为此，Web专家Paul Irish写过一个跨跨浏览器@font-face 的“笑脸版”，详细内容请参考 bulletproof-font-face-implementation-syntax ；<br>需要深入入了解@font-face规则的话，可以参考 How to use @font-face ；<br>除非浏览器统一支持一种字体格式，否则必须面对多种字体格式并存问题。如何使用@font-face规则处理多种字体格式，以及保证Internet Explorer取得必要的.eot格式的字体，可以参考 fixing-ie9-font-face-problems 。</p>
<h2 id="文本是什么"><a href="#文本是什么" class="headerlink" title="文本是什么"></a>文本是什么</h2><p>文本就是一组字或字符，比如章标题、段落正文等等，跟使用什么字体无关。CSS文本属性描述对文本的处理方式，比如：行高或者字符间距多大，有没有下划线和缩进。常用的CSS文本属性如下所示：</p>
<p>text-indent<br>letter-spacing<br>word-spacing<br>text-decoration<br>text-align<br>line-height<br>text-transform<br>vertical-align</p>
<h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><p>text-indent属性设定行内盒子相对于包含元素的起点，具体用法参考 text-indent ，常见问题和注意点如下：</p>
<h3 id="行内盒子"><a href="#行内盒子" class="headerlink" title="行内盒子"></a>行内盒子</h3><p>CSS 会把元素中的文本放在一个不可见的盒子里，比如对 p 元素中的一段文本，CSS 将其视为很长的一行，只不过在遇到容器边界时会折行。例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">border</span>:<span class="number">3px</span> solid red;&#125;</div><div class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid green;&#125;</div><div class="line">&lt;p&gt;&lt;span&gt;Here is <span class="selector-tag">a</span> long paragraph…&lt;/span&gt;&lt;/p&gt;</div></pre></td></tr></table></figure>
<p>总结：实际上缩进的是这个文本盒子的起点位置，后续的行是不会缩进的。如果需要缩进整个段落，可以使用margin或padding。</p>
<p>text-indent适用于块容器，包含inline-block；</p>
<p>text-indent是可继承的，且子元素获得的继承值并不是祖先元素设定的值，而是计算的值。示例代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.root</span> &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;    </div><div class="line">    <span class="attribute">text-indent</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.root</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">span</span> &#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">&#125;</div><div class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"root"</span>&gt;</div><div class="line">    &lt;span&gt;行内儿子节点&lt;/span&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;span&gt;行内块级孙子节点&lt;/span&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>总结：这里没有使用百分比，所以子元素的继承值都是30px。但需要注意示例中的前后两个span，后一个span的缩进较前一个span较大，这是由于后一个span是行内块元素，继承的缩进值起作用了。</p>
<p>text-indent允许设定负值，注意配合padding或margin；  </p>
<h3 id="字符间距"><a href="#字符间距" class="headerlink" title="字符间距"></a>字符间距</h3><p>letter-spacing为正值时增大字符间距，为负值时缩小间距。无论设定字体大小时使用的是什么单位，设定字符间距一定要用相对单位，以便字间距能随字体大小同比例变化。具体用法请参考[letter-spacing]。( <a href="http://css.doyoe.com/properties/text/letter-spacing.htm" target="_blank" rel="external">http://css.doyoe.com/properties/text/letter-spacing.htm</a> )</p>
<h3 id="单词间距"><a href="#单词间距" class="headerlink" title="单词间距"></a>单词间距</h3><p>CSS把任何两边有空白的字符和字符串都视作“单词”，纯汉字文本一段之中没有空格，因此单词间距对中文网页几乎没有用，但对中英混排段落可能有用。单词间距属性具体用法请参考 word-spacing 。</p>
<h3 id="文本装饰"><a href="#文本装饰" class="headerlink" title="文本装饰"></a>文本装饰</h3><p>文本装饰有下划线、上划线、贯串线和闪烁等样式，具体用法可参考 text-decoration</p>
<h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h3><p>一般文本对齐方式有：左对齐/left、右对齐/right、居中对齐/center，以及两端对齐/justify，其中两端对齐是CSS3新增的属性。除此之外，CSS3还定义了一些额外的属性，但浏览器都不怎么支持，具体内容请参考 text-align 。</p>
<p>在实际应用中，如果对元素设置了文本对齐属性，而对子元素是如何显示存在疑惑时，只要根据一下规则去计算即可：</p>
<p>文本对齐属性只适用于块容器（包含行内块元素）；<br>文本对齐属性是可继承的<br>如果没有子元素，则文本内容直接根据父元素定义的对齐属性在父元素盒子里显示；<br>如果子元素是行内非块元素，将其当做文本内容处理（虽然该子元素会继承对齐属性，但是该属性不适用于行内非块元素）；<br>如果子元素是行内块元素，则该元素会按照父元素的文本对齐属性在父元素盒子里显示。此外，该元素会继承父元素的对齐属性，按照以上规则处理其子元素<br>如果子元素非行内块元素，则该元素会继承父元素的对齐属性，然后继续按照以上规则处理子元素；<br>行高</p>
<p>CSS 中的行高平均分布在一行文本的上方和下方，具体用法参考 line-height 。常见问题和注意点如下：</p>
<p>适用于所有元素，且可继承；<br>行高小于字体大小时，行与行之间会出现重叠；<br>实际应用时，要使用相对单位（百分比或乘积因子），避免使用绝对单位（如像素）——字体增大时，可能会出现行与行的重叠；<br>font快捷属性：以复合值的形式把 font-size 和 line-height 值写在一块，例如 div#intro {font:1.2em/1.4 helvetica, arial, sans-serif;} ；<br>文本行高为normal不代表就是1倍于字体大小<br>文本转换</p>
<p>文本转换属性用于转换元素中文本的大小写，它可以设定英文文本首字母大写、全部字母大写和全部字母小写。具体用法可参考 text-transform 。</p>
<h3 id="垂直对齐"><a href="#垂直对齐" class="headerlink" title="垂直对齐"></a>垂直对齐</h3><p>垂直对齐属性 vertical-align 以基线为参照上下移动文本， 具体用法参考 vertical-align 。常见问题和注意点：<br>垂直对齐属性只适用于行内元素；<br>HTML标签 <sup> 和 <sub> 有默认的上标和下标样式，但效果不是很好；<br>应用场景：公式或化学分子式中的上标和下标，文本中脚注的角标；</sub></sup></p>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>white-space<br>tab-size<br>word-break<br>word-wrap<br>overflow-wrap<br>text-align-last<br>text-justify<br>text-size-adjust<br>最佳实战</p>
<p>虽然学习了字体和文本属性，但不一定能够在实际应用中搭配好字体和文本样式。文字排版讲求匀称，一般是由看不见的网格，框定页面文字的走向和布局，匀称的版式可以增强页面的可读性。</p>
<p>在线资源：</p>
<ul>
<li><a href="http://ilovetypography.com/" target="_blank" rel="external">http://ilovetypography.com/</a></li>
<li><a href="http://www.thinkingwithtype.com/" target="_blank" rel="external">http://www.thinkingwithtype.com/</a></li>
<li><a href="http://webtypography.net/" target="_blank" rel="external">http://webtypography.net/</a></li>
</ul>
<p>一、字体与文本</p>
<p>字体与文本的区别：</p>
<p>字体主要涉及文字的大小和外观（可应用于单个字符）。<br>文本主要涉及对字体的处理（只能应用于文本块）</p>
<p>二、指定字体</p>
<p>CSS中指定字体的最简单方式，就是使用五种通用的字体集合</p>
<p>serif ：该字体在字符笔画末端有叫做衬线的小细节（Time New Roman、Georgia、Palatino）<br>sans-serif：末端无任何细节（Trebuchet MS、Arial、Verdana）<br>monospace：每个字母宽度相等（例如，i与m具有相同的宽度），通常用于排版代码块或模仿打印效果<br>cursive：手写笔记，但是比手写效果要整洁（Comic Sans MS、Brush Script）<br>fantasy：不能归入其他种类的字体</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*指定通用字体，浏览器会选择默认的Helvetica或者Arial*/</span></div><div class="line"><span class="comment">/*font-family是一个可继承的属性，值会传递给所有的后代*/</span></div><div class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>: sans-serif;&#125;</div><div class="line"></div><div class="line"><span class="comment">/*以首先字母为开头，以通用字体结束 */</span></div><div class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>: <span class="string">"hoefler text"</span>,times,serif;&#125;</div></pre></td></tr></table></figure>
<p>三、设置字体大小</p>
<p>设置字体大小，可以使用三种类型的值：</p>
<p>绝对值：像素、英寸<br>相对值：百分比、em<br>运动衫尺码关键字：x-small、small、large、xx-large</p>
<p>使用相对大小字体的优点：</p>
<p>在文字大小中选择了更大或者更小之后，所有字体都能成比例地缩放<br>只需要改变body标签的字体大小，按比例改变文本的大小</p>
<p>使用相对大小字体的缺点</p>
<p>可能因字体大小的继承而导致极小字体的显示<br>用户很容易“破坏”没有考虑到文本缩放因素的CSS页面布局</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;</div><div class="line">    <span class="attribute">font-family</span>: verdana,arial,sans-serif;</div><div class="line">    <span class="comment">/*为字体设置了可以调准的基准大小,1em一般为16像素高*/</span></div><div class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h3</span>&#123;</div><div class="line">    <span class="comment">/*h3的默认大小为1.2em(19.2px)，重新设置为0.8em*/</span></div><div class="line">    <span class="attribute">font-size</span>: <span class="number">0.8em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*分别为ol和ul设置大小，而不是为li设置大小，方便后续自定义*/</span></div><div class="line"><span class="selector-tag">ol</span>&#123;<span class="attribute">font-size</span>: .<span class="number">75em</span>;&#125;</div><div class="line"><span class="selector-tag">ul</span>&#123;<span class="attribute">font-size</span>: .<span class="number">75em</span>;&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">font-size</span>: .<span class="number">7em</span>;&#125;</div><div class="line"><span class="comment">/*规定ul的子元素a从父元素中继承属性值（如果没有使用inherit，a的值就会变成0.75*0.7em，导致过小*/</span></div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">a</span> &#123;<span class="attribute">font-size</span>: inherit;&#125;</div></pre></td></tr></table></figure>
<p>四、字体属性</p>
<p>font-style    定义文本的直立或倾斜    italic、normal、oblique<br>font-weight    定义文本的粗细    100、200、…、900、lighter、normal、bold、bolder<br>font-variant    转换成小型大写字母    small-caps、normal</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*font-style有两个作用：使字体倾斜，或者使倾斜的字体直立*/</span></div><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-style</span>: italic;&#125;</div><div class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">font-style</span>: normal;&#125;</div><div class="line"></div><div class="line"><span class="comment">/*加粗超链接的内容*/</span></div><div class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">font-weight</span>: bold;&#125;</div><div class="line"></div><div class="line"><span class="comment">/*将h3标题转换为小型大写字母*/</span></div><div class="line"><span class="selector-tag">h3</span>&#123;<span class="attribute">font-variant</span>: small-caps;&#125;</div></pre></td></tr></table></figure>
<p>五、字体属性的简写</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="comment">/*始终要保证声明font-size 和 font-family的值*/</span></div><div class="line">    <span class="comment">/*指定顺序：先指定font-weight、font-style、font-variant（任意顺序），然后依次指定font-size、font-family*/</span></div><div class="line">    <span class="attribute">font</span>:bold italic small-caps .<span class="number">75em</span> verdana, arial, sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>六、CSS蛇形文本</p>
<p>CSS会把一个盒子放到位于元素中的文本周围，只在开头和结尾是闭合的<br>text-indent 只能缩进首行<br>要想缩进整个段落，需要使用margin-left将整个容器往右侧推动</p>
<p>七、文本属性</p>
<p>text-indent<br>缩进元素中文本的首行<br>任何长度值</p>
<p>vertical-align<br>相对于基准线将文本向上或者向下方移动<br>任何长度值、sup、sub、top、middle、bottom</p>
<p>letter-spacing<br>设置字符间距<br>任何长度值</p>
<p>word-spacing<br>设置字间距<br>任何长度值</p>
<p>text-decoration<br>向文本添加修饰<br>none、underline、overline、line-through、blink</p>
<p>text-align<br>使文本与包含元素对齐<br>left、right、center、justify</p>
<p>line-height<br>设置行高（行与行基准线之间的距离）<br>任何数字值（不需要指定单位）</p>
<p>text-transform<br>改变元素中文本的大小写形式<br>uppercase、lowercase、capitalize、none</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*缩进首行文本*/</span></div><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">text-indent</span>: <span class="number">3em</span>;&#125;</div><div class="line"></div><div class="line"><span class="comment">/*为段落指定一个大于负缩进值的正左外边距，产生悬挂段落的效果*/</span></div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">text-indent</span>: -<span class="number">1.5em</span>;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">2em</span>;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*设置字符间距*/</span></div><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line">    <span class="attribute">letter-spacing</span>: .<span class="number">2em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*设置单词间距*/</span></div><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line">    <span class="attribute">word-spacing</span>: .<span class="number">2em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*去掉文本的下划线*/</span></div><div class="line"><span class="selector-tag">a</span>&#123;</div><div class="line">    <span class="attribute">text-decoration</span>: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*需要在包含元素上设置text-align属性，使其子元素内容对齐*/</span></div><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">text-align</span>: right;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*设置行高*/</span></div><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span><span class="selector-id">#intro</span> &#123;</div><div class="line">    <span class="comment">/*行高设置为字体的1.4倍*/</span></div><div class="line">    <span class="comment">/*行高比文本高出的部分，会再文本的上方和下方平均分配*/</span></div><div class="line">    <span class="attribute">font</span>:<span class="number">1.2em</span>/<span class="number">1.4</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*将每个单词的首字母变成大写*/</span></div><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line">    <span class="attribute">text-transform</span>: capitalize;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line">    <span class="attribute">vertical-align</span>: <span class="number">50%</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown语法]]></title>
      <url>http://hangweiping.github.io/2014/12/29/markdown%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。  </p>
</blockquote>
<a id="more"></a>
<h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">链接 <span class="symbol">:</span>[Title](URL)  </div><div class="line">加粗 <span class="symbol">:**Bold**</span>  </div><div class="line">斜体字 <span class="symbol">:*Italics*</span>  </div><div class="line">删除线 <span class="symbol">:~~text~~</span>  </div><div class="line">高亮 <span class="symbol">:==text=</span>=  </div><div class="line">段落 : 段落之间空一行  </div><div class="line">换行符 : 一行结束时输入两个空格  </div><div class="line">列表 <span class="symbol">:*</span> 添加星号成为一个新的列表项。  </div><div class="line">引用 <span class="symbol">:&gt;</span> 引用内容  </div><div class="line">内嵌代码 : `alert(<span class="string">'Hello World'</span>);`  </div><div class="line">画水平线 (HR) <span class="symbol">:</span>分割线用三个以上的星号 * 、减号-或下划线 <span class="number">_</span> 表示</div></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>具体使用方式请看示例。  </p>
<p>——: 为右对齐。<br>:—— 为左对齐。<br>:——: 为居中对齐。<br>——- 为使用默认居中对齐。  </p>
<table>
<thead>
<tr>
<th style="text-align:right">序号</th>
<th style="text-align:center">交易名</th>
<th style="text-align:left">交易说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:center">prfcfg</td>
<td style="text-align:left">菜单配置</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:center">gentmo</td>
<td style="text-align:left">编译所有交易</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:center">sysdba</td>
<td style="text-align:left">数据库表模型汇总</td>
</tr>
</tbody>
</table>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表包括无序列表和有序列表两类。列表的每一项都使用 标记 + 分隔（至少一个空格或制表符） + 段落 的格式，段落的内容可以跨行，用空格缩进，还可以包含代码块、引用块等。如果在一个列表项里添加用空行隔开的多个段落，需要在每个段落开头添加至少两个空格。如果要表示多级列表，需要在下一级列表标记前加上至少两个空格或一个制表符，多级列表可以混用不同的标记。  </p>
<p>无序列表使用星号 * 、加号 + 或是减号 - 作为列表标记，标记不能混用，否则会视为不同的列表。  </p>
<p>有序列表则使用数字和一个英文句点表示，数字的内容是任意的，并不会影响 HTML 显示的数字。有时不需要列表，但在段落开头的文字是数字加句点的格式，为了不被 Markdown 解析成列表，需要在句点前加上反斜线，如： 2016. Something Begin.  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">+ 无序列表项<span class="number">1</span></div><div class="line">+ 无序列表项<span class="number">2</span></div><div class="line"> + 下一级列表</div><div class="line">   <span class="number">2.</span> 再下一级列表<span class="number">1</span></div><div class="line">   <span class="number">2.</span> 再下一级列表<span class="number">2</span></div><div class="line">- 不同标记视为不同列表</div><div class="line">- 列表还可以</div><div class="line">    # 包含代码块</div><div class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line">- 或者引用</div><div class="line">&gt; I have a dream!</div><div class="line">- 以及多行或多段。</div><div class="line">第二行</div><div class="line"></div><div class="line">  第二段</div><div class="line"></div><div class="line"><span class="number">2016</span>\. Something Begin.</div></pre></td></tr></table></figure>
<ul>
<li>无序列表项1</li>
<li>无序列表项2<ul>
<li>下一级列表<ol>
<li>再下一级列表1</li>
<li>再下一级列表2</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li>不同标记视为不同列表</li>
<li>列表还可以</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 包含代码块</div><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<ul>
<li>或者引用<blockquote>
<p>I have a dream!</p>
</blockquote>
</li>
<li><p>以及多行或多段。<br>第二行</p>
<p>第二段</p>
</li>
</ul>
<p>2016. Something Begin.</p>
<h2 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h2><p>对于 Markdown 中的语法符号，前面加反斜线 \ 即可显示符号本身。包括</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">\\ 反斜线  </div><div class="line">\` 重音号  </div><div class="line">\* 星号  </div><div class="line">\<span class="number">_</span> 下划线  </div><div class="line">\&#123;\&#125; \[\] \(\) 括号  </div><div class="line">\# 井号  </div><div class="line">\+ 加号  </div><div class="line">\- 减号  </div><div class="line">\. 句点  </div><div class="line">\! 惊叹号</div><div class="line">```  </div><div class="line"></div><div class="line">## 任务列表  </div><div class="line"></div><div class="line">需要在 Markdown 列表项的段落部分用 [ ] 开头，也可以用 [x] 开头表示一个已选择的任务项。  </div><div class="line"></div><div class="line">```c</div><div class="line">- [x] 学习 Markdown</div><div class="line">- [ ] 使用 Markdown</div><div class="line">  <span class="number">1.</span> [ ] 写博客</div></pre></td></tr></table></figure>
<ul>
<li>[x] 学习 Markdown</li>
<li>[ ] 使用 Markdown<ol>
<li>[ ] 写博客</li>
</ol>
</li>
</ul>
<h2 id="emoji表情使用"><a href="#emoji表情使用" class="headerlink" title="emoji表情使用"></a>emoji表情使用</h2><p>:EMOJICODE: 的格式，详细的表情列表参见 EMOJI CHEAT SHEET 。</p>
<pre><code>:man: :thumbsup: :sunny: :bug:
</code></pre><p>:man: :thumbsup: :sunny: :bug:</p>
<h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><p>Markdown 中可以直接书写大部分HTML标签.其中在HTML的区块类型标签<code>&lt;div&gt;&lt;table&gt;&lt;pre&gt;&lt;p&gt;</code>等内的，Markdown语法会失效，在HTML行内型标签<span><cite><del>等内，Markdown语法仍然有效。<br>需要注意的是，在 HTML 标签内，书写特殊字符 &lt; 和 &amp; 仍然需要用它们的替代形式 &lt;和 &amp;表示。在 Markdown 中，也能用 &lt; 和 &amp; 的这种特殊形式。</del></cite></span></p>
<p>This is <a href="http://cn.bing.com" target="_blank" rel="external">Markdown</a> regular paragraph.<br>1 &lt; 3 &amp; 5<br>2 &lt; 4 &amp; 6  </p>
<table border="1" bgcolor="yellowgreen"><br>    <tr><br>        <td><strong>count</strong> 1 &lt; 3 &amp; 5</td><br>        <td><strong>count</strong> 2 &lt; 4 &amp; 6</td><br>    </tr><br></table>

<h2 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h2><p>链接用于跳转到其他页面，包含行内式和参考式两种样式，还可以使用简单的自动链接。跳转地址可以用 / 开头的相对路径引用本机资源。  </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">行内式：链接文字和跳转地址写在一起。如：  </div><div class="line">[<span class="string">an example</span>](<span class="link">http://www.cnblogs.com/zhuyuanhao/ "链接title"</span>)  </div><div class="line"></div><div class="line">an example</div><div class="line">参考式：链接文字和跳转地址分开写，通过 [id] 标识联系起来。 [id] 标识可以包含字母、数字、空白和标点符号，但是并不区分大小写。跳转地址部分可以出现在文件的任意地方。  </div><div class="line"></div><div class="line">This is [<span class="string">an example</span>][<span class="symbol">ID 2</span>] reference-style link.  </div><div class="line"></div><div class="line">[<span class="symbol">id 2</span>]: <span class="link">http://www.cnblogs.com/zhuyuanhao/ "可选title, 可以用单引号'、双引号"或括号()包着，也可以另起一行并缩进"  </span></div><div class="line">[<span class="symbol">iD 3</span>]: <span class="link">&lt;http://www.cnblogs.com/zhuyuanhao/&gt;   </span></div><div class="line"><span class="code">    '跳转地址也可以用尖括号包起来'</span></div><div class="line">隐式参考链接：使用空标识 [] ，在跳转地址处使用链接文字作为标识。</div><div class="line"></div><div class="line">[<span class="string">Google</span>][<span class="symbol"></span>]  </div><div class="line"></div><div class="line">[<span class="symbol">Google</span>]: <span class="link">http://google.com/ "Google Inc."  </span></div><div class="line">自动链接：对于网址和电子邮件信箱，只要是用尖括号包起来，Markdown 就会自动把它转成链接，链接文字和跳转地址相同。  </div><div class="line"></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.cnblogs.com</span>/<span class="attr">zhuyuanhao</span>/&gt;</span></span>  </div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">address@example.com</span>&gt;</span></span>  </div><div class="line">http://www.cnblogs.com/zhuyuanhao/  </div><div class="line"></div><div class="line">address@example.com  </div><div class="line">图片用于在当前页面显示图片，也包含行内式和参考式，只需要在链接的样式前加一个惊叹号 ! ，就会被识别为图片。可以使用相对路径引用本地的图片，也能使用 url 引用其他网站的图片。不过到目前为止，Markdown 还没有办法指定图片的宽高。  </div><div class="line"></div><div class="line">行内式：</div><div class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg "Optional title"</span>)  </div><div class="line">参考式：</div><div class="line">![<span class="string">Alt text</span>][<span class="symbol">id</span>]    </div><div class="line">[<span class="symbol">id</span>]: <span class="link">url/to/image  "Optional title attribute"</span></div></pre></td></tr></table></figure>
<p>行内式：链接文字和跳转地址写在一起。如：  </p>
<p><a href="http://www.cnblogs.com/zhuyuanhao/" title="链接title" target="_blank" rel="external">an example</a>  </p>
<p>an example<br>参考式：链接文字和跳转地址分开写，通过 <a href="url/to/image" title="Optional title attribute">id</a> 标识联系起来。 <a href="url/to/image" title="Optional title attribute">id</a> 标识可以包含字母、数字、空白和标点符号，但是并不区分大小写。跳转地址部分可以出现在文件的任意地方。  </p>
<p>This is <a href="http://www.cnblogs.com/zhuyuanhao/" title="可选title, 可以用单引号&#39;、双引号&quot;或括号()包着，也可以另起一行并缩进" target="_blank" rel="external">an example</a> reference-style link.  </p>
<pre><code>&apos;跳转地址也可以用尖括号包起来&apos;
</code></pre><p>隐式参考链接：使用空标识 [] ，在跳转地址处使用链接文字作为标识。</p>
<p><a href="http://google.com/" title="Google Inc." target="_blank" rel="external">Google</a>  </p>
<p>自动链接：对于网址和电子邮件信箱，只要是用尖括号包起来，Markdown 就会自动把它转成链接，链接文字和跳转地址相同。  </p>
<p><a href="http://www.cnblogs.com/zhuyuanhao/" target="_blank" rel="external">http://www.cnblogs.com/zhuyuanhao/</a><br><a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#97;&#x64;&#x64;&#x72;&#x65;&#x73;&#x73;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;">&#97;&#x64;&#x64;&#x72;&#x65;&#x73;&#x73;&#x40;&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109;</a><br><a href="http://www.cnblogs.com/zhuyuanhao/" target="_blank" rel="external">http://www.cnblogs.com/zhuyuanhao/</a>  </p>
<p>address@example.com<br>图片用于在当前页面显示图片，也包含行内式和参考式，只需要在链接的样式前加一个惊叹号 ! ，就会被识别为图片。可以使用相对路径引用本地的图片，也能使用 url 引用其他网站的图片。不过到目前为止，Markdown 还没有办法指定图片的宽高。  </p>
<p>行内式：<br><img src="/path/to/img.jpg" alt="Alt text" title="Optional title"><br>参考式：<br><img src="url/to/image" alt="Alt text" title="Optional title attribute">    </p>
<h2 id="自动生成目录"><a href="#自动生成目录" class="headerlink" title="自动生成目录"></a>自动生成目录</h2><p>在需要目录出现的地方（一般在文章一开始）放置一个标记，这样会自动生成一个嵌套的包含所有标题的列表。默认的标记是[TOC]。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[TOC]</div><div class="line"></div><div class="line"><span class="meta"># 概述</span></div><div class="line"></div><div class="line"><span class="meta">## 定义</span></div><div class="line"></div><div class="line"><span class="meta">## 用处</span></div><div class="line"></div><div class="line"><span class="meta"># 结论</span></div></pre></td></tr></table></figure>
<p>最前面的那个目录就是用 [TOC]生成的。</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注用于为正文中的某个条目添加补充注释，说明该条目的引文出处，跟参考文献一样，脚注一般位于文档的末尾，文章内以数字标注。在Markdown Extra也可以很容易的实现脚注。</p>
<p>语法说明：</p>
<p>在需要标记脚注文字的后面添加一个方括号，方括号中的内容必须以^开头，再接着是数字或字符串标记：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">脚注[ ^1]有一个标签[^label]和该标签的定义[^!DEF].</div><div class="line">接着，在文件的任意地方，你可以把这个脚注的内容定义出来：  </div><div class="line">[<span class="symbol"> ^1</span>]: <span class="link">这是一个脚注</span></div><div class="line">[<span class="symbol">^label</span>]: <span class="link">这是脚注的标签</span></div><div class="line">[<span class="symbol">^!DEF</span>]: <span class="link">这是脚注标签的定义</span></div></pre></td></tr></table></figure>
<p>脚注<a href="这是一个脚注"> ^1</a>有一个标签<a href="这是脚注的标签">^label</a>和该标签的定义<a href="这是脚注标签的定义">^!DEF</a>.<br>接着，在文件的任意地方，你可以把这个脚注的内容定义出来：  </p>
<p>脚注内容定义的形式：</p>
<p>前面引用脚注的标签符号<br>接着一个冒号<br>再接着一个以上的空格或制表符<br>最后是脚注定义的内容。<br>脚注定义的内容可以包含多行、代码区块、区块引用和大多数其他markdown格式的内容。</p>
<p>例子：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">这是一个脚注[ ^footnote].</div><div class="line"></div><div class="line">[ ^footnote]: 脚注定义内容的第一行内容.</div><div class="line">定义内容的第二行.</div><div class="line">&gt; 一个包含多行的</div><div class="line">&gt; 区块引用.</div></pre></td></tr></table></figure>
<p>转为HTML后为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个脚注<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#fn:footnote"</span> <span class="attr">id</span>=<span class="string">"fnref:footnote"</span> <span class="attr">title</span>=<span class="string">"See footnote"</span> <span class="attr">class</span>=<span class="string">"footnote"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footnotes"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"fn:footnote"</span>&gt;</span>脚注定义内容的第一行内容. <span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">定义内容的第二行.</div><div class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> 一个包含多行的 <span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">    &gt; 区块引用.</div><div class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#fnref:footnote"</span> <span class="attr">title</span>=<span class="string">"Return to article"</span> <span class="attr">class</span>=<span class="string">"reversefootnote"</span>&gt;</span>↩<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>默认情况下，脚注内容位于生成的 HTML 文档末尾，上面的脚注内容在该文章的末尾可以看到。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>图片链接  公式暂不涉及</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery中的Ajax]]></title>
      <url>http://hangweiping.github.io/2014/12/27/jQuery%E4%B8%AD%E7%9A%84Ajax/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原始ajax的五个步骤</p>
</blockquote>
<ol>
<li>准备发送请求 (调用 new XMLHttpRequest())   (readyState == 0)</li>
<li>打开一个请求  (调用open方法)  (readyState == 1)</li>
<li>发送请求 (调用send方法,并且接收到响应头)  (readyState == 2)</li>
<li>开始接受到请求 (readyState == 3)</li>
<li>接受完成 (readyState == 4)</li>
</ol>
<a id="more"></a>
<h3 id="Ajax核心对象XMLHttpRequest"><a href="#Ajax核心对象XMLHttpRequest" class="headerlink" title="Ajax核心对象XMLHttpRequest"></a>Ajax核心对象XMLHttpRequest</h3><p>这个对象最早在IE中被实现，不过它最早的时候是通过ActiveXObject实现的，如果不需要管兼容的话，IE9或者其他浏览器使用 new XMLHttpRequest() 就能创建了一个 XHR (XMLHttpRequest) 对象,IE中由于存在三个版本的XHR对象，所以如果需要兼容，需要对这三个版本进行处理，从中选出IE浏览器中最新支持对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="literal">undefined</span>)&#123;</div><div class="line">xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> ActiveXObject != <span class="literal">undefined</span>)&#123;</div><div class="line">xhr = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>,<span class="string">"MSXML2.XMLHttp.3.0"</span>,<span class="string">"MSXML2.XMLHttp"</span>]();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>,ilen = versions.length;i\&lt;ilen;i++) &#123;</div><div class="line">   <span class="keyword">try</span>&#123;</div><div class="line">  <span class="comment">//避免不支持当前版本报错</span></div><div class="line">  <span class="keyword">new</span> ActiveXObject[versions\[i]()];</div><div class="line">  <span class="comment">//保存当前支持的版本</span></div><div class="line">  argument.callee.ActiveXString = versions[i]();</div><div class="line">&#125;</div><div class="line">   <span class="keyword">catch</span> (e) &#123;&#125;</div><div class="line">  &#125;     </div><div class="line">  <span class="comment">//返回一个当前浏览器支持的版本的XHR对象</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(argument.callee.ActiveXString);</div><div class="line">&#125;)() ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码就做了第一阶段的事情，初始化一个请求</p>
<h3 id="打开一个请求-open"><a href="#打开一个请求-open" class="headerlink" title="打开一个请求 open"></a>打开一个请求 open</h3><p>xhr.open(); // xhr是通过new XMLHttpRequest()返回的对象 并没有发送请求，它只定义了请求的类型，url，以及是否异步，如： xhr.open(“get”,”index.html”, false ); 最常见的请求类型有post和get两种方法，url如果没有指定完整的（带协议前缀的如: <a href="http://,https://" target="_blank" rel="external">http://,https://</a> ）url地址，那么它的地址相对当前执行代码的页面，Ajax最优秀的地方便是可以异步同步发送请求，第三个参数false代表同步，true代表异步。</p>
<h3 id="post跟get的区别"><a href="#post跟get的区别" class="headerlink" title="post跟get的区别"></a>post跟get的区别</h3><p>对于前端，对它能体现对大的区别就是传参不同，get的参数放在url地址后面以 ?abc=1&amp;bcd=2&amp;dd=3&amp;s=4 的形式传递，而post的参数放在请求主体内，通过 xhr.send() 发送，  xhr.send(“任何想发送给服务器的字符串”);<br>url<br>url相对与执行当前代码的页面。<br>在页面<a href="http://mydomin.com/test/obj/index.html中调用了xhr.send()表示请求在index.html页面发送，那么url响应的地址就是http://mydomin.com/test/obj/我的请求的url地址。" target="_blank" rel="external">http://mydomin.com/test/obj/index.html中调用了xhr.send()表示请求在index.html页面发送，那么url响应的地址就是http://mydomin.com/test/obj/我的请求的url地址。</a><br>如果是一个完整的地址，那么必须是同域的情况下才允许发送请求，否在会引发安全报错，同域：同端口同协议的url地址<br><a href="http://baidu.com:80" target="_blank" rel="external">http://baidu.com:80</a><br>协议:http<br>端口:80</p>
<h3 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h3><p>同步请求必须接收完(到达第四阶段)响应才会继续往下执行代码，<br>而异步请求会在发出一个请求继续执行不会阻碍流程，<br>不管是同步或在异步当接收完完响应之后会调用onreadystatechange方法，当xhr属性的readystate的值为4（第四阶段）的时候表示接受完成 xhr.onreadystatechange =function (e){} ，除了第零阶段，几乎每个阶段都对调用onreadystatechange方法，但取决于浏览器的实现。<br>发送一个请求 xhr.send()<br>xhr.send() 阶段才是真真的发起请求阶段，几乎可以用来发送任何数据，在这个阶段，<br>如果是异步请求，那么调用之后就会直接执行下面的代码，<br>如果是同步请求，那么需要等到readyState的值为4也就是接收完所有响应之后才会往下执行。</p>
<h3 id="接受响应"><a href="#接受响应" class="headerlink" title="接受响应"></a>接受响应</h3><p>xhr对象有四个关于响应的属性</p>
<ul>
<li>responseText  (响应文本)</li>
<li>responseXML     （如果响应头是text/xml或在application/xml那么响应数据会添加到这个属性）</li>
<li>status (响应状态码,200,304,404,500等等)</li>
<li>statusText (响应状态说明)<br>无论响应的是什么样的内容，都会把服务器返回的内容存在 xhr.responseText 中，所以有时候只需关注  xhr.responseText ，只有响应头的类型是text/xml或在application/xml的时候 xhr.responseXML 才会填充响应数据</li>
</ul>
<h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>statusText：表示对响应状态的说明，不过有时候并不能准确解释状态，如我直接访问一个发起一个跨域的请求的时候， statusText 为空，并且每个浏览器对状态的描述并不是所有的都一致。<br>虽然jQuery已经把所有的步骤都封装好，让技术员指需要关注成功与否，但很多时候了解其中的原理，处理问题会让人更加灵活并且得心应手。</p>
<h2 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h2><blockquote>
<p>jQuery 对 Ajax 做了大量的封装，我们使用起来也较为方便，不需要去考虑浏览器兼容性。对于封装的方式，jQuery采用了三层封装：最底层的封装方法为：$.ajax()，而通过这层封装了第二层有三种方法：.load()、$.get()和$.post()，最高层是$.getScript()和$.getJSON()方法。</p>
</blockquote>
<h3 id="Ajax中的load-方法"><a href="#Ajax中的load-方法" class="headerlink" title="Ajax中的load()方法"></a>Ajax中的load()方法</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**   Ajax中的load方法（局部方法，可以直接绑定在需要获取的元素上）</div><div class="line">  @<span class="keyword">param</span> &#123;String&#125;        <span class="keyword">url</span>  必须，获取文件地址</div><div class="line">  @<span class="keyword">param</span> &#123;JSON <span class="keyword">or</span> String&#125;          可选，键值对方式的请求参数或者（使用键值对   形式，请求将转化成post）</div><div class="line">  @<span class="keyword">param</span> &#123;Function&#125;      可选，请求成功的回调函数</div><div class="line">  @<span class="keyword">config</span>   &#123;String&#125;   <span class="keyword">responseText</span>         获得字符串形式的响应数据</div><div class="line">  @<span class="keyword">config</span>   &#123;String&#125;   <span class="keyword">textStatus</span>            文本方式返回HTTP状态码</div><div class="line">  @<span class="keyword">config</span>   &#123;Object&#125;   <span class="keyword">XMLHttpRequest</span>        <span class="keyword">xhr</span>对象，有多种属性</div><div class="line"> */</div><div class="line">.load(url, data, complete(responseText, textStatus, XMLHttpRequest));</div><div class="line"></div><div class="line">例如下面这段代码  </div><div class="line"></div><div class="line">	$(<span class="string">'button'</span>).click(function () &#123;</div><div class="line">	$(<span class="string">'#box'</span>).load(<span class="string">'test.php'</span>, &#123;url : <span class="string">'guowen'</span>&#125;);</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>
<p>在控制台可以看到请求为POST，（注意：这里第二个参数若是字符串的情况，例如”url=guowen”，请求仍然为GET。）<br>所以服务器端php文件应该如此设置：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?php</span></span></div><div class="line"><span class="keyword">if</span> ($_POST[<span class="string">"url"</span>]() == <span class="string">"guowen"</span>) &#123;<span class="comment">//get请求把POST更改一下就好了</span></div><div class="line"><span class="keyword">echo</span> <span class="string">"\&lt;a href='http://guowenfh.github.io/'\&gt;三省吾身丶丶\&lt;/a\&gt;"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">"其他网站"</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>关于XHR对象上的属性，和HTTP状态码，参考我原来的博客。</p>
<h3 id="get-和-post"><a href="#get-和-post" class="headerlink" title="$.get()和$.post()"></a>$.get()和$.post()</h3><blockquote>
<p>.load()方法是局部方法，因为他需要一个包含元素的 jQuery 对象作为前缀。而$.get()和$.post()是全局方法，无须指定某个元素。对于用途而言，.load()适合做静态文件的异步获取，而对于需要传递参数到服务器页面的，$.get()和$.post()更加合适。</p>
</blockquote>
<p>$.get()方法有四个参数，前面三个参数和.load()一样，多了一个第四参数type，即服务器返回的内容格式：包括xml、html、script、json、jsonp和text。第一个参数为必选参数，后面三个为可选参数<br>GET方式请求会直接在html后以?Key=value跟随，所以，有三种形式请求数据，  </p>
<ol>
<li>直接跟在url后</li>
<li>键值对形式的{url:”guowen”}</li>
<li>字符串形式的”url=guowen”<br>POST请求方式除去不能直接跟在url后之外，剩余两个，使用方法一样<br>注意: 与.load()方法不同的是：.load()方法根据第二个参数的不同类型，请求方式会改变，但这里已经是两个独立的方法了，所以请求类型不会进行转换。<br>第四个参数一般都不进行设置，jQuery会自动转换其类型。强制设置时，有可能会连标签一起返回。<br>至于POST与GET方式请求的差别，在我原来的博客中也有写到，这里就不赘述了。</li>
</ol>
<h3 id="getScript-和-getJSON"><a href="#getScript-和-getJSON" class="headerlink" title="$.getScript()和$.getJSON()"></a>$.getScript()和$.getJSON()</h3><p>jQuery提供了一组用于特定异步加载的方法：$.getScript()，用于加载特定的JS文件；$.getJSON()，用于专门加载JSON文件。<br>$.getJSON()方法与之前的使用方法类似，就是把第四个参数，类型强制设置成了JSON。<br>有时我们希望能够特定的情况再加载JS文件，而不是一开始把所有JS文件都加载了，这时就可以使用$.getScript()方法。</p>
<p>//点击按钮后再加载 JS 文件<br>$(‘input’).click(function () {<br>$.getScript(‘test.js’);<br>});</p>
<h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h3><p>$.ajax()是所有 ajax 方法中最底层的方法，所有其他方法都是基于$.ajax()方法的封装。这个方法只有一个参数，传递一个各个功能键值对的对象。<br>参数很多有兴趣的自己去看jQuery.ajax()，本来准备写几个常用的。强迫症犯了，去网上找资料做成了表格。。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'button'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">$.ajax(&#123;</div><div class="line">type : <span class="string">'POST'</span>, <span class="comment">//这里可以换成 GET</span></div><div class="line">url : <span class="string">'test.php'</span>,</div><div class="line">data : &#123;</div><div class="line">url : <span class="string">'guowen'</span></div><div class="line">&#125;,</div><div class="line">success : <span class="function"><span class="keyword">function</span> (<span class="params">response, stutas, xhr</span>) </span>&#123;</div><div class="line">$(<span class="string">'#box'</span>).html(response);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意：对于data属性，如果是GET、模式，可以使用三种之前说所的三种形式。如果是POST模式可以使用之前所说的两种形式。（这里不需要考虑之前的data类型的问题了，因为指定了请求类型，不会转化）</p>
<h3 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h3><p>使用表单序列化方法.serialize()，会智能的获取指定表单内的所有元素。这样，在面对大量表单元素时，会把表单元素内容序列化为字符串，然后再使用Ajax请求。<br>序列化表单内的元素：data : $(‘form’).serialize()，其余部分相同。<br>除此之外还可以直接获取单选框、复选框和下拉列表框等内容除了.serialize()方法，还有一个可以返回 JSON 数据的方法：.serializeArray()。这个方法可以直接把数据整合成键值对的 JSON 对象。<br>使用方法相同$(‘form’).serializeArray().有时，我们可能会在同一个程序中多次调用$.ajax()方法。而它们很多参数都相同，这个时候我们课时使用 jQuery 提供的$.ajaxSetup()请求默认值来初始化参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'form input[type=button]()'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">$.ajaxSetup(&#123;<span class="comment">//初始化多个ajax方法相同部分参数，后面再写ajax的时候，就不用在写了。</span></div><div class="line">type : <span class="string">'POST'</span>,</div><div class="line">url : <span class="string">'test.php'</span>,</div><div class="line">data : $(<span class="string">'form'</span>).serialize()<span class="comment">//表单序列化</span></div><div class="line">&#125;);</div><div class="line">$.ajax(&#123;</div><div class="line">success : <span class="function"><span class="keyword">function</span> (<span class="params">response, status, xhr</span>) </span>&#123;</div><div class="line">alert(response);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在使用 data 属性传递的时候，如果是以对象形式传递键值对，可以使用$.param()方法将对象转换为字符串键值对格式。<br>主要是针对无法直接使用表单序列化方法.serialize()的情况，且传递参数为对象，建议使用该方法进行解析后再进行传递。</p>
<h3 id="Ajax进阶"><a href="#Ajax进阶" class="headerlink" title="Ajax进阶"></a>Ajax进阶</h3><p>加载请求，及错误处理。<br>主要是处理网速较慢的情况，出现请求时间较长的问题。而此时若没有一点提示，用户可能会认为你的网页出现了问题。若是能在请求过程中给用户一些提示，比如：正在努力加载中…… 。 可能会对用户更加友好一些。<br>jQuery提供了两个全局事件，jQuery 提供了两个全局事件，.ajaxStart()和.ajaxStop()。<br>这两个全局事件，只要用户触发了 Ajax，请求开始时（未完成其他请求）激活.ajaxStart()，请求结束时（所有请求都结束了）激活.ajaxStop()。<br>值得注意的是，因为是全局事件，所以这两个方法是直接需要直接绑定到document上的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).ajaxStart(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">$(<span class="string">".loading"</span>).show();</div><div class="line">&#125;).ajaxStop(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">$(<span class="string">".loading"</span>).hide();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然你也可以自行在ajax内部进行一些设置,如请求超时时间，该ajax函数是否触发全局事件等等。以键值对的方式写明就可以了。<br>错误处理也特别简单</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line"><span class="comment">//…………</span></div><div class="line">timeout : <span class="number">500</span>,<span class="comment">//如果请求时间太长，可以设置超时</span></div><div class="line">global : <span class="literal">false</span>,<span class="comment">//如果某个 ajax 不想触发全局事件，可以设置取消</span></div><div class="line">error : <span class="function"><span class="keyword">function</span>(<span class="params">xhr,errorText,errorType</span>)</span>&#123;<span class="comment">//一般都直接用xhr对象</span></div><div class="line">alert(<span class="string">"发生错误："</span>+xhr.status);<span class="comment">//返回错误状态码</span></div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>除此之外$.get()、$.post()和.load(),可以通过连缀处理使用局部.error()方法来处理错误，当然还有一个全局的方法：通过全局.ajaxError()事件方法来返回错误信息。即可</p>
<h3 id="请求全局事件"><a href="#请求全局事件" class="headerlink" title="请求全局事件"></a>请求全局事件</h3><p>jQuery 对于 Ajax 操作提供了很多全局事件方法，除去上面已经提到的.ajaxStart()、.ajaxStop()、.ajaxError()等事件方法。他们都属于请求时触发的全局事件，除了这些，还有一些其他全局事件：</p>
<ol>
<li>.ajaxSuccess()，对应一个局部方法：.success()，请求成功完成时执行。</li>
<li>.ajaxComplete()，对应一个局部方法：.complete()，请求完成后注册一个回调函数。</li>
<li>.ajaxSend()，没有对应的局部方法，只有属性 beforeSend，请求发送之前要绑定的函数。<br><strong>注意</strong>：全局事件方法是所有 Ajax 请求都会触发到，并且只能绑定在 document 上。而局部方法，则针对某个 Ajax。<br>对于一些全局事件方法的参数，大部分为对象，而这些对象有哪些属性或方法能调用，可以通过遍历方法得到。如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历 settings 对象的属性</span></div><div class="line">$(<span class="built_in">document</span>).ajaxSuccess(<span class="function"><span class="keyword">function</span> (<span class="params">event, xhr, settings</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> settings) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这些全局方法，在$.ajax()方法中都可以直接以参数中的键值对的形式来完成</p>
<h3 id="JSON和JSONP"><a href="#JSON和JSONP" class="headerlink" title="JSON和JSONP"></a>JSON和JSONP</h3><p>其实在同一个域中时，只要url的后缀是json的文件的，默认就是json。当然你还可以使用$.ajax()方法设置 dataType属性加载 JSON 文件。<br>先来试试本地JSON:<br>php如下：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?php</span></span></div><div class="line">$_arr= <span class="keyword">array</span>(<span class="string">'a'</span>=\&gt;<span class="number">1</span>,<span class="string">'b'</span>=\&gt;<span class="number">2</span>,<span class="string">'c'</span>=\&gt;<span class="number">3</span>);</div><div class="line">$_result = json_encode($_arr);</div><div class="line"><span class="keyword">echo</span> $_result;</div><div class="line">?\&gt;</div></pre></td></tr></table></figure>
<p>js:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">type:<span class="string">"post"</span>,</div><div class="line">url:<span class="string">"test.php"</span>,</div><div class="line">dataType:<span class="string">"json"</span>,<span class="comment">//因为文件类型是php。但是返回的数据是json，所以必须设置类型，否则返回字符串</span></div><div class="line">success:<span class="function"><span class="keyword">function</span>(<span class="params">response,staus,xhr</span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(response.a);<span class="comment">//打印出来1</span></div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>实现跨域：这部分需要服务器端配合。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?php</span></span></div><div class="line">$_arr= <span class="keyword">array</span>(<span class="string">'a'</span>=\&gt;<span class="number">1</span>,<span class="string">'b'</span>=\&gt;<span class="number">2</span>,<span class="string">'c'</span>=\&gt;<span class="number">3</span>);</div><div class="line">$_result = json_encode($_arr);</div><div class="line">$_callback = $_GET[<span class="string">'callback'</span>]();<span class="comment">//关键在这。配合客户端JS使用</span></div><div class="line"><span class="keyword">echo</span> $_callback.<span class="string">"($_result)"</span>;<span class="comment">//php用点号实现字符串拼接</span></div><div class="line">?\&gt;</div></pre></td></tr></table></figure>
<p>客户端实现：  </p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;//我本地地址为http://<span class="number">127.0.0.1:8020</span>/ajax.html</div><div class="line">type:<span class="string">"<span class="keyword">GET</span>"</span>,</div><div class="line">url:<span class="string">"http://localhost/test.php?callback=?"</span>,//这样就可以实现跨域资源的访问了，最后的？号，jQuery会自动转化成字符串</div><div class="line">dataType:<span class="string">"json"</span>,//若这里使用JSONP的话，可以删除上面url的“?callback=?”，jQuery会自动处理。</div><div class="line">success:function(response,staus,xhr)&#123;</div><div class="line">alert(response.a);</div><div class="line">console.log(response)</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然我们还可以进行使用$.getJSON()。使用方式同上。</p>
<h3 id="jqXHR对象"><a href="#jqXHR对象" class="headerlink" title="jqXHR对象"></a>jqXHR对象</h3><p>在之前，我们使用了局部方法：.success()、.complete()和.error()。这三个局部方法并不是 XMLHttpRequest 对象调用的，而是$.ajax()之类的全局方法返回的对象调用的。这个对象，就是 jqXHR 对象，它是原生对象 XHR 的一个超集。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取 jqXHR 对象，查看属性和方法</span></div><div class="line"><span class="keyword">var</span> jqXHR = $.ajax(&#123;</div><div class="line"><span class="keyword">type</span> : <span class="string">'POST'</span>,</div><div class="line">url : <span class="string">'test.php'</span>,</div><div class="line">data : $(<span class="string">'form'</span>).serialize()</div><div class="line">&#125;);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> jqXHR) &#123;</div><div class="line"><span class="built_in">document</span>.write(i + <span class="string">'\&lt;br /\&gt;'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：如果使用 jqXHR 对象的话，那么建议用.done()、.always()和.fail()代<br>替.success()、.complete()和.error()。以为在未来版本中，很可能将这三种方法废弃取消。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//成功后回调函数</span></div><div class="line">jqXHR.done(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">$(<span class="string">'#box'</span>).html(response);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用 jqXHR 的连缀方式比$.ajax()的属性方式有三大好处：</p>
<ol>
<li>可连缀操作，可读性大大提高；</li>
<li>可以多次执行同一个回调函数；</li>
<li>为多个操作指定回调函数；</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[css设计指南-定位]]></title>
      <url>http://hangweiping.github.io/2014/12/26/css%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97-%E5%AE%9A%E4%BD%8D/</url>
      <content type="html"><![CDATA[<p>其实 HTML 页面中每个元素其实都是一个「盒子」，默认情况下这些盒子的边框不可见，背景也是透明的，所以我们不能直接的看到页面中盒子的结构，但是我们可以借助一些 Web Developer 工具条可以方便地显示盒子的边框和背景，让我们能很直观的看到这些盒子的结构。  </p>
<a id="more"></a>
<h2 id="理解盒模型"><a href="#理解盒模型" class="headerlink" title="理解盒模型"></a>理解盒模型</h2><p>每个盒子都有三组属性：  </p>
<ol>
<li>外边距(margin)： 可以设置盒子与相邻盒子之间的距离。</li>
<li>边框(border)： 可以设置边框的宽度、样式和颜色。</li>
<li><p>内边距(padding)：可以设置盒子内容区和边框之间的距离。<br>一个盒子有四条边，所以这些属性也各有四个属性，分别是上(top)、右(right)、下(bottom)和左(left)，尽管这三组属性共有 12 个属性值，但我们也可以对它们进行简写，这里以margin 为例：  </p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">margin-top</span>:<span class="number">1px</span>;</div><div class="line"><span class="attribute">margin-right</span>:<span class="number">1px</span>;</div><div class="line"><span class="attribute">margin</span>-botton:<span class="number">1px</span>;</div><div class="line"><span class="attribute">margin-left</span>:<span class="number">1px</span>;</div></pre></td></tr></table></figure>
<p>缩写后的代码如下:<br><code>margin:1px 1px 1px 1px;</code><br>缩写的顺序是<strong>上 -> 右 -> 下 -> 左，顺时针的方向</strong>。相对的边的值相同，则可以省掉，代码如下:</p>
</li>
</ol>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span>;<span class="comment">// 四个方向的边距相同，等同于margin:1px 1px 1px 1px;</span></div><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span> <span class="number">2px</span>;<span class="comment">// 上下边距都为1px，左右边距均为2px，等同于margin:1px 2px 1px 2px</span></div><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span> <span class="number">2px</span> <span class="number">3px</span>;<span class="comment">// 右边距和左边距相同，等同于margin:1px 2px 3px 2px;</span></div><div class="line"><span class="attribute">margin</span>:<span class="number">1px</span> <span class="number">2px</span> <span class="number">1px</span> <span class="number">3px</span>;<span class="comment">// 注意，这里虽然上下边距都为1px，但是这里不能缩写。</span></div></pre></td></tr></table></figure>
<h3 id="盒子的边框-border"><a href="#盒子的边框-border" class="headerlink" title="盒子的边框(border)"></a>盒子的边框(border)</h3><p>边框(border)有四个相关属性：</p>
<ol>
<li>宽度(border-width)：可以使用 thin、 medium 和 thick 等文本值，也可以使用 除百分比和负值以外 的任何绝对值。</li>
<li>样式(border-style)：有 none、 hidden、 dotted、 dashed、 solid、 double、 groove、 ridge、 inset 和 outset 等文本值。</li>
<li>颜色(border-color)：可以使用任何颜色值，包括 rgb、 hsl、十六进制颜色值和颜色关键字。</li>
<li>圆角(border-radius)：属于 CSS3 新增属性，可使用百分比、相对值和绝对值。<br>CSS 推荐标准并没有明确规定 border-width 的几个文本值的确切宽度，所以实际宽度会因浏览器而异。border-radius 不影响盒子的定位。<h3 id="盒子的内边距-padding"><a href="#盒子的内边距-padding" class="headerlink" title="盒子的内边距(padding)"></a>盒子的内边距(padding)</h3>内边距是盒子内容区与盒子边框之间的距离。在没有设置内边距的情况下，内容紧挨着边框：设置内边距后，内容区与边框有一定的距离(padding 的大小)：<h3 id="盒子外边距-margin"><a href="#盒子外边距-margin" class="headerlink" title="盒子外边距(margin)"></a>盒子外边距(margin)</h3>与内边距和边框相比，外边距就要显得复杂的多了，首先是外边距叠加， 垂直方向上的外边距会叠加 ，例如有三个段落应用了如下规则：</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">height</span>:<span class="number">50px</span>;</div><div class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#000</span>;</div><div class="line"><span class="attribute">background</span>: <span class="number">#fff</span>;</div><div class="line"><span class="attribute">margin-top</span>: <span class="number">50px</span>;</div><div class="line"><span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于第一段的下边距与第二段的上边距相邻，你可能会觉得它们两个盒子边框之间的外边距只和是 80px，但实际上是 50px，像这样上下外边距相遇时，它们会相互重叠，直到一个外边距碰到另一个盒子的边框。就上面例子而言，第二段较宽的上外边距会碰到第一段的边框，也就是说较宽的外边距决定两个盒子之间的距离。</p>
<h3 id="外边距的单位"><a href="#外边距的单位" class="headerlink" title="外边距的单位"></a>外边距的单位</h3><p>在设置段落文本外边距时应该注意，为了避免因增大字号导致段落间外边距不变引起的整体不协调的问题，在设置段落的上下外边距是应该使用 em 单位，这样当字体大小调整时，段落的上下外边距也会根据字体的大小来调整距离，这样页面的整体布局就会比较协调一致，而左右外边距则可以用 px 绝对单位，确保左右外边距不会因字体大小的调整而发生改变，比如可以这么设置：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">font-size</span>: <span class="number">1em</span>;</div><div class="line"><span class="attribute">margin</span>: .<span class="number">75em</span> <span class="number">30px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样段落垂直距离就会始终保持字体高度的四分之三的高度，水平外边距不会因字体的调整而发生改变了。</p>
<h2 id="盒子有多大"><a href="#盒子有多大" class="headerlink" title="盒子有多大"></a>盒子有多大</h2><p>作者在本章介绍了块级元素和行内元素的不同行为。</p>
<h3 id="没有宽度的盒子"><a href="#没有宽度的盒子" class="headerlink" title="没有宽度的盒子"></a>没有宽度的盒子</h3><p>作者在这一节中专门提到了一个 「没有宽度」的概念：没有显式地设置元素的width 属性。如果不设置块级元素的 width 属性，那么这个属性的默认值就是auto ，结果就是会让元素的宽度扩展到与父元素同宽，对于块级元素和行内元素更具体的介绍请看笔者的上一篇文章 CSS 设计指南 学习笔记 一 。<br><strong>盒模型结论一：</strong><br>没有设置宽度的元素始终会扩展到填满其父元素的宽度为止，添加水平外边距、水平边框和水平内边距都会导致内容宽度的减少，减少量等于水平外边距、水平边框和水平内边距的和。</p>
<h3 id="有宽度的盒子"><a href="#有宽度的盒子" class="headerlink" title="有宽度的盒子"></a>有宽度的盒子</h3><p><strong>盒模型结论二：</strong><br>为设定了宽度的盒子添加外边距、边框和内边距，会导致盒子扩展的更宽，实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而不是盒子要占据的( margin-left + border-left + padding-left + width + padding-right + border-right + margin-right )水平宽度。<br>所以一定要记住的是，给设定了 width 的元素添加外边距、边框和内边距所展示的行为与默认的 auto 状态下的行为会有截然不同的表现。<br>拓展：<br>但是与布局相关的元素大部分都同时设置了 margin 、 border 、 padding 和width ，这就导致了在布局时的各种计算保证总宽度( margin-left + border-left + padding-left + width + padding-right + border-right + margin-right )保持不变，这样不仅麻烦，有的时候还比较容易出错，为了解决这一问题， CSS3 新增了一个 box-sizing 属性，通过它可以将设置了 width 的元素也设定成具有默认的 auto 状态下的行为。这样就省去了许多计算 width 的时间，同时也不会出错，而且它的浏览器支持情况也是一片大好（ 除了 IE 6 和 IE 7 不支持，其他个别老版本的浏览器需要添加浏览器私有前缀才支持 ）。<br>可以这样使用这个属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> *&#123;</div><div class="line"><span class="attribute">-webkit-box-sizing</span>: border-box;</div><div class="line">   <span class="attribute">-moz-box-sizing</span>: border-box;</div><div class="line"><span class="attribute">box-sizing</span>: border-box;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="浮动与清除"><a href="#浮动与清除" class="headerlink" title="浮动与清除"></a>浮动与清除</h2><p>浮动和清除是页面布局的一大利剑，分别是 float 和 clear ，浮动可以让原来上下堆叠的块级元素变成左右并列，可以实现文字绕图片排列效果。浮动的元素会脱离常规的文档流，原来紧跟其后的元素会在空间允许的情况下向上提升到与浮动元素平起平坐。如果浮动元素后面有两个段落，而你只想让第一段与浮动元素并列（就算旁边还能放下第二段，也不想让它上来），就可以使用 clear 属性清除浮动。</p>
<h3 id="围住浮动元素的三种方法"><a href="#围住浮动元素的三种方法" class="headerlink" title="围住浮动元素的三种方法"></a>围住浮动元素的三种方法</h3><p>浮动元素脱离了文档流，所以我们看不到包含它的父元素了，这种情况有时候并不是我们想要的，所以作者在本章介绍了如何围住浮动元素的三种方法。<br><strong>方法一：</strong> 为父元素添加 overflow: hidden; 强制它包围浮动元素。<br>这种方法在某些情况下也不适用，比如通过浮动设置的水平排列的菜单，对其父元素设置 overflow: hidden; 后，尽管父元素围住了它，但是如果菜单有下拉选项的话，当鼠标移动到上面的时候下拉菜单并不会显示，因为设置了 overflow: hidden; ，所以超出父元素范围的内容都被隐藏掉了。  </p>
<p><strong>方法二：</strong> 同时浮动父元素</p>
<p>父元素设置浮动后，不管其子元素是否是浮动，父元素都会紧紧地包围住它的子元素，因此需要用 width: 100%; 再让父元素的宽度与浏览器容器同宽。同样，尽管父元素围住了它，但是这样会导致页面中出现大量的浮动元素，而浮动元素有往往不好控制，并不利于页面的布局。</p>
<p><strong>方法三：</strong> 添加非浮动的清除元素</p>
<p>第三种强制父元素包含其浮动的子元素的方式就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素，因此父元素一定会包含这个子元素以及前面的浮动元素：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CSS</span></div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.clearfix</span> &#123;</div><div class="line"><span class="attribute">clear</span>:both;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>尽管这个方法能解决上面提到的两种方法中的问题，但它还不是最好的方法，因为它会在文档中添加无意义的标签，这违反了标签语义化的规则，对搜索引擎并不友好。所以如果你要清楚浮动但既不想浮动父元素又不想对父元素设置 overflow: hidden; 也不想增加无意义的标签的话，可以使用伪元素来清除浮动：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line"><span class="attribute">content</span>: <span class="string">" "</span>;</div><div class="line"><span class="attribute">display</span>: table;</div><div class="line"><span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在父元素中添加 clearfix 类，因为搜索引擎并不会抓取伪元素，所以这种方法并没有增加无意义的标签，这里应该注意的是，CSS3 标准是用两个冒号来区别伪元素和伪类，而 CSS2.1 中不管是伪元素还是伪类都是用单个冒号表示，然而 IE8 并不支持双冒号的伪元素，所以问题就来了，如果你要遵循 CSS3 的标准使用双冒号的话就不兼容 IE8 了，如果使用但冒号的话又不符合 CSS3 标准规范，当然现在大多数还是使用但冒号的，选择哪种还是看个人的选择。</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>CSS 布局的核心是 position 属性，对元素应用这个属性可以相对于它在常规文档流中的位置重新定位， position 属性有 4 个值： static 、 relative 、absolute 和 fixed 。</p>
<h3 id="静态定位-static"><a href="#静态定位-static" class="headerlink" title="静态定位(static)"></a>静态定位(static)</h3><p>静态定位下的块级元素会在默认文档流中上下堆叠，想要突破 static 定位提供的这种按顺序布局元素的方式，就必须对元素的 position 属性的值改为其他三个值。</p>
<h3 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位(relative)"></a>相对定位(relative)</h3><p>所谓的相对定位就是相对于元素原来的位置（static 状态下的位置）进行定位，也就是说在不设置 top 、 right 、 bottom 或 left 的话，和它在默认(static)情况下的表现是相同的，但是如果对它设置了 top 、 right 、 bottom 或 left 的话，就会相对与它默认的位置进行定位。相对定位的元素可以遮住静态(static)定位的元素。可以给 top 和 left 属性设定负值，把元素向上和向左移动。</p>
<h3 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位(absolute)"></a>绝对定位(absolute)</h3><p>绝对定位跟静态定位和相对定位是绝对不一样的，静态定位和相对定位并不会脱离文档流，会占居原来的位置，而绝对定位会把元素彻底从文档流中拿出来，然后再相对于其他元素（这里的其他元素指的是定位上下文，默认是 body 元素）定位。<br>绝对定位的一个重要的概念就是 定位上下文 ，把元素的 position 属性设定为relative 、 absolute 或 fixed 后，继而可以使用 top 、 right 、bottom 和 left 属性，相对于「另一个元素」移动该元素的位置。这里的「另一个元素」就是该元素的定位上下文。<br>绝对定位的默认定位上下文是 body ，这是因为 body 是标记中所有元素的唯一的祖先元素，而实际上，绝对定位元素的任何祖先元素都可以成为该绝对定位元素的定位上下文，只要把相应的祖先元素的 position 属性的值设定为 relative 即可。</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>从完全脱离文档流的角度说，固定定位与绝对定位类似。但不同之处在于，固定定位的定位上下文是视口（浏览器窗口），因此它不会随页面的滚动而移动。最常见的情况是用它来创建不随页面滚动而移动的导航元素。</p>
<h3 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h3><p>在讲绝对定位的时候，我们了解到绝对定位元素默认的定位上下文是body元素，因为body是标记中所有元素唯一的祖先元素。而实际上， 绝对定位元素的所有祖先元素都可以成为它的定位上下文，只要把相应祖先元素的position设定为relative即可 。<br>只有将元素的position属性设置为relative、absolute、fixed，这个元素的top、right、bottom和left属性才会起作用。<br>设置了内部div的position属性为absolute之后，内部div就会脱离原来的位置，默认相对于body重新定位。<br>设置了外部div的position属性为relative值之后，它就变成了内部div的定位上下文。 此时内部div的top、left属性参照的就是外部div了。如果你再用left和top属性重新定位外部div，内部div也会跟着移动相同的距离，以保住它与外部div之间的位置关系。<br>事实上，只要把元素的外边距和内边距设定好，多数情况下只用默认的静态定位就足以实现页面布局了。很多刚接触CSS的初学者(include myself)都会错误的设定position属性,最终发现从文档流中挪出来的元素很难控制。因此，除非真需要那么做，否则不要轻易修改元素默认的position属性。</p>
<h2 id="显示属性"><a href="#显示属性" class="headerlink" title="显示属性"></a>显示属性</h2><p>display 属性的值很多，但常用的除了前面提到的控制块级元素、行内元素和行内块级元素的 block 、 inline 和 inline-block 以外，还有一个比较常用的就是 none ，把元素的 display 属性的值设定为 none 后，该元素及所包含在其中的元素，都不会在页面中显示。他们原先战局的所有空间都会被「回收」，就好像相关元素根本不存在一样。<br>与此类似的属性还有 visibility ，这个属性常用的两个值是 visible (默认值) 和 hidden ，把元素的 visibility 属性的值设定成 hidden ，元素会被隐藏，但它还会占据页面中原来的空间位置。<br>笔者觉得有点类似定位中 absolute 和 relative 的感觉，就是 absolute 定位的元素的原来的位置会被「回收」（脱离文档流），就好像元素根本不存在一样（指的是原来占据的位置不存在一样）， relative 定位的元素还会占据页面中原来的空间位置。</p>
<p><strong>总结</strong>  </p>
<blockquote>
<p>本章的内容不少，都是一些很重要的概念，比如盒模型、定位元素、浮动与清除浮动和元素背景属性。</p>
<ol>
<li>margin、padding的属性值顺序均为 上右下左</li>
<li>垂直方向上的margin外边距会叠加，取较大值。水平方向则不会，两者之间间距为两者之间margin外间距之和。</li>
<li>围住浮动元素的三种方法： 一：为父元素添加overflow:hidden   二：同时浮动父元素   三：添加非浮动的清除元素(写一个class，里面包含clear属性)</li>
</ol>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从右向左阅读r的定义]]></title>
      <url>http://hangweiping.github.io/2014/12/25/%E4%BB%8E%E5%8F%B3%E5%90%91%E5%B7%A6%E9%98%85%E8%AF%BBr%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<h3 id="指向指针的引用-从右向左"><a href="#指向指针的引用-从右向左" class="headerlink" title="指向指针的引用(从右向左)"></a>指向指针的引用(从右向左)</h3><p>引用本身不是对象，所以不能定义指向引用的指针，但指针是对象，所以存在对指针的引用  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>；</div><div class="line"><span class="keyword">int</span> *p;      <span class="comment">//p是int 指针</span></div><div class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">//r是一个对指针p的引用</span></div><div class="line">r = &amp;i;      <span class="comment">//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span></div><div class="line">*r = <span class="number">0</span>;      <span class="comment">//解引用r得到i,也就是p指向的对象，将i值改为0</span></div></pre></td></tr></table></figure>
 <a id="more"></a>
<p> 要理解一个变量类型到底是什么，最简单的就是从右向左阅读r的定义，离变量名进的符号对变量的类型有直接的影响。因此r是一个引用，声明符的其余部分用来确定r引用的类型是什么，*说明r引用的是一个指针。最后声明的基本数据类型指出r引用的是一个int指针.</p>
<h3 id="const指针-从右向左"><a href="#const指针-从右向左" class="headerlink" title="const指针(从右向左)"></a>const指针(从右向左)</h3><p> 所以的指针的类型都要和它所指的对象严格匹配，除了(1)允许令一个指向常量的指针指向一个非常量对象(2)暂时不需知道</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</div><div class="line"><span class="keyword">double</span> *ptr = &amp;pi;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;</div><div class="line">*cptr = <span class="number">42</span>;</div></pre></td></tr></table></figure>
<p>谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变</p>
<hr>
<p>指针是对象,const修饰符修饰一个变量，则此变量的值在初始化之后无法改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;<span class="comment">//curErr将一直指向errNumb</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;<span class="comment">//pip是一个指向常量对象的常量指针</span></div></pre></td></tr></table></figure>
<p> 指针本身是一个常量并不意味着不通过指针修改其所指对象的值，能否这样做完全取决于所指对象的类型.所</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://hangweiping.github.io/2014/12/24/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
